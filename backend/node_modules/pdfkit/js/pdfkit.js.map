{"version":3,"file":"pdfkit.js","sources":["../lib/abstract_reference.js","../lib/tree.js","../lib/spotcolor.js","../lib/object.js","../lib/reference.js","../lib/utils.js","../lib/page.js","../lib/name_tree.js","../lib/saslprep/lib/util.js","../lib/saslprep/lib/code-points.js","../lib/saslprep/index.js","../lib/security.js","../lib/gradient.js","../lib/pattern.js","../lib/mixins/color.js","../lib/path.js","../lib/mixins/vector.js","../lib/font/afm.js","../lib/font.js","../lib/font/standard.js","../lib/font/embedded.js","../lib/font_factory.js","../lib/mixins/fonts.js","../lib/line_wrapper.js","../lib/mixins/text.js","../lib/image/jpeg.js","../lib/image/png.js","../lib/image.js","../lib/mixins/images.js","../lib/mixins/annotations.js","../lib/outline.js","../lib/mixins/outline.js","../lib/structure_content.js","../lib/structure_element.js","../lib/number_tree.js","../lib/mixins/markings.js","../lib/mixins/acroform.js","../lib/mixins/attachments.js","../lib/mixins/pdfa.js","../lib/mixins/pdfua.js","../lib/mixins/subsets.js","../lib/table/utils.js","../lib/table/style.js","../lib/table/normalize.js","../lib/table/size.js","../lib/table/accessibility.js","../lib/table/render.js","../lib/table/index.js","../lib/mixins/table.js","../lib/metadata.js","../lib/mixins/metadata.js","../lib/document.js"],"sourcesContent":["/*\nPDFAbstractReference - abstract class for PDF reference\n*/\n\nclass PDFAbstractReference {\n  toString() {\n    throw new Error('Must be implemented by subclasses');\n  }\n}\n\nexport default PDFAbstractReference;\n","/*\nPDFTree - abstract base class for name and number tree objects\n*/\n\nimport PDFObject from './object';\n\nclass PDFTree {\n  constructor(options = {}) {\n    this._items = {};\n    // disable /Limits output for this tree\n    this.limits = typeof options.limits === 'boolean' ? options.limits : true;\n  }\n\n  add(key, val) {\n    return (this._items[key] = val);\n  }\n\n  get(key) {\n    return this._items[key];\n  }\n\n  toString() {\n    // Needs to be sorted by key\n    const sortedKeys = Object.keys(this._items).sort((a, b) =>\n      this._compareKeys(a, b),\n    );\n\n    const out = ['<<'];\n    if (this.limits && sortedKeys.length > 1) {\n      const first = sortedKeys[0],\n        last = sortedKeys[sortedKeys.length - 1];\n      out.push(\n        `  /Limits ${PDFObject.convert([this._dataForKey(first), this._dataForKey(last)])}`,\n      );\n    }\n    out.push(`  /${this._keysName()} [`);\n    for (let key of sortedKeys) {\n      out.push(\n        `    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(\n          this._items[key],\n        )}`,\n      );\n    }\n    out.push(']');\n    out.push('>>');\n    return out.join('\\n');\n  }\n\n  _compareKeys(/*a, b*/) {\n    throw new Error('Must be implemented by subclasses');\n  }\n\n  _keysName() {\n    throw new Error('Must be implemented by subclasses');\n  }\n\n  _dataForKey(/*k*/) {\n    throw new Error('Must be implemented by subclasses');\n  }\n}\n\nexport default PDFTree;\n","export default class SpotColor {\n  constructor(doc, name, C, M, Y, K) {\n    this.id = 'CS' + Object.keys(doc.spotColors).length;\n    this.name = name;\n    this.values = [C, M, Y, K];\n    this.ref = doc.ref([\n      'Separation',\n      this.name,\n      'DeviceCMYK',\n      {\n        Range: [0, 1, 0, 1, 0, 1, 0, 1],\n        C0: [0, 0, 0, 0],\n        C1: this.values.map((value) => value / 100),\n        FunctionType: 2,\n        Domain: [0, 1],\n        N: 1,\n      },\n    ]);\n    this.ref.end();\n  }\n\n  toString() {\n    return `${this.ref.id} 0 R`;\n  }\n}\n","/*\nPDFObject - converts JavaScript types into their corresponding PDF types.\nBy Devon Govett\n*/\n\nimport PDFAbstractReference from './abstract_reference';\nimport PDFTree from './tree';\nimport SpotColor from './spotcolor';\n\nconst pad = (str, length) => (Array(length + 1).join('0') + str).slice(-length);\n\nconst escapableRe = /[\\n\\r\\t\\b\\f()\\\\]/g;\nconst escapable = {\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\\\': '\\\\\\\\',\n  '(': '\\\\(',\n  ')': '\\\\)',\n};\n\n// Convert little endian UTF-16 to big endian\nconst swapBytes = function (buff) {\n  const l = buff.length;\n  if (l & 0x01) {\n    throw new Error('Buffer length must be even');\n  } else {\n    for (let i = 0, end = l - 1; i < end; i += 2) {\n      const a = buff[i];\n      buff[i] = buff[i + 1];\n      buff[i + 1] = a;\n    }\n  }\n\n  return buff;\n};\n\nclass PDFObject {\n  static convert(object, encryptFn = null) {\n    // String literals are converted to the PDF name type\n    if (typeof object === 'string') {\n      return `/${object}`;\n\n      // String objects are converted to PDF strings (UTF-16)\n    } else if (object instanceof String) {\n      let string = object;\n      // Detect if this is a unicode string\n      let isUnicode = false;\n      for (let i = 0, end = string.length; i < end; i++) {\n        if (string.charCodeAt(i) > 0x7f) {\n          isUnicode = true;\n          break;\n        }\n      }\n\n      // If so, encode it as big endian UTF-16\n      let stringBuffer;\n      if (isUnicode) {\n        stringBuffer = swapBytes(Buffer.from(`\\ufeff${string}`, 'utf16le'));\n      } else {\n        stringBuffer = Buffer.from(string.valueOf(), 'ascii');\n      }\n\n      // Encrypt the string when necessary\n      if (encryptFn) {\n        string = encryptFn(stringBuffer).toString('binary');\n      } else {\n        string = stringBuffer.toString('binary');\n      }\n\n      // Escape characters as required by the spec\n      string = string.replace(escapableRe, (c) => escapable[c]);\n\n      return `(${string})`;\n\n      // Buffers are converted to PDF hex strings\n    } else if (Buffer.isBuffer(object)) {\n      return `<${object.toString('hex')}>`;\n    } else if (\n      object instanceof PDFAbstractReference ||\n      object instanceof PDFTree ||\n      object instanceof SpotColor\n    ) {\n      return object.toString();\n    } else if (object instanceof Date) {\n      let string =\n        `D:${pad(object.getUTCFullYear(), 4)}` +\n        pad(object.getUTCMonth() + 1, 2) +\n        pad(object.getUTCDate(), 2) +\n        pad(object.getUTCHours(), 2) +\n        pad(object.getUTCMinutes(), 2) +\n        pad(object.getUTCSeconds(), 2) +\n        'Z';\n\n      // Encrypt the string when necessary\n      if (encryptFn) {\n        string = encryptFn(Buffer.from(string, 'ascii')).toString('binary');\n\n        // Escape characters as required by the spec\n        string = string.replace(escapableRe, (c) => escapable[c]);\n      }\n\n      return `(${string})`;\n    } else if (Array.isArray(object)) {\n      const items = object\n        .map((e) => PDFObject.convert(e, encryptFn))\n        .join(' ');\n      return `[${items}]`;\n    } else if ({}.toString.call(object) === '[object Object]') {\n      const out = ['<<'];\n      for (let key in object) {\n        const val = object[key];\n        out.push(`/${key} ${PDFObject.convert(val, encryptFn)}`);\n      }\n\n      out.push('>>');\n      return out.join('\\n');\n    } else if (typeof object === 'number') {\n      return PDFObject.number(object);\n    } else {\n      return `${object}`;\n    }\n  }\n\n  static number(n) {\n    if (n > -1e21 && n < 1e21) {\n      return Math.round(n * 1e6) / 1e6;\n    }\n\n    throw new Error(`unsupported number: ${n}`);\n  }\n}\n\nexport default PDFObject;\n","/*\nPDFReference - represents a reference to another object in the PDF object heirarchy\nBy Devon Govett\n*/\n\nimport zlib from 'zlib';\nimport PDFAbstractReference from './abstract_reference';\nimport PDFObject from './object';\n\nclass PDFReference extends PDFAbstractReference {\n  constructor(document, id, data = {}) {\n    super();\n    this.document = document;\n    this.id = id;\n    this.data = data;\n    this.gen = 0;\n    this.compress = this.document.compress && !this.data.Filter;\n    this.uncompressedLength = 0;\n    this.buffer = [];\n  }\n\n  write(chunk) {\n    if (!(chunk instanceof Uint8Array)) {\n      chunk = Buffer.from(chunk + '\\n', 'binary');\n    }\n\n    this.uncompressedLength += chunk.length;\n    if (this.data.Length == null) {\n      this.data.Length = 0;\n    }\n    this.buffer.push(chunk);\n    this.data.Length += chunk.length;\n    if (this.compress) {\n      this.data.Filter = 'FlateDecode';\n    }\n  }\n\n  end(chunk) {\n    if (chunk) {\n      this.write(chunk);\n    }\n    this.finalize();\n  }\n\n  finalize() {\n    this.offset = this.document._offset;\n\n    const encryptFn = this.document._security\n      ? this.document._security.getEncryptFn(this.id, this.gen)\n      : null;\n\n    if (this.buffer.length) {\n      this.buffer = Buffer.concat(this.buffer);\n      if (this.compress) {\n        this.buffer = zlib.deflateSync(this.buffer);\n      }\n\n      if (encryptFn) {\n        this.buffer = encryptFn(this.buffer);\n      }\n\n      this.data.Length = this.buffer.length;\n    }\n\n    this.document._write(`${this.id} ${this.gen} obj`);\n    this.document._write(PDFObject.convert(this.data, encryptFn));\n\n    if (this.buffer.length) {\n      this.document._write('stream');\n      this.document._write(this.buffer);\n\n      this.buffer = []; // free up memory\n      this.document._write('\\nendstream');\n    }\n\n    this.document._write('endobj');\n    this.document._refEnd(this);\n  }\n  toString() {\n    return `${this.id} ${this.gen} R`;\n  }\n}\n\nexport default PDFReference;\n","const fArray = new Float32Array(1);\r\nconst uArray = new Uint32Array(fArray.buffer);\r\n\r\nexport function PDFNumber(n) {\r\n  // PDF numbers are strictly 32bit\r\n  // so convert this number to a 32bit number\r\n  // @see ISO 32000-1 Annex C.2 (real numbers)\r\n  const rounded = Math.fround(n);\r\n  if (rounded <= n) return rounded;\r\n\r\n  // Will have to perform 32bit float truncation\r\n  fArray[0] = n;\r\n\r\n  // Get the 32-bit representation as integer and shift bits\r\n  if (n <= 0) {\r\n    uArray[0] += 1;\r\n  } else {\r\n    uArray[0] -= 1;\r\n  }\r\n\r\n  // Return the float value\r\n  return fArray[0];\r\n}\r\n\r\n/**\r\n * Measurement of size\r\n *\r\n * @typedef {number | `${number}` | `${number}${'em' | 'in' | 'px' | 'cm' | 'mm' | 'pc' | 'ex' | 'ch' | 'rem' | 'vw' | 'vmin' | 'vmax' | '%' | 'pt'}`} Size\r\n */\r\n\r\n/**\r\n * @typedef {Array<PDFTilingPattern | PDFColor> | string | Array<number>} PDFColor\r\n */\r\n\r\n/** @typedef {string | Buffer | Uint8Array | ArrayBuffer} PDFFontSource */\r\n/**\r\n * Side definitions\r\n * - To define all sides, use a single value\r\n * - To define up-down left-right, use a `[Y, X]` array\r\n * - To define each side, use `[top, right, bottom, left]` array\r\n * - Or `{vertical: SideValue, horizontal: SideValue}`\r\n * - Or `{top: SideValue, right: SideValue, bottom: SideValue, left: SideValue}`\r\n *\r\n * @template T\r\n * @typedef {T | [T, T] | [T, T, T, T] | { vertical: T; horizontal: T } | ExpandedSideDefinition<T>} SideDefinition<T>\r\n **/\r\n\r\n/**\r\n * @template T\r\n * @typedef {{ top: T; right: T; bottom: T; left: T }} ExpandedSideDefinition<T>\r\n */\r\n\r\n/**\r\n * Convert any side definition into a static structure\r\n *\r\n * @template S\r\n * @template D\r\n * @template O\r\n * @template {S | D} T\r\n * @param {SideDefinition<S>} sides - The sides to convert\r\n * @param {SideDefinition<D>} defaultDefinition - The value to use when no definition is provided\r\n * @param {function(T): O} transformer - The transformation to apply to the sides once normalized\r\n * @returns {ExpandedSideDefinition<O>}\r\n */\r\nexport function normalizeSides(\r\n  sides,\r\n  defaultDefinition = undefined,\r\n  transformer = (v) => v,\r\n) {\r\n  if (\r\n    sides == null ||\r\n    (typeof sides === 'object' && Object.keys(sides).length === 0)\r\n  ) {\r\n    sides = defaultDefinition;\r\n  }\r\n  if (sides == null || typeof sides !== 'object') {\r\n    sides = { top: sides, right: sides, bottom: sides, left: sides };\r\n  } else if (Array.isArray(sides)) {\r\n    if (sides.length === 2) {\r\n      sides = { vertical: sides[0], horizontal: sides[1] };\r\n    } else {\r\n      sides = {\r\n        top: sides[0],\r\n        right: sides[1],\r\n        bottom: sides[2],\r\n        left: sides[3],\r\n      };\r\n    }\r\n  }\r\n\r\n  if ('vertical' in sides || 'horizontal' in sides) {\r\n    sides = {\r\n      top: sides.vertical,\r\n      right: sides.horizontal,\r\n      bottom: sides.vertical,\r\n      left: sides.horizontal,\r\n    };\r\n  }\r\n\r\n  return {\r\n    top: transformer(sides.top),\r\n    right: transformer(sides.right),\r\n    bottom: transformer(sides.bottom),\r\n    left: transformer(sides.left),\r\n  };\r\n}\r\n\r\nexport const MM_TO_CM = 1 / 10; // 1MM = 1CM\r\nexport const CM_TO_IN = 1 / 2.54; // 1CM = 1/2.54 IN\r\nexport const PX_TO_IN = 1 / 96; // 1 PX = 1/96 IN\r\nexport const IN_TO_PT = 72; // 1 IN = 72 PT\r\nexport const PC_TO_PT = 12; // 1 PC = 12 PT\r\n\r\n/**\r\n * Get cosine in degrees of a\r\n *\r\n * Rounding errors are handled\r\n * @param a\r\n * @returns {number}\r\n */\r\nexport function cosine(a) {\r\n  if (a === 0) return 1;\r\n  if (a === 90) return 0;\r\n  if (a === 180) return -1;\r\n  if (a === 270) return 0;\r\n  return Math.cos((a * Math.PI) / 180);\r\n}\r\n\r\n/**\r\n * Get sine in degrees of a\r\n *\r\n * Rounding errors are handled\r\n * @param a\r\n * @returns {number}\r\n */\r\nexport function sine(a) {\r\n  if (a === 0) return 0;\r\n  if (a === 90) return 1;\r\n  if (a === 180) return 0;\r\n  if (a === 270) return -1;\r\n  return Math.sin((a * Math.PI) / 180);\r\n}\r\n","/*\nPDFPage - represents a single page in the PDF document\nBy Devon Govett\n*/\n\nimport { normalizeSides } from './utils';\n\n/**\n * @type {SideDefinition<Size>}\n */\nconst DEFAULT_MARGINS = {\n  top: 72,\n  left: 72,\n  bottom: 72,\n  right: 72,\n};\n\nconst SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n};\n\nclass PDFPage {\n  constructor(document, options = {}) {\n    this.document = document;\n    this._options = options;\n    this.size = options.size || 'letter';\n    this.layout = options.layout || 'portrait';\n\n    // calculate page dimensions\n    const dimensions = Array.isArray(this.size)\n      ? this.size\n      : SIZES[this.size.toUpperCase()];\n    this.width = dimensions[this.layout === 'portrait' ? 0 : 1];\n    this.height = dimensions[this.layout === 'portrait' ? 1 : 0];\n\n    this.content = this.document.ref();\n\n    if (options.font) document.font(options.font, options.fontFamily);\n    if (options.fontSize) document.fontSize(options.fontSize);\n\n    // process margins\n    // Margin calculation must occur after font assignment to ensure any dynamic sizes are calculated correctly\n    this.margins = normalizeSides(\n      options.margin ?? options.margins,\n      DEFAULT_MARGINS,\n      (x) => document.sizeToPoint(x, 0, this),\n    );\n\n    // Initialize the Font, XObject, and ExtGState dictionaries\n    this.resources = this.document.ref({\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n    });\n\n    // The page dictionary\n    this.dictionary = this.document.ref({\n      Type: 'Page',\n      Parent: this.document._root.data.Pages,\n      MediaBox: [0, 0, this.width, this.height],\n      Contents: this.content,\n      Resources: this.resources,\n    });\n\n    this.markings = [];\n  }\n\n  // Lazily create these objects\n  get fonts() {\n    const data = this.resources.data;\n    return data.Font != null ? data.Font : (data.Font = {});\n  }\n\n  get xobjects() {\n    const data = this.resources.data;\n    return data.XObject != null ? data.XObject : (data.XObject = {});\n  }\n\n  get ext_gstates() {\n    const data = this.resources.data;\n    return data.ExtGState != null ? data.ExtGState : (data.ExtGState = {});\n  }\n\n  get patterns() {\n    const data = this.resources.data;\n    return data.Pattern != null ? data.Pattern : (data.Pattern = {});\n  }\n\n  get colorSpaces() {\n    const data = this.resources.data;\n    return data.ColorSpace || (data.ColorSpace = {});\n  }\n\n  get annotations() {\n    const data = this.dictionary.data;\n    return data.Annots != null ? data.Annots : (data.Annots = []);\n  }\n\n  get structParentTreeKey() {\n    const data = this.dictionary.data;\n    return data.StructParents != null\n      ? data.StructParents\n      : (data.StructParents = this.document.createStructParentTreeNextKey());\n  }\n\n  /**\n   * The width of the safe contents of a page\n   *\n   * @returns {number}\n   */\n  get contentWidth() {\n    return this.width - this.margins.left - this.margins.right;\n  }\n\n  /**\n   * The height of the safe contents of a page\n   *\n   * @returns {number}\n   */\n  get contentHeight() {\n    return this.height - this.margins.top - this.margins.bottom;\n  }\n\n  maxY() {\n    return this.height - this.margins.bottom;\n  }\n\n  write(chunk) {\n    return this.content.write(chunk);\n  }\n\n  // Set tab order if document is tagged for accessibility.\n  _setTabOrder() {\n    if (!this.dictionary.Tabs && this.document.hasMarkInfoDictionary()) {\n      this.dictionary.data.Tabs = 'S';\n    }\n  }\n\n  end() {\n    this._setTabOrder();\n    this.dictionary.end();\n    this.resources.data.ColorSpace = this.resources.data.ColorSpace || {};\n    for (let color of Object.values(this.document.spotColors)) {\n      this.resources.data.ColorSpace[color.id] = color;\n    }\n    this.resources.end();\n    return this.content.end();\n  }\n}\n\nexport default PDFPage;\n","/*\nPDFNameTree - represents a name tree object\n*/\n\nimport PDFTree from './tree';\n\nclass PDFNameTree extends PDFTree {\n  _compareKeys(a, b) {\n    return a.localeCompare(b);\n  }\n\n  _keysName() {\n    return 'Names';\n  }\n\n  _dataForKey(k) {\n    return new String(k);\n  }\n}\n\nexport default PDFNameTree;\n","/**\n * Check if value is in a range group.\n * @param {number} value\n * @param {number[]} rangeGroup\n * @returns {boolean}\n */\nfunction inRange(value, rangeGroup) {\n  if (value < rangeGroup[0]) return false;\n  let startRange = 0;\n  let endRange = rangeGroup.length / 2;\n  while (startRange <= endRange) {\n    const middleRange = Math.floor((startRange + endRange) / 2);\n\n    // actual array index\n    const arrayIndex = middleRange * 2;\n\n    // Check if value is in range pointed by actual index\n    if (\n      value >= rangeGroup[arrayIndex] &&\n      value <= rangeGroup[arrayIndex + 1]\n    ) {\n      return true;\n    }\n\n    if (value > rangeGroup[arrayIndex + 1]) {\n      // Search Right Side Of Array\n      startRange = middleRange + 1;\n    } else {\n      // Search Left Side Of Array\n      endRange = middleRange - 1;\n    }\n  }\n  return false;\n}\n\nexport { inRange };\n","import { inRange } from './util';\n\n// prettier-ignore-start\n/**\n * A.1 Unassigned code points in Unicode 3.2\n * @link https://tools.ietf.org/html/rfc3454#appendix-A.1\n */\nconst unassigned_code_points = [\n  0x0221, 0x0221, 0x0234, 0x024f, 0x02ae, 0x02af, 0x02ef, 0x02ff, 0x0350,\n  0x035f, 0x0370, 0x0373, 0x0376, 0x0379, 0x037b, 0x037d, 0x037f, 0x0383,\n  0x038b, 0x038b, 0x038d, 0x038d, 0x03a2, 0x03a2, 0x03cf, 0x03cf, 0x03f7,\n  0x03ff, 0x0487, 0x0487, 0x04cf, 0x04cf, 0x04f6, 0x04f7, 0x04fa, 0x04ff,\n  0x0510, 0x0530, 0x0557, 0x0558, 0x0560, 0x0560, 0x0588, 0x0588, 0x058b,\n  0x0590, 0x05a2, 0x05a2, 0x05ba, 0x05ba, 0x05c5, 0x05cf, 0x05eb, 0x05ef,\n  0x05f5, 0x060b, 0x060d, 0x061a, 0x061c, 0x061e, 0x0620, 0x0620, 0x063b,\n  0x063f, 0x0656, 0x065f, 0x06ee, 0x06ef, 0x06ff, 0x06ff, 0x070e, 0x070e,\n  0x072d, 0x072f, 0x074b, 0x077f, 0x07b2, 0x0900, 0x0904, 0x0904, 0x093a,\n  0x093b, 0x094e, 0x094f, 0x0955, 0x0957, 0x0971, 0x0980, 0x0984, 0x0984,\n  0x098d, 0x098e, 0x0991, 0x0992, 0x09a9, 0x09a9, 0x09b1, 0x09b1, 0x09b3,\n  0x09b5, 0x09ba, 0x09bb, 0x09bd, 0x09bd, 0x09c5, 0x09c6, 0x09c9, 0x09ca,\n  0x09ce, 0x09d6, 0x09d8, 0x09db, 0x09de, 0x09de, 0x09e4, 0x09e5, 0x09fb,\n  0x0a01, 0x0a03, 0x0a04, 0x0a0b, 0x0a0e, 0x0a11, 0x0a12, 0x0a29, 0x0a29,\n  0x0a31, 0x0a31, 0x0a34, 0x0a34, 0x0a37, 0x0a37, 0x0a3a, 0x0a3b, 0x0a3d,\n  0x0a3d, 0x0a43, 0x0a46, 0x0a49, 0x0a4a, 0x0a4e, 0x0a58, 0x0a5d, 0x0a5d,\n  0x0a5f, 0x0a65, 0x0a75, 0x0a80, 0x0a84, 0x0a84, 0x0a8c, 0x0a8c, 0x0a8e,\n  0x0a8e, 0x0a92, 0x0a92, 0x0aa9, 0x0aa9, 0x0ab1, 0x0ab1, 0x0ab4, 0x0ab4,\n  0x0aba, 0x0abb, 0x0ac6, 0x0ac6, 0x0aca, 0x0aca, 0x0ace, 0x0acf, 0x0ad1,\n  0x0adf, 0x0ae1, 0x0ae5, 0x0af0, 0x0b00, 0x0b04, 0x0b04, 0x0b0d, 0x0b0e,\n  0x0b11, 0x0b12, 0x0b29, 0x0b29, 0x0b31, 0x0b31, 0x0b34, 0x0b35, 0x0b3a,\n  0x0b3b, 0x0b44, 0x0b46, 0x0b49, 0x0b4a, 0x0b4e, 0x0b55, 0x0b58, 0x0b5b,\n  0x0b5e, 0x0b5e, 0x0b62, 0x0b65, 0x0b71, 0x0b81, 0x0b84, 0x0b84, 0x0b8b,\n  0x0b8d, 0x0b91, 0x0b91, 0x0b96, 0x0b98, 0x0b9b, 0x0b9b, 0x0b9d, 0x0b9d,\n  0x0ba0, 0x0ba2, 0x0ba5, 0x0ba7, 0x0bab, 0x0bad, 0x0bb6, 0x0bb6, 0x0bba,\n  0x0bbd, 0x0bc3, 0x0bc5, 0x0bc9, 0x0bc9, 0x0bce, 0x0bd6, 0x0bd8, 0x0be6,\n  0x0bf3, 0x0c00, 0x0c04, 0x0c04, 0x0c0d, 0x0c0d, 0x0c11, 0x0c11, 0x0c29,\n  0x0c29, 0x0c34, 0x0c34, 0x0c3a, 0x0c3d, 0x0c45, 0x0c45, 0x0c49, 0x0c49,\n  0x0c4e, 0x0c54, 0x0c57, 0x0c5f, 0x0c62, 0x0c65, 0x0c70, 0x0c81, 0x0c84,\n  0x0c84, 0x0c8d, 0x0c8d, 0x0c91, 0x0c91, 0x0ca9, 0x0ca9, 0x0cb4, 0x0cb4,\n  0x0cba, 0x0cbd, 0x0cc5, 0x0cc5, 0x0cc9, 0x0cc9, 0x0cce, 0x0cd4, 0x0cd7,\n  0x0cdd, 0x0cdf, 0x0cdf, 0x0ce2, 0x0ce5, 0x0cf0, 0x0d01, 0x0d04, 0x0d04,\n  0x0d0d, 0x0d0d, 0x0d11, 0x0d11, 0x0d29, 0x0d29, 0x0d3a, 0x0d3d, 0x0d44,\n  0x0d45, 0x0d49, 0x0d49, 0x0d4e, 0x0d56, 0x0d58, 0x0d5f, 0x0d62, 0x0d65,\n  0x0d70, 0x0d81, 0x0d84, 0x0d84, 0x0d97, 0x0d99, 0x0db2, 0x0db2, 0x0dbc,\n  0x0dbc, 0x0dbe, 0x0dbf, 0x0dc7, 0x0dc9, 0x0dcb, 0x0dce, 0x0dd5, 0x0dd5,\n  0x0dd7, 0x0dd7, 0x0de0, 0x0df1, 0x0df5, 0x0e00, 0x0e3b, 0x0e3e, 0x0e5c,\n  0x0e80, 0x0e83, 0x0e83, 0x0e85, 0x0e86, 0x0e89, 0x0e89, 0x0e8b, 0x0e8c,\n  0x0e8e, 0x0e93, 0x0e98, 0x0e98, 0x0ea0, 0x0ea0, 0x0ea4, 0x0ea4, 0x0ea6,\n  0x0ea6, 0x0ea8, 0x0ea9, 0x0eac, 0x0eac, 0x0eba, 0x0eba, 0x0ebe, 0x0ebf,\n  0x0ec5, 0x0ec5, 0x0ec7, 0x0ec7, 0x0ece, 0x0ecf, 0x0eda, 0x0edb, 0x0ede,\n  0x0eff, 0x0f48, 0x0f48, 0x0f6b, 0x0f70, 0x0f8c, 0x0f8f, 0x0f98, 0x0f98,\n  0x0fbd, 0x0fbd, 0x0fcd, 0x0fce, 0x0fd0, 0x0fff, 0x1022, 0x1022, 0x1028,\n  0x1028, 0x102b, 0x102b, 0x1033, 0x1035, 0x103a, 0x103f, 0x105a, 0x109f,\n  0x10c6, 0x10cf, 0x10f9, 0x10fa, 0x10fc, 0x10ff, 0x115a, 0x115e, 0x11a3,\n  0x11a7, 0x11fa, 0x11ff, 0x1207, 0x1207, 0x1247, 0x1247, 0x1249, 0x1249,\n  0x124e, 0x124f, 0x1257, 0x1257, 0x1259, 0x1259, 0x125e, 0x125f, 0x1287,\n  0x1287, 0x1289, 0x1289, 0x128e, 0x128f, 0x12af, 0x12af, 0x12b1, 0x12b1,\n  0x12b6, 0x12b7, 0x12bf, 0x12bf, 0x12c1, 0x12c1, 0x12c6, 0x12c7, 0x12cf,\n  0x12cf, 0x12d7, 0x12d7, 0x12ef, 0x12ef, 0x130f, 0x130f, 0x1311, 0x1311,\n  0x1316, 0x1317, 0x131f, 0x131f, 0x1347, 0x1347, 0x135b, 0x1360, 0x137d,\n  0x139f, 0x13f5, 0x1400, 0x1677, 0x167f, 0x169d, 0x169f, 0x16f1, 0x16ff,\n  0x170d, 0x170d, 0x1715, 0x171f, 0x1737, 0x173f, 0x1754, 0x175f, 0x176d,\n  0x176d, 0x1771, 0x1771, 0x1774, 0x177f, 0x17dd, 0x17df, 0x17ea, 0x17ff,\n  0x180f, 0x180f, 0x181a, 0x181f, 0x1878, 0x187f, 0x18aa, 0x1dff, 0x1e9c,\n  0x1e9f, 0x1efa, 0x1eff, 0x1f16, 0x1f17, 0x1f1e, 0x1f1f, 0x1f46, 0x1f47,\n  0x1f4e, 0x1f4f, 0x1f58, 0x1f58, 0x1f5a, 0x1f5a, 0x1f5c, 0x1f5c, 0x1f5e,\n  0x1f5e, 0x1f7e, 0x1f7f, 0x1fb5, 0x1fb5, 0x1fc5, 0x1fc5, 0x1fd4, 0x1fd5,\n  0x1fdc, 0x1fdc, 0x1ff0, 0x1ff1, 0x1ff5, 0x1ff5, 0x1fff, 0x1fff, 0x2053,\n  0x2056, 0x2058, 0x205e, 0x2064, 0x2069, 0x2072, 0x2073, 0x208f, 0x209f,\n  0x20b2, 0x20cf, 0x20eb, 0x20ff, 0x213b, 0x213c, 0x214c, 0x2152, 0x2184,\n  0x218f, 0x23cf, 0x23ff, 0x2427, 0x243f, 0x244b, 0x245f, 0x24ff, 0x24ff,\n  0x2614, 0x2615, 0x2618, 0x2618, 0x267e, 0x267f, 0x268a, 0x2700, 0x2705,\n  0x2705, 0x270a, 0x270b, 0x2728, 0x2728, 0x274c, 0x274c, 0x274e, 0x274e,\n  0x2753, 0x2755, 0x2757, 0x2757, 0x275f, 0x2760, 0x2795, 0x2797, 0x27b0,\n  0x27b0, 0x27bf, 0x27cf, 0x27ec, 0x27ef, 0x2b00, 0x2e7f, 0x2e9a, 0x2e9a,\n  0x2ef4, 0x2eff, 0x2fd6, 0x2fef, 0x2ffc, 0x2fff, 0x3040, 0x3040, 0x3097,\n  0x3098, 0x3100, 0x3104, 0x312d, 0x3130, 0x318f, 0x318f, 0x31b8, 0x31ef,\n  0x321d, 0x321f, 0x3244, 0x3250, 0x327c, 0x327e, 0x32cc, 0x32cf, 0x32ff,\n  0x32ff, 0x3377, 0x337a, 0x33de, 0x33df, 0x33ff, 0x33ff, 0x4db6, 0x4dff,\n  0x9fa6, 0x9fff, 0xa48d, 0xa48f, 0xa4c7, 0xabff, 0xd7a4, 0xd7ff, 0xfa2e,\n  0xfa2f, 0xfa6b, 0xfaff, 0xfb07, 0xfb12, 0xfb18, 0xfb1c, 0xfb37, 0xfb37,\n  0xfb3d, 0xfb3d, 0xfb3f, 0xfb3f, 0xfb42, 0xfb42, 0xfb45, 0xfb45, 0xfbb2,\n  0xfbd2, 0xfd40, 0xfd4f, 0xfd90, 0xfd91, 0xfdc8, 0xfdcf, 0xfdfd, 0xfdff,\n  0xfe10, 0xfe1f, 0xfe24, 0xfe2f, 0xfe47, 0xfe48, 0xfe53, 0xfe53, 0xfe67,\n  0xfe67, 0xfe6c, 0xfe6f, 0xfe75, 0xfe75, 0xfefd, 0xfefe, 0xff00, 0xff00,\n  0xffbf, 0xffc1, 0xffc8, 0xffc9, 0xffd0, 0xffd1, 0xffd8, 0xffd9, 0xffdd,\n  0xffdf, 0xffe7, 0xffe7, 0xffef, 0xfff8, 0x10000, 0x102ff, 0x1031f, 0x1031f,\n  0x10324, 0x1032f, 0x1034b, 0x103ff, 0x10426, 0x10427, 0x1044e, 0x1cfff,\n  0x1d0f6, 0x1d0ff, 0x1d127, 0x1d129, 0x1d1de, 0x1d3ff, 0x1d455, 0x1d455,\n  0x1d49d, 0x1d49d, 0x1d4a0, 0x1d4a1, 0x1d4a3, 0x1d4a4, 0x1d4a7, 0x1d4a8,\n  0x1d4ad, 0x1d4ad, 0x1d4ba, 0x1d4ba, 0x1d4bc, 0x1d4bc, 0x1d4c1, 0x1d4c1,\n  0x1d4c4, 0x1d4c4, 0x1d506, 0x1d506, 0x1d50b, 0x1d50c, 0x1d515, 0x1d515,\n  0x1d51d, 0x1d51d, 0x1d53a, 0x1d53a, 0x1d53f, 0x1d53f, 0x1d545, 0x1d545,\n  0x1d547, 0x1d549, 0x1d551, 0x1d551, 0x1d6a4, 0x1d6a7, 0x1d7ca, 0x1d7cd,\n  0x1d800, 0x1fffd, 0x2a6d7, 0x2f7ff, 0x2fa1e, 0x2fffd, 0x30000, 0x3fffd,\n  0x40000, 0x4fffd, 0x50000, 0x5fffd, 0x60000, 0x6fffd, 0x70000, 0x7fffd,\n  0x80000, 0x8fffd, 0x90000, 0x9fffd, 0xa0000, 0xafffd, 0xb0000, 0xbfffd,\n  0xc0000, 0xcfffd, 0xd0000, 0xdfffd, 0xe0000, 0xe0000, 0xe0002, 0xe001f,\n  0xe0080, 0xefffd,\n];\n// prettier-ignore-end\n\nconst isUnassignedCodePoint = (character) =>\n  inRange(character, unassigned_code_points);\n\n// prettier-ignore-start\n/**\n * B.1 Commonly mapped to nothing\n * @link https://tools.ietf.org/html/rfc3454#appendix-B.1\n */\nconst commonly_mapped_to_nothing = [\n  0x00ad, 0x00ad, 0x034f, 0x034f, 0x1806, 0x1806, 0x180b, 0x180b, 0x180c,\n  0x180c, 0x180d, 0x180d, 0x200b, 0x200b, 0x200c, 0x200c, 0x200d, 0x200d,\n  0x2060, 0x2060, 0xfe00, 0xfe00, 0xfe01, 0xfe01, 0xfe02, 0xfe02, 0xfe03,\n  0xfe03, 0xfe04, 0xfe04, 0xfe05, 0xfe05, 0xfe06, 0xfe06, 0xfe07, 0xfe07,\n  0xfe08, 0xfe08, 0xfe09, 0xfe09, 0xfe0a, 0xfe0a, 0xfe0b, 0xfe0b, 0xfe0c,\n  0xfe0c, 0xfe0d, 0xfe0d, 0xfe0e, 0xfe0e, 0xfe0f, 0xfe0f, 0xfeff, 0xfeff,\n];\n// prettier-ignore-end\n\nconst isCommonlyMappedToNothing = (character) =>\n  inRange(character, commonly_mapped_to_nothing);\n\n// prettier-ignore-start\n/**\n * C.1.2 Non-ASCII space characters\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.1.2\n */\nconst non_ASCII_space_characters = [\n  0x00a0, 0x00a0 /* NO-BREAK SPACE */, 0x1680, 0x1680 /* OGHAM SPACE MARK */,\n  0x2000, 0x2000 /* EN QUAD */, 0x2001, 0x2001 /* EM QUAD */, 0x2002,\n  0x2002 /* EN SPACE */, 0x2003, 0x2003 /* EM SPACE */, 0x2004,\n  0x2004 /* THREE-PER-EM SPACE */, 0x2005, 0x2005 /* FOUR-PER-EM SPACE */,\n  0x2006, 0x2006 /* SIX-PER-EM SPACE */, 0x2007, 0x2007 /* FIGURE SPACE */,\n  0x2008, 0x2008 /* PUNCTUATION SPACE */, 0x2009, 0x2009 /* THIN SPACE */,\n  0x200a, 0x200a /* HAIR SPACE */, 0x200b, 0x200b /* ZERO WIDTH SPACE */,\n  0x202f, 0x202f /* NARROW NO-BREAK SPACE */, 0x205f,\n  0x205f /* MEDIUM MATHEMATICAL SPACE */, 0x3000,\n  0x3000 /* IDEOGRAPHIC SPACE */,\n];\n// prettier-ignore-end\n\nconst isNonASCIISpaceCharacter = (character) =>\n  inRange(character, non_ASCII_space_characters);\n\n// prettier-ignore-start\nconst non_ASCII_controls_characters = [\n  /**\n   * C.2.2 Non-ASCII control characters\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.2.2\n   */\n  0x0080, 0x009f /* [CONTROL CHARACTERS] */, 0x06dd,\n  0x06dd /* ARABIC END OF AYAH */, 0x070f,\n  0x070f /* SYRIAC ABBREVIATION MARK */, 0x180e,\n  0x180e /* MONGOLIAN VOWEL SEPARATOR */, 0x200c,\n  0x200c /* ZERO WIDTH NON-JOINER */, 0x200d, 0x200d /* ZERO WIDTH JOINER */,\n  0x2028, 0x2028 /* LINE SEPARATOR */, 0x2029, 0x2029 /* PARAGRAPH SEPARATOR */,\n  0x2060, 0x2060 /* WORD JOINER */, 0x2061, 0x2061 /* FUNCTION APPLICATION */,\n  0x2062, 0x2062 /* INVISIBLE TIMES */, 0x2063,\n  0x2063 /* INVISIBLE SEPARATOR */, 0x206a, 0x206f /* [CONTROL CHARACTERS] */,\n  0xfeff, 0xfeff /* ZERO WIDTH NO-BREAK SPACE */, 0xfff9,\n  0xfffc /* [CONTROL CHARACTERS] */, 0x1d173,\n  0x1d17a /* [MUSICAL CONTROL CHARACTERS] */,\n];\n\nconst non_character_codepoints = [\n  /**\n   * C.4 Non-character code points\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.4\n   */\n  0xfdd0, 0xfdef /* [NONCHARACTER CODE POINTS] */, 0xfffe,\n  0xffff /* [NONCHARACTER CODE POINTS] */, 0x1fffe,\n  0x1ffff /* [NONCHARACTER CODE POINTS] */, 0x2fffe,\n  0x2ffff /* [NONCHARACTER CODE POINTS] */, 0x3fffe,\n  0x3ffff /* [NONCHARACTER CODE POINTS] */, 0x4fffe,\n  0x4ffff /* [NONCHARACTER CODE POINTS] */, 0x5fffe,\n  0x5ffff /* [NONCHARACTER CODE POINTS] */, 0x6fffe,\n  0x6ffff /* [NONCHARACTER CODE POINTS] */, 0x7fffe,\n  0x7ffff /* [NONCHARACTER CODE POINTS] */, 0x8fffe,\n  0x8ffff /* [NONCHARACTER CODE POINTS] */, 0x9fffe,\n  0x9ffff /* [NONCHARACTER CODE POINTS] */, 0xafffe,\n  0xaffff /* [NONCHARACTER CODE POINTS] */, 0xbfffe,\n  0xbffff /* [NONCHARACTER CODE POINTS] */, 0xcfffe,\n  0xcffff /* [NONCHARACTER CODE POINTS] */, 0xdfffe,\n  0xdffff /* [NONCHARACTER CODE POINTS] */, 0xefffe,\n  0xeffff /* [NONCHARACTER CODE POINTS] */, 0x10fffe,\n  0x10ffff /* [NONCHARACTER CODE POINTS] */,\n];\n\n/**\n * 2.3.  Prohibited Output\n */\nconst prohibited_characters = [\n  /**\n   * C.2.1 ASCII control characters\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.2.1\n   */\n  0, 0x001f /* [CONTROL CHARACTERS] */, 0x007f, 0x007f /* DELETE */,\n\n  /**\n   * C.8 Change display properties or are deprecated\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.8\n   */\n  0x0340, 0x0340 /* COMBINING GRAVE TONE MARK */, 0x0341,\n  0x0341 /* COMBINING ACUTE TONE MARK */, 0x200e,\n  0x200e /* LEFT-TO-RIGHT MARK */, 0x200f, 0x200f /* RIGHT-TO-LEFT MARK */,\n  0x202a, 0x202a /* LEFT-TO-RIGHT EMBEDDING */, 0x202b,\n  0x202b /* RIGHT-TO-LEFT EMBEDDING */, 0x202c,\n  0x202c /* POP DIRECTIONAL FORMATTING */, 0x202d,\n  0x202d /* LEFT-TO-RIGHT OVERRIDE */, 0x202e,\n  0x202e /* RIGHT-TO-LEFT OVERRIDE */, 0x206a,\n  0x206a /* INHIBIT SYMMETRIC SWAPPING */, 0x206b,\n  0x206b /* ACTIVATE SYMMETRIC SWAPPING */, 0x206c,\n  0x206c /* INHIBIT ARABIC FORM SHAPING */, 0x206d,\n  0x206d /* ACTIVATE ARABIC FORM SHAPING */, 0x206e,\n  0x206e /* NATIONAL DIGIT SHAPES */, 0x206f, 0x206f /* NOMINAL DIGIT SHAPES */,\n\n  /**\n   * C.7 Inappropriate for canonical representation\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.7\n   */\n  0x2ff0, 0x2ffb /* [IDEOGRAPHIC DESCRIPTION CHARACTERS] */,\n\n  /**\n   * C.5 Surrogate codes\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.5\n   */\n  0xd800, 0xdfff,\n\n  /**\n   * C.3 Private use\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.3\n   */\n  0xe000, 0xf8ff /* [PRIVATE USE, PLANE 0] */,\n\n  /**\n   * C.6 Inappropriate for plain text\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.6\n   */\n  0xfff9, 0xfff9 /* INTERLINEAR ANNOTATION ANCHOR */, 0xfffa,\n  0xfffa /* INTERLINEAR ANNOTATION SEPARATOR */, 0xfffb,\n  0xfffb /* INTERLINEAR ANNOTATION TERMINATOR */, 0xfffc,\n  0xfffc /* OBJECT REPLACEMENT CHARACTER */, 0xfffd,\n  0xfffd /* REPLACEMENT CHARACTER */,\n\n  /**\n   * C.9 Tagging characters\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.9\n   */\n  0xe0001, 0xe0001 /* LANGUAGE TAG */, 0xe0020,\n  0xe007f /* [TAGGING CHARACTERS] */,\n\n  /**\n   * C.3 Private use\n   * @link https://tools.ietf.org/html/rfc3454#appendix-C.3\n   */\n\n  0xf0000, 0xffffd /* [PRIVATE USE, PLANE 15] */, 0x100000,\n  0x10fffd /* [PRIVATE USE, PLANE 16] */,\n];\n// prettier-ignore-end\n\nconst isProhibitedCharacter = (character) =>\n  inRange(character, non_ASCII_space_characters) ||\n  inRange(character, prohibited_characters) ||\n  inRange(character, non_ASCII_controls_characters) ||\n  inRange(character, non_character_codepoints);\n\n// prettier-ignore-start\n/**\n * D.1 Characters with bidirectional property \"R\" or \"AL\"\n * @link https://tools.ietf.org/html/rfc3454#appendix-D.1\n */\nconst bidirectional_r_al = [\n  0x05be, 0x05be, 0x05c0, 0x05c0, 0x05c3, 0x05c3, 0x05d0, 0x05ea, 0x05f0,\n  0x05f4, 0x061b, 0x061b, 0x061f, 0x061f, 0x0621, 0x063a, 0x0640, 0x064a,\n  0x066d, 0x066f, 0x0671, 0x06d5, 0x06dd, 0x06dd, 0x06e5, 0x06e6, 0x06fa,\n  0x06fe, 0x0700, 0x070d, 0x0710, 0x0710, 0x0712, 0x072c, 0x0780, 0x07a5,\n  0x07b1, 0x07b1, 0x200f, 0x200f, 0xfb1d, 0xfb1d, 0xfb1f, 0xfb28, 0xfb2a,\n  0xfb36, 0xfb38, 0xfb3c, 0xfb3e, 0xfb3e, 0xfb40, 0xfb41, 0xfb43, 0xfb44,\n  0xfb46, 0xfbb1, 0xfbd3, 0xfd3d, 0xfd50, 0xfd8f, 0xfd92, 0xfdc7, 0xfdf0,\n  0xfdfc, 0xfe70, 0xfe74, 0xfe76, 0xfefc,\n];\n// prettier-ignore-end\n\nconst isBidirectionalRAL = (character) =>\n  inRange(character, bidirectional_r_al);\n\n// prettier-ignore-start\n/**\n * D.2 Characters with bidirectional property \"L\"\n * @link https://tools.ietf.org/html/rfc3454#appendix-D.2\n */\nconst bidirectional_l = [\n  0x0041, 0x005a, 0x0061, 0x007a, 0x00aa, 0x00aa, 0x00b5, 0x00b5, 0x00ba,\n  0x00ba, 0x00c0, 0x00d6, 0x00d8, 0x00f6, 0x00f8, 0x0220, 0x0222, 0x0233,\n  0x0250, 0x02ad, 0x02b0, 0x02b8, 0x02bb, 0x02c1, 0x02d0, 0x02d1, 0x02e0,\n  0x02e4, 0x02ee, 0x02ee, 0x037a, 0x037a, 0x0386, 0x0386, 0x0388, 0x038a,\n  0x038c, 0x038c, 0x038e, 0x03a1, 0x03a3, 0x03ce, 0x03d0, 0x03f5, 0x0400,\n  0x0482, 0x048a, 0x04ce, 0x04d0, 0x04f5, 0x04f8, 0x04f9, 0x0500, 0x050f,\n  0x0531, 0x0556, 0x0559, 0x055f, 0x0561, 0x0587, 0x0589, 0x0589, 0x0903,\n  0x0903, 0x0905, 0x0939, 0x093d, 0x0940, 0x0949, 0x094c, 0x0950, 0x0950,\n  0x0958, 0x0961, 0x0964, 0x0970, 0x0982, 0x0983, 0x0985, 0x098c, 0x098f,\n  0x0990, 0x0993, 0x09a8, 0x09aa, 0x09b0, 0x09b2, 0x09b2, 0x09b6, 0x09b9,\n  0x09be, 0x09c0, 0x09c7, 0x09c8, 0x09cb, 0x09cc, 0x09d7, 0x09d7, 0x09dc,\n  0x09dd, 0x09df, 0x09e1, 0x09e6, 0x09f1, 0x09f4, 0x09fa, 0x0a05, 0x0a0a,\n  0x0a0f, 0x0a10, 0x0a13, 0x0a28, 0x0a2a, 0x0a30, 0x0a32, 0x0a33, 0x0a35,\n  0x0a36, 0x0a38, 0x0a39, 0x0a3e, 0x0a40, 0x0a59, 0x0a5c, 0x0a5e, 0x0a5e,\n  0x0a66, 0x0a6f, 0x0a72, 0x0a74, 0x0a83, 0x0a83, 0x0a85, 0x0a8b, 0x0a8d,\n  0x0a8d, 0x0a8f, 0x0a91, 0x0a93, 0x0aa8, 0x0aaa, 0x0ab0, 0x0ab2, 0x0ab3,\n  0x0ab5, 0x0ab9, 0x0abd, 0x0ac0, 0x0ac9, 0x0ac9, 0x0acb, 0x0acc, 0x0ad0,\n  0x0ad0, 0x0ae0, 0x0ae0, 0x0ae6, 0x0aef, 0x0b02, 0x0b03, 0x0b05, 0x0b0c,\n  0x0b0f, 0x0b10, 0x0b13, 0x0b28, 0x0b2a, 0x0b30, 0x0b32, 0x0b33, 0x0b36,\n  0x0b39, 0x0b3d, 0x0b3e, 0x0b40, 0x0b40, 0x0b47, 0x0b48, 0x0b4b, 0x0b4c,\n  0x0b57, 0x0b57, 0x0b5c, 0x0b5d, 0x0b5f, 0x0b61, 0x0b66, 0x0b70, 0x0b83,\n  0x0b83, 0x0b85, 0x0b8a, 0x0b8e, 0x0b90, 0x0b92, 0x0b95, 0x0b99, 0x0b9a,\n  0x0b9c, 0x0b9c, 0x0b9e, 0x0b9f, 0x0ba3, 0x0ba4, 0x0ba8, 0x0baa, 0x0bae,\n  0x0bb5, 0x0bb7, 0x0bb9, 0x0bbe, 0x0bbf, 0x0bc1, 0x0bc2, 0x0bc6, 0x0bc8,\n  0x0bca, 0x0bcc, 0x0bd7, 0x0bd7, 0x0be7, 0x0bf2, 0x0c01, 0x0c03, 0x0c05,\n  0x0c0c, 0x0c0e, 0x0c10, 0x0c12, 0x0c28, 0x0c2a, 0x0c33, 0x0c35, 0x0c39,\n  0x0c41, 0x0c44, 0x0c60, 0x0c61, 0x0c66, 0x0c6f, 0x0c82, 0x0c83, 0x0c85,\n  0x0c8c, 0x0c8e, 0x0c90, 0x0c92, 0x0ca8, 0x0caa, 0x0cb3, 0x0cb5, 0x0cb9,\n  0x0cbe, 0x0cbe, 0x0cc0, 0x0cc4, 0x0cc7, 0x0cc8, 0x0cca, 0x0ccb, 0x0cd5,\n  0x0cd6, 0x0cde, 0x0cde, 0x0ce0, 0x0ce1, 0x0ce6, 0x0cef, 0x0d02, 0x0d03,\n  0x0d05, 0x0d0c, 0x0d0e, 0x0d10, 0x0d12, 0x0d28, 0x0d2a, 0x0d39, 0x0d3e,\n  0x0d40, 0x0d46, 0x0d48, 0x0d4a, 0x0d4c, 0x0d57, 0x0d57, 0x0d60, 0x0d61,\n  0x0d66, 0x0d6f, 0x0d82, 0x0d83, 0x0d85, 0x0d96, 0x0d9a, 0x0db1, 0x0db3,\n  0x0dbb, 0x0dbd, 0x0dbd, 0x0dc0, 0x0dc6, 0x0dcf, 0x0dd1, 0x0dd8, 0x0ddf,\n  0x0df2, 0x0df4, 0x0e01, 0x0e30, 0x0e32, 0x0e33, 0x0e40, 0x0e46, 0x0e4f,\n  0x0e5b, 0x0e81, 0x0e82, 0x0e84, 0x0e84, 0x0e87, 0x0e88, 0x0e8a, 0x0e8a,\n  0x0e8d, 0x0e8d, 0x0e94, 0x0e97, 0x0e99, 0x0e9f, 0x0ea1, 0x0ea3, 0x0ea5,\n  0x0ea5, 0x0ea7, 0x0ea7, 0x0eaa, 0x0eab, 0x0ead, 0x0eb0, 0x0eb2, 0x0eb3,\n  0x0ebd, 0x0ebd, 0x0ec0, 0x0ec4, 0x0ec6, 0x0ec6, 0x0ed0, 0x0ed9, 0x0edc,\n  0x0edd, 0x0f00, 0x0f17, 0x0f1a, 0x0f34, 0x0f36, 0x0f36, 0x0f38, 0x0f38,\n  0x0f3e, 0x0f47, 0x0f49, 0x0f6a, 0x0f7f, 0x0f7f, 0x0f85, 0x0f85, 0x0f88,\n  0x0f8b, 0x0fbe, 0x0fc5, 0x0fc7, 0x0fcc, 0x0fcf, 0x0fcf, 0x1000, 0x1021,\n  0x1023, 0x1027, 0x1029, 0x102a, 0x102c, 0x102c, 0x1031, 0x1031, 0x1038,\n  0x1038, 0x1040, 0x1057, 0x10a0, 0x10c5, 0x10d0, 0x10f8, 0x10fb, 0x10fb,\n  0x1100, 0x1159, 0x115f, 0x11a2, 0x11a8, 0x11f9, 0x1200, 0x1206, 0x1208,\n  0x1246, 0x1248, 0x1248, 0x124a, 0x124d, 0x1250, 0x1256, 0x1258, 0x1258,\n  0x125a, 0x125d, 0x1260, 0x1286, 0x1288, 0x1288, 0x128a, 0x128d, 0x1290,\n  0x12ae, 0x12b0, 0x12b0, 0x12b2, 0x12b5, 0x12b8, 0x12be, 0x12c0, 0x12c0,\n  0x12c2, 0x12c5, 0x12c8, 0x12ce, 0x12d0, 0x12d6, 0x12d8, 0x12ee, 0x12f0,\n  0x130e, 0x1310, 0x1310, 0x1312, 0x1315, 0x1318, 0x131e, 0x1320, 0x1346,\n  0x1348, 0x135a, 0x1361, 0x137c, 0x13a0, 0x13f4, 0x1401, 0x1676, 0x1681,\n  0x169a, 0x16a0, 0x16f0, 0x1700, 0x170c, 0x170e, 0x1711, 0x1720, 0x1731,\n  0x1735, 0x1736, 0x1740, 0x1751, 0x1760, 0x176c, 0x176e, 0x1770, 0x1780,\n  0x17b6, 0x17be, 0x17c5, 0x17c7, 0x17c8, 0x17d4, 0x17da, 0x17dc, 0x17dc,\n  0x17e0, 0x17e9, 0x1810, 0x1819, 0x1820, 0x1877, 0x1880, 0x18a8, 0x1e00,\n  0x1e9b, 0x1ea0, 0x1ef9, 0x1f00, 0x1f15, 0x1f18, 0x1f1d, 0x1f20, 0x1f45,\n  0x1f48, 0x1f4d, 0x1f50, 0x1f57, 0x1f59, 0x1f59, 0x1f5b, 0x1f5b, 0x1f5d,\n  0x1f5d, 0x1f5f, 0x1f7d, 0x1f80, 0x1fb4, 0x1fb6, 0x1fbc, 0x1fbe, 0x1fbe,\n  0x1fc2, 0x1fc4, 0x1fc6, 0x1fcc, 0x1fd0, 0x1fd3, 0x1fd6, 0x1fdb, 0x1fe0,\n  0x1fec, 0x1ff2, 0x1ff4, 0x1ff6, 0x1ffc, 0x200e, 0x200e, 0x2071, 0x2071,\n  0x207f, 0x207f, 0x2102, 0x2102, 0x2107, 0x2107, 0x210a, 0x2113, 0x2115,\n  0x2115, 0x2119, 0x211d, 0x2124, 0x2124, 0x2126, 0x2126, 0x2128, 0x2128,\n  0x212a, 0x212d, 0x212f, 0x2131, 0x2133, 0x2139, 0x213d, 0x213f, 0x2145,\n  0x2149, 0x2160, 0x2183, 0x2336, 0x237a, 0x2395, 0x2395, 0x249c, 0x24e9,\n  0x3005, 0x3007, 0x3021, 0x3029, 0x3031, 0x3035, 0x3038, 0x303c, 0x3041,\n  0x3096, 0x309d, 0x309f, 0x30a1, 0x30fa, 0x30fc, 0x30ff, 0x3105, 0x312c,\n  0x3131, 0x318e, 0x3190, 0x31b7, 0x31f0, 0x321c, 0x3220, 0x3243, 0x3260,\n  0x327b, 0x327f, 0x32b0, 0x32c0, 0x32cb, 0x32d0, 0x32fe, 0x3300, 0x3376,\n  0x337b, 0x33dd, 0x33e0, 0x33fe, 0x3400, 0x4db5, 0x4e00, 0x9fa5, 0xa000,\n  0xa48c, 0xac00, 0xd7a3, 0xd800, 0xfa2d, 0xfa30, 0xfa6a, 0xfb00, 0xfb06,\n  0xfb13, 0xfb17, 0xff21, 0xff3a, 0xff41, 0xff5a, 0xff66, 0xffbe, 0xffc2,\n  0xffc7, 0xffca, 0xffcf, 0xffd2, 0xffd7, 0xffda, 0xffdc, 0x10300, 0x1031e,\n  0x10320, 0x10323, 0x10330, 0x1034a, 0x10400, 0x10425, 0x10428, 0x1044d,\n  0x1d000, 0x1d0f5, 0x1d100, 0x1d126, 0x1d12a, 0x1d166, 0x1d16a, 0x1d172,\n  0x1d183, 0x1d184, 0x1d18c, 0x1d1a9, 0x1d1ae, 0x1d1dd, 0x1d400, 0x1d454,\n  0x1d456, 0x1d49c, 0x1d49e, 0x1d49f, 0x1d4a2, 0x1d4a2, 0x1d4a5, 0x1d4a6,\n  0x1d4a9, 0x1d4ac, 0x1d4ae, 0x1d4b9, 0x1d4bb, 0x1d4bb, 0x1d4bd, 0x1d4c0,\n  0x1d4c2, 0x1d4c3, 0x1d4c5, 0x1d505, 0x1d507, 0x1d50a, 0x1d50d, 0x1d514,\n  0x1d516, 0x1d51c, 0x1d51e, 0x1d539, 0x1d53b, 0x1d53e, 0x1d540, 0x1d544,\n  0x1d546, 0x1d546, 0x1d54a, 0x1d550, 0x1d552, 0x1d6a3, 0x1d6a8, 0x1d7c9,\n  0x20000, 0x2a6d6, 0x2f800, 0x2fa1d, 0xf0000, 0xffffd, 0x100000, 0x10fffd,\n];\n// prettier-ignore-end\n\nconst isBidirectionalL = (character) => inRange(character, bidirectional_l);\n\nexport {\n  isUnassignedCodePoint,\n  isCommonlyMappedToNothing,\n  isNonASCIISpaceCharacter,\n  isProhibitedCharacter,\n  isBidirectionalRAL,\n  isBidirectionalL,\n};\n","import {\n  isUnassignedCodePoint,\n  isCommonlyMappedToNothing,\n  isNonASCIISpaceCharacter,\n  isProhibitedCharacter,\n  isBidirectionalRAL,\n  isBidirectionalL,\n} from './lib/code-points';\n\n// 2.1.  Mapping\n\n/**\n * non-ASCII space characters [StringPrep, C.1.2] that can be\n * mapped to SPACE (U+0020)\n */\nconst mapping2space = isNonASCIISpaceCharacter;\n\n/**\n * the \"commonly mapped to nothing\" characters [StringPrep, B.1]\n * that can be mapped to nothing.\n */\nconst mapping2nothing = isCommonlyMappedToNothing;\n\n// utils\nconst getCodePoint = (character) => character.codePointAt(0);\nconst first = (x) => x[0];\nconst last = (x) => x[x.length - 1];\n\n/**\n * Convert provided string into an array of Unicode Code Points.\n * Based on https://stackoverflow.com/a/21409165/1556249\n * and https://www.npmjs.com/package/code-point-at.\n * @param {string} input\n * @returns {number[]}\n */\nfunction toCodePoints(input) {\n  const codepoints = [];\n  const size = input.length;\n\n  for (let i = 0; i < size; i += 1) {\n    const before = input.charCodeAt(i);\n\n    if (before >= 0xd800 && before <= 0xdbff && size > i + 1) {\n      const next = input.charCodeAt(i + 1);\n\n      if (next >= 0xdc00 && next <= 0xdfff) {\n        codepoints.push((before - 0xd800) * 0x400 + next - 0xdc00 + 0x10000);\n        i += 1;\n        continue;\n      }\n    }\n\n    codepoints.push(before);\n  }\n\n  return codepoints;\n}\n\n/**\n * SASLprep.\n * @param {string} input\n * @param {Object} opts\n * @param {boolean} opts.allowUnassigned\n * @returns {string}\n */\nfunction saslprep(input, opts = {}) {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected string.');\n  }\n\n  if (input.length === 0) {\n    return '';\n  }\n\n  // 1. Map\n  const mapped_input = toCodePoints(input)\n    // 1.1 mapping to space\n    .map((character) => (mapping2space(character) ? 0x20 : character))\n    // 1.2 mapping to nothing\n    .filter((character) => !mapping2nothing(character));\n\n  // 2. Normalize\n  const normalized_input = String.fromCodePoint\n    .apply(null, mapped_input)\n    .normalize('NFKC');\n\n  const normalized_map = toCodePoints(normalized_input);\n\n  // 3. Prohibit\n  const hasProhibited = normalized_map.some(isProhibitedCharacter);\n\n  if (hasProhibited) {\n    throw new Error(\n      'Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3',\n    );\n  }\n\n  // Unassigned Code Points\n  if (opts.allowUnassigned !== true) {\n    const hasUnassigned = normalized_map.some(isUnassignedCodePoint);\n\n    if (hasUnassigned) {\n      throw new Error(\n        'Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5',\n      );\n    }\n  }\n\n  // 4. check bidi\n\n  const hasBidiRAL = normalized_map.some(isBidirectionalRAL);\n\n  const hasBidiL = normalized_map.some(isBidirectionalL);\n\n  // 4.1 If a string contains any RandALCat character, the string MUST NOT\n  // contain any LCat character.\n  if (hasBidiRAL && hasBidiL) {\n    throw new Error(\n      'String must not contain RandALCat and LCat at the same time,' +\n        ' see https://tools.ietf.org/html/rfc3454#section-6',\n    );\n  }\n\n  /**\n   * 4.2 If a string contains any RandALCat character, a RandALCat\n   * character MUST be the first character of the string, and a\n   * RandALCat character MUST be the last character of the string.\n   */\n\n  const isFirstBidiRAL = isBidirectionalRAL(\n    getCodePoint(first(normalized_input)),\n  );\n  const isLastBidiRAL = isBidirectionalRAL(\n    getCodePoint(last(normalized_input)),\n  );\n\n  if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {\n    throw new Error(\n      'Bidirectional RandALCat character must be the first and the last' +\n        ' character of the string, see https://tools.ietf.org/html/rfc3454#section-6',\n    );\n  }\n\n  return normalized_input;\n}\n\nexport default saslprep;\n","/*\n   PDFSecurity - represents PDF security settings\n   By Yang Liu <hi@zesik.com>\n */\n\nimport CryptoJS from 'crypto-js';\nimport saslprep from './saslprep/index';\n\nclass PDFSecurity {\n  static generateFileID(info = {}) {\n    let infoStr = `${info.CreationDate.getTime()}\\n`;\n\n    for (let key in info) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (!info.hasOwnProperty(key)) {\n        continue;\n      }\n      infoStr += `${key}: ${info[key].valueOf()}\\n`;\n    }\n\n    return wordArrayToBuffer(CryptoJS.MD5(infoStr));\n  }\n\n  static generateRandomWordArray(bytes) {\n    return CryptoJS.lib.WordArray.random(bytes);\n  }\n\n  static create(document, options = {}) {\n    if (!options.ownerPassword && !options.userPassword) {\n      return null;\n    }\n    return new PDFSecurity(document, options);\n  }\n\n  constructor(document, options = {}) {\n    if (!options.ownerPassword && !options.userPassword) {\n      throw new Error('None of owner password and user password is defined.');\n    }\n\n    this.document = document;\n    this._setupEncryption(options);\n  }\n\n  _setupEncryption(options) {\n    switch (options.pdfVersion) {\n      case '1.4':\n      case '1.5':\n        this.version = 2;\n        break;\n      case '1.6':\n      case '1.7':\n        this.version = 4;\n        break;\n      case '1.7ext3':\n        this.version = 5;\n        break;\n      default:\n        this.version = 1;\n        break;\n    }\n\n    const encDict = {\n      Filter: 'Standard',\n    };\n\n    switch (this.version) {\n      case 1:\n      case 2:\n      case 4:\n        this._setupEncryptionV1V2V4(this.version, encDict, options);\n        break;\n      case 5:\n        this._setupEncryptionV5(encDict, options);\n        break;\n    }\n\n    this.dictionary = this.document.ref(encDict);\n  }\n\n  _setupEncryptionV1V2V4(v, encDict, options) {\n    let r, permissions;\n    switch (v) {\n      case 1:\n        r = 2;\n        this.keyBits = 40;\n        permissions = getPermissionsR2(options.permissions);\n        break;\n      case 2:\n        r = 3;\n        this.keyBits = 128;\n        permissions = getPermissionsR3(options.permissions);\n        break;\n      case 4:\n        r = 4;\n        this.keyBits = 128;\n        permissions = getPermissionsR3(options.permissions);\n        break;\n    }\n\n    const paddedUserPassword = processPasswordR2R3R4(options.userPassword);\n    const paddedOwnerPassword = options.ownerPassword\n      ? processPasswordR2R3R4(options.ownerPassword)\n      : paddedUserPassword;\n\n    const ownerPasswordEntry = getOwnerPasswordR2R3R4(\n      r,\n      this.keyBits,\n      paddedUserPassword,\n      paddedOwnerPassword,\n    );\n    this.encryptionKey = getEncryptionKeyR2R3R4(\n      r,\n      this.keyBits,\n      this.document._id,\n      paddedUserPassword,\n      ownerPasswordEntry,\n      permissions,\n    );\n    let userPasswordEntry;\n    if (r === 2) {\n      userPasswordEntry = getUserPasswordR2(this.encryptionKey);\n    } else {\n      userPasswordEntry = getUserPasswordR3R4(\n        this.document._id,\n        this.encryptionKey,\n      );\n    }\n\n    encDict.V = v;\n    if (v >= 2) {\n      encDict.Length = this.keyBits;\n    }\n    if (v === 4) {\n      encDict.CF = {\n        StdCF: {\n          AuthEvent: 'DocOpen',\n          CFM: 'AESV2',\n          Length: this.keyBits / 8,\n        },\n      };\n      encDict.StmF = 'StdCF';\n      encDict.StrF = 'StdCF';\n    }\n    encDict.R = r;\n    encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n    encDict.U = wordArrayToBuffer(userPasswordEntry);\n    encDict.P = permissions;\n  }\n\n  _setupEncryptionV5(encDict, options) {\n    this.keyBits = 256;\n    const permissions = getPermissionsR3(options.permissions);\n\n    const processedUserPassword = processPasswordR5(options.userPassword);\n    const processedOwnerPassword = options.ownerPassword\n      ? processPasswordR5(options.ownerPassword)\n      : processedUserPassword;\n\n    this.encryptionKey = getEncryptionKeyR5(\n      PDFSecurity.generateRandomWordArray,\n    );\n    const userPasswordEntry = getUserPasswordR5(\n      processedUserPassword,\n      PDFSecurity.generateRandomWordArray,\n    );\n    const userKeySalt = CryptoJS.lib.WordArray.create(\n      userPasswordEntry.words.slice(10, 12),\n      8,\n    );\n    const userEncryptionKeyEntry = getUserEncryptionKeyR5(\n      processedUserPassword,\n      userKeySalt,\n      this.encryptionKey,\n    );\n    const ownerPasswordEntry = getOwnerPasswordR5(\n      processedOwnerPassword,\n      userPasswordEntry,\n      PDFSecurity.generateRandomWordArray,\n    );\n    const ownerKeySalt = CryptoJS.lib.WordArray.create(\n      ownerPasswordEntry.words.slice(10, 12),\n      8,\n    );\n    const ownerEncryptionKeyEntry = getOwnerEncryptionKeyR5(\n      processedOwnerPassword,\n      ownerKeySalt,\n      userPasswordEntry,\n      this.encryptionKey,\n    );\n    const permsEntry = getEncryptedPermissionsR5(\n      permissions,\n      this.encryptionKey,\n      PDFSecurity.generateRandomWordArray,\n    );\n\n    encDict.V = 5;\n    encDict.Length = this.keyBits;\n    encDict.CF = {\n      StdCF: {\n        AuthEvent: 'DocOpen',\n        CFM: 'AESV3',\n        Length: this.keyBits / 8,\n      },\n    };\n    encDict.StmF = 'StdCF';\n    encDict.StrF = 'StdCF';\n    encDict.R = 5;\n    encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n    encDict.OE = wordArrayToBuffer(ownerEncryptionKeyEntry);\n    encDict.U = wordArrayToBuffer(userPasswordEntry);\n    encDict.UE = wordArrayToBuffer(userEncryptionKeyEntry);\n    encDict.P = permissions;\n    encDict.Perms = wordArrayToBuffer(permsEntry);\n  }\n\n  getEncryptFn(obj, gen) {\n    let digest;\n    if (this.version < 5) {\n      digest = this.encryptionKey\n        .clone()\n        .concat(\n          CryptoJS.lib.WordArray.create(\n            [\n              ((obj & 0xff) << 24) |\n                ((obj & 0xff00) << 8) |\n                ((obj >> 8) & 0xff00) |\n                (gen & 0xff),\n              (gen & 0xff00) << 16,\n            ],\n            5,\n          ),\n        );\n    }\n\n    if (this.version === 1 || this.version === 2) {\n      let key = CryptoJS.MD5(digest);\n      key.sigBytes = Math.min(16, this.keyBits / 8 + 5);\n      return (buffer) =>\n        wordArrayToBuffer(\n          CryptoJS.RC4.encrypt(CryptoJS.lib.WordArray.create(buffer), key)\n            .ciphertext,\n        );\n    }\n\n    let key;\n    if (this.version === 4) {\n      key = CryptoJS.MD5(\n        digest.concat(CryptoJS.lib.WordArray.create([0x73416c54], 4)),\n      );\n    } else {\n      key = this.encryptionKey;\n    }\n\n    const iv = PDFSecurity.generateRandomWordArray(16);\n    const options = {\n      mode: CryptoJS.mode.CBC,\n      padding: CryptoJS.pad.Pkcs7,\n      iv,\n    };\n\n    return (buffer) =>\n      wordArrayToBuffer(\n        iv\n          .clone()\n          .concat(\n            CryptoJS.AES.encrypt(\n              CryptoJS.lib.WordArray.create(buffer),\n              key,\n              options,\n            ).ciphertext,\n          ),\n      );\n  }\n\n  end() {\n    this.dictionary.end();\n  }\n}\n\nfunction getPermissionsR2(permissionObject = {}) {\n  let permissions = 0xffffffc0 >> 0;\n  if (permissionObject.printing) {\n    permissions |= 0b000000000100;\n  }\n  if (permissionObject.modifying) {\n    permissions |= 0b000000001000;\n  }\n  if (permissionObject.copying) {\n    permissions |= 0b000000010000;\n  }\n  if (permissionObject.annotating) {\n    permissions |= 0b000000100000;\n  }\n  return permissions;\n}\n\nfunction getPermissionsR3(permissionObject = {}) {\n  let permissions = 0xfffff0c0 >> 0;\n  if (permissionObject.printing === 'lowResolution') {\n    permissions |= 0b000000000100;\n  }\n  if (permissionObject.printing === 'highResolution') {\n    permissions |= 0b100000000100;\n  }\n  if (permissionObject.modifying) {\n    permissions |= 0b000000001000;\n  }\n  if (permissionObject.copying) {\n    permissions |= 0b000000010000;\n  }\n  if (permissionObject.annotating) {\n    permissions |= 0b000000100000;\n  }\n  if (permissionObject.fillingForms) {\n    permissions |= 0b000100000000;\n  }\n  if (permissionObject.contentAccessibility) {\n    permissions |= 0b001000000000;\n  }\n  if (permissionObject.documentAssembly) {\n    permissions |= 0b010000000000;\n  }\n  return permissions;\n}\n\nfunction getUserPasswordR2(encryptionKey) {\n  return CryptoJS.RC4.encrypt(processPasswordR2R3R4(), encryptionKey)\n    .ciphertext;\n}\n\nfunction getUserPasswordR3R4(documentId, encryptionKey) {\n  const key = encryptionKey.clone();\n  let cipher = CryptoJS.MD5(\n    processPasswordR2R3R4().concat(CryptoJS.lib.WordArray.create(documentId)),\n  );\n  for (let i = 0; i < 20; i++) {\n    const xorRound = Math.ceil(key.sigBytes / 4);\n    for (let j = 0; j < xorRound; j++) {\n      key.words[j] =\n        encryptionKey.words[j] ^ (i | (i << 8) | (i << 16) | (i << 24));\n    }\n    cipher = CryptoJS.RC4.encrypt(cipher, key).ciphertext;\n  }\n  return cipher.concat(CryptoJS.lib.WordArray.create(null, 16));\n}\n\nfunction getOwnerPasswordR2R3R4(\n  r,\n  keyBits,\n  paddedUserPassword,\n  paddedOwnerPassword,\n) {\n  let digest = paddedOwnerPassword;\n  let round = r >= 3 ? 51 : 1;\n  for (let i = 0; i < round; i++) {\n    digest = CryptoJS.MD5(digest);\n  }\n\n  const key = digest.clone();\n  key.sigBytes = keyBits / 8;\n  let cipher = paddedUserPassword;\n  round = r >= 3 ? 20 : 1;\n  for (let i = 0; i < round; i++) {\n    const xorRound = Math.ceil(key.sigBytes / 4);\n    for (let j = 0; j < xorRound; j++) {\n      key.words[j] = digest.words[j] ^ (i | (i << 8) | (i << 16) | (i << 24));\n    }\n    cipher = CryptoJS.RC4.encrypt(cipher, key).ciphertext;\n  }\n  return cipher;\n}\n\nfunction getEncryptionKeyR2R3R4(\n  r,\n  keyBits,\n  documentId,\n  paddedUserPassword,\n  ownerPasswordEntry,\n  permissions,\n) {\n  let key = paddedUserPassword\n    .clone()\n    .concat(ownerPasswordEntry)\n    .concat(CryptoJS.lib.WordArray.create([lsbFirstWord(permissions)], 4))\n    .concat(CryptoJS.lib.WordArray.create(documentId));\n  const round = r >= 3 ? 51 : 1;\n  for (let i = 0; i < round; i++) {\n    key = CryptoJS.MD5(key);\n    key.sigBytes = keyBits / 8;\n  }\n  return key;\n}\n\nfunction getUserPasswordR5(processedUserPassword, generateRandomWordArray) {\n  const validationSalt = generateRandomWordArray(8);\n  const keySalt = generateRandomWordArray(8);\n  return CryptoJS.SHA256(processedUserPassword.clone().concat(validationSalt))\n    .concat(validationSalt)\n    .concat(keySalt);\n}\n\nfunction getUserEncryptionKeyR5(\n  processedUserPassword,\n  userKeySalt,\n  encryptionKey,\n) {\n  const key = CryptoJS.SHA256(\n    processedUserPassword.clone().concat(userKeySalt),\n  );\n  const options = {\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.NoPadding,\n    iv: CryptoJS.lib.WordArray.create(null, 16),\n  };\n  return CryptoJS.AES.encrypt(encryptionKey, key, options).ciphertext;\n}\n\nfunction getOwnerPasswordR5(\n  processedOwnerPassword,\n  userPasswordEntry,\n  generateRandomWordArray,\n) {\n  const validationSalt = generateRandomWordArray(8);\n  const keySalt = generateRandomWordArray(8);\n  return CryptoJS.SHA256(\n    processedOwnerPassword\n      .clone()\n      .concat(validationSalt)\n      .concat(userPasswordEntry),\n  )\n    .concat(validationSalt)\n    .concat(keySalt);\n}\n\nfunction getOwnerEncryptionKeyR5(\n  processedOwnerPassword,\n  ownerKeySalt,\n  userPasswordEntry,\n  encryptionKey,\n) {\n  const key = CryptoJS.SHA256(\n    processedOwnerPassword\n      .clone()\n      .concat(ownerKeySalt)\n      .concat(userPasswordEntry),\n  );\n  const options = {\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.NoPadding,\n    iv: CryptoJS.lib.WordArray.create(null, 16),\n  };\n  return CryptoJS.AES.encrypt(encryptionKey, key, options).ciphertext;\n}\n\nfunction getEncryptionKeyR5(generateRandomWordArray) {\n  return generateRandomWordArray(32);\n}\n\nfunction getEncryptedPermissionsR5(\n  permissions,\n  encryptionKey,\n  generateRandomWordArray,\n) {\n  const cipher = CryptoJS.lib.WordArray.create(\n    [lsbFirstWord(permissions), 0xffffffff, 0x54616462],\n    12,\n  ).concat(generateRandomWordArray(4));\n  const options = {\n    mode: CryptoJS.mode.ECB,\n    padding: CryptoJS.pad.NoPadding,\n  };\n  return CryptoJS.AES.encrypt(cipher, encryptionKey, options).ciphertext;\n}\n\nfunction processPasswordR2R3R4(password = '') {\n  const out = Buffer.alloc(32);\n  const length = password.length;\n  let index = 0;\n  while (index < length && index < 32) {\n    const code = password.charCodeAt(index);\n    if (code > 0xff) {\n      throw new Error('Password contains one or more invalid characters.');\n    }\n    out[index] = code;\n    index++;\n  }\n  while (index < 32) {\n    out[index] = PASSWORD_PADDING[index - length];\n    index++;\n  }\n  return CryptoJS.lib.WordArray.create(out);\n}\n\nfunction processPasswordR5(password = '') {\n  password = unescape(encodeURIComponent(saslprep(password)));\n  const length = Math.min(127, password.length);\n  const out = Buffer.alloc(length);\n\n  for (let i = 0; i < length; i++) {\n    out[i] = password.charCodeAt(i);\n  }\n\n  return CryptoJS.lib.WordArray.create(out);\n}\n\nfunction lsbFirstWord(data) {\n  return (\n    ((data & 0xff) << 24) |\n    ((data & 0xff00) << 8) |\n    ((data >> 8) & 0xff00) |\n    ((data >> 24) & 0xff)\n  );\n}\n\nfunction wordArrayToBuffer(wordArray) {\n  const byteArray = [];\n  for (let i = 0; i < wordArray.sigBytes; i++) {\n    byteArray.push(\n      (wordArray.words[Math.floor(i / 4)] >> (8 * (3 - (i % 4)))) & 0xff,\n    );\n  }\n  return Buffer.from(byteArray);\n}\n\nconst PASSWORD_PADDING = [\n  0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff,\n  0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c,\n  0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a,\n];\n\nexport default PDFSecurity;\n","import PDFObject from './object';\n\nconst { number } = PDFObject;\n\nclass PDFGradient {\n  constructor(doc) {\n    this.doc = doc;\n    this.stops = [];\n    this.embedded = false;\n    this.transform = [1, 0, 0, 1, 0, 0];\n  }\n\n  stop(pos, color, opacity) {\n    if (opacity == null) {\n      opacity = 1;\n    }\n    color = this.doc._normalizeColor(color);\n\n    if (this.stops.length === 0) {\n      if (color.length === 3) {\n        this._colorSpace = 'DeviceRGB';\n      } else if (color.length === 4) {\n        this._colorSpace = 'DeviceCMYK';\n      } else if (color.length === 1) {\n        this._colorSpace = 'DeviceGray';\n      } else {\n        throw new Error('Unknown color space');\n      }\n    } else if (\n      (this._colorSpace === 'DeviceRGB' && color.length !== 3) ||\n      (this._colorSpace === 'DeviceCMYK' && color.length !== 4) ||\n      (this._colorSpace === 'DeviceGray' && color.length !== 1)\n    ) {\n      throw new Error('All gradient stops must use the same color space');\n    }\n\n    opacity = Math.max(0, Math.min(1, opacity));\n    this.stops.push([pos, color, opacity]);\n    return this;\n  }\n\n  setTransform(m11, m12, m21, m22, dx, dy) {\n    this.transform = [m11, m12, m21, m22, dx, dy];\n    return this;\n  }\n\n  embed(m) {\n    let fn;\n    const stopsLength = this.stops.length;\n    if (stopsLength === 0) {\n      return;\n    }\n    this.embedded = true;\n    this.matrix = m;\n\n    // if the last stop comes before 100%, add a copy at 100%\n    const last = this.stops[stopsLength - 1];\n    if (last[0] < 1) {\n      this.stops.push([1, last[1], last[2]]);\n    }\n\n    const bounds = [];\n    const encode = [];\n    const stops = [];\n\n    for (let i = 0; i < stopsLength - 1; i++) {\n      encode.push(0, 1);\n      if (i + 2 !== stopsLength) {\n        bounds.push(this.stops[i + 1][0]);\n      }\n\n      fn = this.doc.ref({\n        FunctionType: 2,\n        Domain: [0, 1],\n        C0: this.stops[i + 0][1],\n        C1: this.stops[i + 1][1],\n        N: 1,\n      });\n\n      stops.push(fn);\n      fn.end();\n    }\n\n    // if there are only two stops, we don't need a stitching function\n    if (stopsLength === 1) {\n      fn = stops[0];\n    } else {\n      fn = this.doc.ref({\n        FunctionType: 3, // stitching function\n        Domain: [0, 1],\n        Functions: stops,\n        Bounds: bounds,\n        Encode: encode,\n      });\n\n      fn.end();\n    }\n\n    this.id = `Sh${++this.doc._gradCount}`;\n\n    const shader = this.shader(fn);\n    shader.end();\n\n    const pattern = this.doc.ref({\n      Type: 'Pattern',\n      PatternType: 2,\n      Shading: shader,\n      Matrix: this.matrix.map(number),\n    });\n\n    pattern.end();\n\n    if (this.stops.some((stop) => stop[2] < 1)) {\n      let grad = this.opacityGradient();\n      grad._colorSpace = 'DeviceGray';\n\n      for (let stop of this.stops) {\n        grad.stop(stop[0], [stop[2]]);\n      }\n\n      grad = grad.embed(this.matrix);\n\n      const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];\n\n      const form = this.doc.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        FormType: 1,\n        BBox: pageBBox,\n        Group: {\n          Type: 'Group',\n          S: 'Transparency',\n          CS: 'DeviceGray',\n        },\n        Resources: {\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n          Pattern: {\n            Sh1: grad,\n          },\n        },\n      });\n\n      form.write('/Pattern cs /Sh1 scn');\n      form.end(`${pageBBox.join(' ')} re f`);\n\n      const gstate = this.doc.ref({\n        Type: 'ExtGState',\n        SMask: {\n          Type: 'Mask',\n          S: 'Luminosity',\n          G: form,\n        },\n      });\n\n      gstate.end();\n\n      const opacityPattern = this.doc.ref({\n        Type: 'Pattern',\n        PatternType: 1,\n        PaintType: 1,\n        TilingType: 2,\n        BBox: pageBBox,\n        XStep: pageBBox[2],\n        YStep: pageBBox[3],\n        Resources: {\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n          Pattern: {\n            Sh1: pattern,\n          },\n          ExtGState: {\n            Gs1: gstate,\n          },\n        },\n      });\n\n      opacityPattern.write('/Gs1 gs /Pattern cs /Sh1 scn');\n      opacityPattern.end(`${pageBBox.join(' ')} re f`);\n\n      this.doc.page.patterns[this.id] = opacityPattern;\n    } else {\n      this.doc.page.patterns[this.id] = pattern;\n    }\n\n    return pattern;\n  }\n\n  apply(stroke) {\n    // apply gradient transform to existing document ctm\n    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;\n    const [m11, m12, m21, m22, dx, dy] = this.transform;\n    const m = [\n      m0 * m11 + m2 * m12,\n      m1 * m11 + m3 * m12,\n      m0 * m21 + m2 * m22,\n      m1 * m21 + m3 * m22,\n      m0 * dx + m2 * dy + m4,\n      m1 * dx + m3 * dy + m5,\n    ];\n\n    if (!this.embedded || m.join(' ') !== this.matrix.join(' ')) {\n      this.embed(m);\n    }\n    this.doc._setColorSpace('Pattern', stroke);\n    const op = stroke ? 'SCN' : 'scn';\n    return this.doc.addContent(`/${this.id} ${op}`);\n  }\n}\n\nclass PDFLinearGradient extends PDFGradient {\n  constructor(doc, x1, y1, x2, y2) {\n    super(doc);\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  shader(fn) {\n    return this.doc.ref({\n      ShadingType: 2,\n      ColorSpace: this._colorSpace,\n      Coords: [this.x1, this.y1, this.x2, this.y2],\n      Function: fn,\n      Extend: [true, true],\n    });\n  }\n\n  opacityGradient() {\n    return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);\n  }\n}\n\nclass PDFRadialGradient extends PDFGradient {\n  constructor(doc, x1, y1, r1, x2, y2, r2) {\n    super(doc);\n    this.doc = doc;\n    this.x1 = x1;\n    this.y1 = y1;\n    this.r1 = r1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.r2 = r2;\n  }\n\n  shader(fn) {\n    return this.doc.ref({\n      ShadingType: 3,\n      ColorSpace: this._colorSpace,\n      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],\n      Function: fn,\n      Extend: [true, true],\n    });\n  }\n\n  opacityGradient() {\n    return new PDFRadialGradient(\n      this.doc,\n      this.x1,\n      this.y1,\n      this.r1,\n      this.x2,\n      this.y2,\n      this.r2,\n    );\n  }\n}\n\nexport default { PDFGradient, PDFLinearGradient, PDFRadialGradient };\n","/*\nPDF tiling pattern support. Uncolored only.\n */\n\nconst underlyingColorSpaces = ['DeviceCMYK', 'DeviceRGB'];\n\nclass PDFTilingPattern {\n  constructor(doc, bBox, xStep, yStep, stream) {\n    this.doc = doc;\n    this.bBox = bBox;\n    this.xStep = xStep;\n    this.yStep = yStep;\n    this.stream = stream;\n  }\n\n  createPattern() {\n    // no resources needed for our current usage\n    // required entry\n    const resources = this.doc.ref();\n    resources.end();\n    // apply default transform matrix (flipped in the default doc._ctm)\n    // see document.js & gradient.js\n    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;\n    const [m11, m12, m21, m22, dx, dy] = [1, 0, 0, 1, 0, 0];\n    const m = [\n      m0 * m11 + m2 * m12,\n      m1 * m11 + m3 * m12,\n      m0 * m21 + m2 * m22,\n      m1 * m21 + m3 * m22,\n      m0 * dx + m2 * dy + m4,\n      m1 * dx + m3 * dy + m5,\n    ];\n    const pattern = this.doc.ref({\n      Type: 'Pattern',\n      PatternType: 1, // tiling\n      PaintType: 2, // 1-colored, 2-uncolored\n      TilingType: 2, // 2-no distortion\n      BBox: this.bBox,\n      XStep: this.xStep,\n      YStep: this.yStep,\n      Matrix: m.map((v) => +v.toFixed(5)),\n      Resources: resources,\n    });\n    pattern.end(this.stream);\n    return pattern;\n  }\n\n  embedPatternColorSpaces() {\n    // map each pattern to an underlying color space\n    // and embed on each page\n    underlyingColorSpaces.forEach((csName) => {\n      const csId = this.getPatternColorSpaceId(csName);\n\n      if (this.doc.page.colorSpaces[csId]) return;\n      const cs = this.doc.ref(['Pattern', csName]);\n      cs.end();\n      this.doc.page.colorSpaces[csId] = cs;\n    });\n  }\n\n  getPatternColorSpaceId(underlyingColorspace) {\n    return `CsP${underlyingColorspace}`;\n  }\n\n  embed() {\n    if (!this.id) {\n      this.doc._patternCount = this.doc._patternCount + 1;\n      this.id = 'P' + this.doc._patternCount;\n      this.pattern = this.createPattern();\n    }\n\n    // patterns are embedded in each page\n    if (!this.doc.page.patterns[this.id]) {\n      this.doc.page.patterns[this.id] = this.pattern;\n    }\n  }\n\n  apply(stroke, patternColor) {\n    // do any embedding/creating that might be needed\n    this.embedPatternColorSpaces();\n    this.embed();\n\n    const normalizedColor = this.doc._normalizeColor(patternColor);\n    if (!normalizedColor)\n      throw Error(`invalid pattern color. (value: ${patternColor})`);\n\n    // select one of the pattern color spaces\n    const csId = this.getPatternColorSpaceId(\n      this.doc._getColorSpace(normalizedColor),\n    );\n    this.doc._setColorSpace(csId, stroke);\n\n    // stroke/fill using the pattern and color (in the above underlying color space)\n    const op = stroke ? 'SCN' : 'scn';\n    return this.doc.addContent(\n      `${normalizedColor.join(' ')} /${this.id} ${op}`,\n    );\n  }\n}\n\nexport default { PDFTilingPattern };\n","import Gradient from '../gradient';\nimport pattern from '../pattern';\nimport SpotColor from '../spotcolor';\n\nconst { PDFGradient, PDFLinearGradient, PDFRadialGradient } = Gradient;\nconst { PDFTilingPattern } = pattern;\n\nexport default {\n  initColor() {\n    this.spotColors = {};\n    // The opacity dictionaries\n    this._opacityRegistry = {};\n    this._opacityCount = 0;\n    this._patternCount = 0;\n    this._gradCount = 0;\n  },\n\n  _normalizeColor(color) {\n    if (typeof color === 'string') {\n      if (color.charAt(0) === '#') {\n        if (color.length === 4) {\n          color = color.replace(\n            /#([0-9A-F])([0-9A-F])([0-9A-F])/i,\n            '#$1$1$2$2$3$3',\n          );\n        }\n        const hex = parseInt(color.slice(1), 16);\n        color = [hex >> 16, (hex >> 8) & 0xff, hex & 0xff];\n      } else if (namedColors[color]) {\n        color = namedColors[color];\n      } else if (this.spotColors[color]) {\n        return this.spotColors[color];\n      }\n    }\n\n    if (Array.isArray(color)) {\n      // RGB\n      if (color.length === 3) {\n        color = color.map((part) => part / 255);\n        // CMYK\n      } else if (color.length === 4) {\n        color = color.map((part) => part / 100);\n      }\n      return color;\n    }\n\n    return null;\n  },\n\n  _setColor(color, stroke) {\n    if (color instanceof PDFGradient) {\n      color.apply(stroke);\n      return true;\n      // see if tiling pattern, decode & apply it it\n    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern) {\n      color[0].apply(stroke, color[1]);\n      return true;\n    }\n    // any other case should be a normal color and not a pattern\n    return this._setColorCore(color, stroke);\n  },\n\n  _setColorCore(color, stroke) {\n    color = this._normalizeColor(color);\n    if (!color) {\n      return false;\n    }\n\n    const op = stroke ? 'SCN' : 'scn';\n    const space = this._getColorSpace(color);\n    this._setColorSpace(space, stroke);\n\n    if (color instanceof SpotColor) {\n      this.page.colorSpaces[color.id] = color.ref;\n      this.addContent(`1 ${op}`);\n    } else {\n      this.addContent(`${color.join(' ')} ${op}`);\n    }\n\n    return true;\n  },\n\n  _setColorSpace(space, stroke) {\n    const op = stroke ? 'CS' : 'cs';\n    return this.addContent(`/${space} ${op}`);\n  },\n\n  _getColorSpace(color) {\n    if (color instanceof SpotColor) {\n      return color.id;\n    }\n\n    return color.length === 4 ? 'DeviceCMYK' : 'DeviceRGB';\n  },\n\n  fillColor(color, opacity) {\n    const set = this._setColor(color, false);\n    if (set) {\n      this.fillOpacity(opacity);\n    }\n\n    // save this for text wrapper, which needs to reset\n    // the fill color on new pages\n    this._fillColor = [color, opacity];\n    return this;\n  },\n\n  strokeColor(color, opacity) {\n    const set = this._setColor(color, true);\n    if (set) {\n      this.strokeOpacity(opacity);\n    }\n    return this;\n  },\n\n  opacity(opacity) {\n    this._doOpacity(opacity, opacity);\n    return this;\n  },\n\n  fillOpacity(opacity) {\n    this._doOpacity(opacity, null);\n    return this;\n  },\n\n  strokeOpacity(opacity) {\n    this._doOpacity(null, opacity);\n    return this;\n  },\n\n  _doOpacity(fillOpacity, strokeOpacity) {\n    let dictionary, name;\n    if (fillOpacity == null && strokeOpacity == null) {\n      return;\n    }\n\n    if (fillOpacity != null) {\n      fillOpacity = Math.max(0, Math.min(1, fillOpacity));\n    }\n    if (strokeOpacity != null) {\n      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));\n    }\n    const key = `${fillOpacity}_${strokeOpacity}`;\n\n    if (this._opacityRegistry[key]) {\n      [dictionary, name] = this._opacityRegistry[key];\n    } else {\n      dictionary = { Type: 'ExtGState' };\n\n      if (fillOpacity != null) {\n        dictionary.ca = fillOpacity;\n      }\n      if (strokeOpacity != null) {\n        dictionary.CA = strokeOpacity;\n      }\n\n      dictionary = this.ref(dictionary);\n      dictionary.end();\n      const id = ++this._opacityCount;\n      name = `Gs${id}`;\n      this._opacityRegistry[key] = [dictionary, name];\n    }\n\n    this.page.ext_gstates[name] = dictionary;\n    return this.addContent(`/${name} gs`);\n  },\n\n  linearGradient(x1, y1, x2, y2) {\n    return new PDFLinearGradient(this, x1, y1, x2, y2);\n  },\n\n  radialGradient(x1, y1, r1, x2, y2, r2) {\n    return new PDFRadialGradient(this, x1, y1, r1, x2, y2, r2);\n  },\n\n  pattern(bbox, xStep, yStep, stream) {\n    return new PDFTilingPattern(this, bbox, xStep, yStep, stream);\n  },\n\n  addSpotColor(name, C, M, Y, K) {\n    const color = new SpotColor(this, name, C, M, Y, K);\n    this.spotColors[name] = color;\n    return this;\n  },\n};\n\nvar namedColors = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50],\n};\n","let cx, cy, px, py, sx, sy;\n\ncx = cy = px = py = sx = sy = 0;\n\nconst parameters = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0,\n};\n\nconst parse = function (path) {\n  let cmd;\n  const ret = [];\n  let args = [];\n  let curArg = '';\n  let foundDecimal = false;\n  let params = 0;\n\n  for (let c of path) {\n    if (parameters[c] != null) {\n      params = parameters[c];\n      if (cmd) {\n        // save existing command\n        if (curArg.length > 0) {\n          args[args.length] = +curArg;\n        }\n        ret[ret.length] = { cmd, args };\n\n        args = [];\n        curArg = '';\n        foundDecimal = false;\n      }\n\n      cmd = c;\n    } else if (\n      [' ', ','].includes(c) ||\n      (c === '-' && curArg.length > 0 && curArg[curArg.length - 1] !== 'e') ||\n      (c === '.' && foundDecimal)\n    ) {\n      if (curArg.length === 0) {\n        continue;\n      }\n\n      if (args.length === params) {\n        // handle reused commands\n        ret[ret.length] = { cmd, args };\n        args = [+curArg];\n\n        // handle assumed commands\n        if (cmd === 'M') {\n          cmd = 'L';\n        }\n        if (cmd === 'm') {\n          cmd = 'l';\n        }\n      } else {\n        args[args.length] = +curArg;\n      }\n\n      foundDecimal = c === '.';\n\n      // fix for negative numbers or repeated decimals with no delimeter between commands\n      curArg = ['-', '.'].includes(c) ? c : '';\n    } else {\n      curArg += c;\n      if (c === '.') {\n        foundDecimal = true;\n      }\n    }\n  }\n\n  // add the last command\n  if (curArg.length > 0) {\n    if (args.length === params) {\n      // handle reused commands\n      ret[ret.length] = { cmd, args };\n      args = [+curArg];\n\n      // handle assumed commands\n      if (cmd === 'M') {\n        cmd = 'L';\n      }\n      if (cmd === 'm') {\n        cmd = 'l';\n      }\n    } else {\n      args[args.length] = +curArg;\n    }\n  }\n\n  ret[ret.length] = { cmd, args };\n\n  return ret;\n};\n\nconst apply = function (commands, doc) {\n  // current point, control point, and subpath starting point\n  cx = cy = px = py = sx = sy = 0;\n\n  // run the commands\n  for (let i = 0; i < commands.length; i++) {\n    const c = commands[i];\n    if (typeof runners[c.cmd] === 'function') {\n      runners[c.cmd](doc, c.args);\n    }\n  }\n};\n\nconst runners = {\n  M(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n\n  m(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n\n  C(doc, a) {\n    cx = a[4];\n    cy = a[5];\n    px = a[2];\n    py = a[3];\n    return doc.bezierCurveTo(...a);\n  },\n\n  c(doc, a) {\n    doc.bezierCurveTo(\n      a[0] + cx,\n      a[1] + cy,\n      a[2] + cx,\n      a[3] + cy,\n      a[4] + cx,\n      a[5] + cy,\n    );\n    px = cx + a[2];\n    py = cy + a[3];\n    cx += a[4];\n    return (cy += a[5]);\n  },\n\n  S(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    return (cy = a[3]);\n  },\n\n  s(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n\n    doc.bezierCurveTo(\n      cx - (px - cx),\n      cy - (py - cy),\n      cx + a[0],\n      cy + a[1],\n      cx + a[2],\n      cy + a[3],\n    );\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return (cy += a[3]);\n  },\n\n  Q(doc, a) {\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    cy = a[3];\n    return doc.quadraticCurveTo(a[0], a[1], cx, cy);\n  },\n\n  q(doc, a) {\n    doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return (cy += a[3]);\n  },\n\n  T(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n\n    doc.quadraticCurveTo(px, py, a[0], a[1]);\n    px = cx - (px - cx);\n    py = cy - (py - cy);\n    cx = a[0];\n    return (cy = a[1]);\n  },\n\n  t(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n\n    doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);\n    cx += a[0];\n    return (cy += a[1]);\n  },\n\n  A(doc, a) {\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return (cy = a[6]);\n  },\n\n  a(doc, a) {\n    a[5] += cx;\n    a[6] += cy;\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return (cy = a[6]);\n  },\n\n  L(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n\n  l(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n\n  H(doc, a) {\n    cx = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n\n  h(doc, a) {\n    cx += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n\n  V(doc, a) {\n    cy = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n\n  v(doc, a) {\n    cy += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n\n  Z(doc) {\n    doc.closePath();\n    cx = sx;\n    return (cy = sy);\n  },\n\n  z(doc) {\n    doc.closePath();\n    cx = sx;\n    return (cy = sy);\n  },\n};\n\nconst solveArc = function (doc, x, y, coords) {\n  const [rx, ry, rot, large, sweep, ex, ey] = coords;\n  const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n\n  for (let seg of segs) {\n    const bez = segmentToBezier(...seg);\n    doc.bezierCurveTo(...bez);\n  }\n};\n\n// from Inkscape svgtopdf, thanks!\nconst arcToSegments = function (x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const th = rotateX * (Math.PI / 180);\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = (px * px) / (rx * rx) + (py * py) / (ry * ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) {\n    sfactor_sq = 0;\n  }\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep === large) {\n    sfactor = -sfactor;\n  }\n\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n\n  let th_arc = th1 - th0;\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += 2 * Math.PI;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  const result = [];\n\n  for (let i = 0; i < segments; i++) {\n    const th2 = th0 + (i * th_arc) / segments;\n    const th3 = th0 + ((i + 1) * th_arc) / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return result;\n};\n\nconst segmentToBezier = function (cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n\n  const th_half = 0.5 * (th1 - th0);\n  const t =\n    ((8 / 3) * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5)) /\n    Math.sin(th_half);\n  const x1 = cx + Math.cos(th0) - t * Math.sin(th0);\n  const y1 = cy + Math.sin(th0) + t * Math.cos(th0);\n  const x3 = cx + Math.cos(th1);\n  const y3 = cy + Math.sin(th1);\n  const x2 = x3 + t * Math.sin(th1);\n  const y2 = y3 - t * Math.cos(th1);\n\n  return [\n    a00 * x1 + a01 * y1,\n    a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,\n    a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,\n    a10 * x3 + a11 * y3,\n  ];\n};\n\nclass SVGPath {\n  static apply(doc, path) {\n    const commands = parse(path);\n    apply(commands, doc);\n  }\n}\n\nexport default SVGPath;\n","import SVGPath from '../path';\nimport PDFObject from '../object';\n\nconst { number } = PDFObject;\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nexport default {\n  initVector() {\n    this._ctm = [1, 0, 0, 1, 0, 0]; // current transformation matrix\n    this._ctmStack = [];\n  },\n\n  save() {\n    this._ctmStack.push(this._ctm.slice());\n    // TODO: save/restore colorspace and styles so not setting it unnessesarily all the time?\n    return this.addContent('q');\n  },\n\n  restore() {\n    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];\n    return this.addContent('Q');\n  },\n\n  closePath() {\n    return this.addContent('h');\n  },\n\n  lineWidth(w) {\n    return this.addContent(`${number(w)} w`);\n  },\n\n  _CAP_STYLES: {\n    BUTT: 0,\n    ROUND: 1,\n    SQUARE: 2,\n  },\n\n  lineCap(c) {\n    if (typeof c === 'string') {\n      c = this._CAP_STYLES[c.toUpperCase()];\n    }\n    return this.addContent(`${c} J`);\n  },\n\n  _JOIN_STYLES: {\n    MITER: 0,\n    ROUND: 1,\n    BEVEL: 2,\n  },\n\n  lineJoin(j) {\n    if (typeof j === 'string') {\n      j = this._JOIN_STYLES[j.toUpperCase()];\n    }\n    return this.addContent(`${j} j`);\n  },\n\n  miterLimit(m) {\n    return this.addContent(`${number(m)} M`);\n  },\n\n  dash(length, options = {}) {\n    const originalLength = length;\n    if (!Array.isArray(length)) {\n      length = [length, options.space || length];\n    }\n\n    const valid = length.every((x) => Number.isFinite(x) && x > 0);\n    if (!valid) {\n      throw new Error(\n        `dash(${JSON.stringify(originalLength)}, ${JSON.stringify(\n          options,\n        )}) invalid, lengths must be numeric and greater than zero`,\n      );\n    }\n\n    length = length.map(number).join(' ');\n    return this.addContent(`[${length}] ${number(options.phase || 0)} d`);\n  },\n\n  undash() {\n    return this.addContent('[] 0 d');\n  },\n\n  moveTo(x, y) {\n    return this.addContent(`${number(x)} ${number(y)} m`);\n  },\n\n  lineTo(x, y) {\n    return this.addContent(`${number(x)} ${number(y)} l`);\n  },\n\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    return this.addContent(\n      `${number(cp1x)} ${number(cp1y)} ${number(cp2x)} ${number(cp2y)} ${number(\n        x,\n      )} ${number(y)} c`,\n    );\n  },\n\n  quadraticCurveTo(cpx, cpy, x, y) {\n    return this.addContent(\n      `${number(cpx)} ${number(cpy)} ${number(x)} ${number(y)} v`,\n    );\n  },\n\n  rect(x, y, w, h) {\n    return this.addContent(\n      `${number(x)} ${number(y)} ${number(w)} ${number(h)} re`,\n    );\n  },\n\n  roundedRect(x, y, w, h, r) {\n    if (r == null) {\n      r = 0;\n    }\n    r = Math.min(r, 0.5 * w, 0.5 * h);\n\n    // amount to inset control points from corners (see `ellipse`)\n    const c = r * (1.0 - KAPPA);\n\n    this.moveTo(x + r, y);\n    this.lineTo(x + w - r, y);\n    this.bezierCurveTo(x + w - c, y, x + w, y + c, x + w, y + r);\n    this.lineTo(x + w, y + h - r);\n    this.bezierCurveTo(x + w, y + h - c, x + w - c, y + h, x + w - r, y + h);\n    this.lineTo(x + r, y + h);\n    this.bezierCurveTo(x + c, y + h, x, y + h - c, x, y + h - r);\n    this.lineTo(x, y + r);\n    this.bezierCurveTo(x, y + c, x + c, y, x + r, y);\n    return this.closePath();\n  },\n\n  ellipse(x, y, r1, r2) {\n    // based on http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas/2173084#2173084\n    if (r2 == null) {\n      r2 = r1;\n    }\n    x -= r1;\n    y -= r2;\n    const ox = r1 * KAPPA;\n    const oy = r2 * KAPPA;\n    const xe = x + r1 * 2;\n    const ye = y + r2 * 2;\n    const xm = x + r1;\n    const ym = y + r2;\n\n    this.moveTo(x, ym);\n    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    return this.closePath();\n  },\n\n  circle(x, y, radius) {\n    return this.ellipse(x, y, radius);\n  },\n\n  arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise == null) {\n      anticlockwise = false;\n    }\n    const TWO_PI = 2.0 * Math.PI;\n    const HALF_PI = 0.5 * Math.PI;\n\n    let deltaAng = endAngle - startAngle;\n\n    if (Math.abs(deltaAng) > TWO_PI) {\n      // draw only full circle if more than that is specified\n      deltaAng = TWO_PI;\n    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {\n      // necessary to flip direction of rendering\n      const dir = anticlockwise ? -1 : 1;\n      deltaAng = dir * TWO_PI + deltaAng;\n    }\n\n    const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);\n    const segAng = deltaAng / numSegs;\n    const handleLen = (segAng / HALF_PI) * KAPPA * radius;\n    let curAng = startAngle;\n\n    // component distances between anchor point and control point\n    let deltaCx = -Math.sin(curAng) * handleLen;\n    let deltaCy = Math.cos(curAng) * handleLen;\n\n    // anchor point\n    let ax = x + Math.cos(curAng) * radius;\n    let ay = y + Math.sin(curAng) * radius;\n\n    // calculate and render segments\n    this.moveTo(ax, ay);\n\n    for (let segIdx = 0; segIdx < numSegs; segIdx++) {\n      // starting control point\n      const cp1x = ax + deltaCx;\n      const cp1y = ay + deltaCy;\n\n      // step angle\n      curAng += segAng;\n\n      // next anchor point\n      ax = x + Math.cos(curAng) * radius;\n      ay = y + Math.sin(curAng) * radius;\n\n      // next control point delta\n      deltaCx = -Math.sin(curAng) * handleLen;\n      deltaCy = Math.cos(curAng) * handleLen;\n\n      // ending control point\n      const cp2x = ax - deltaCx;\n      const cp2y = ay - deltaCy;\n\n      // render segment\n      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);\n    }\n\n    return this;\n  },\n\n  polygon(...points) {\n    this.moveTo(...(points.shift() || []));\n    for (let point of points) {\n      this.lineTo(...(point || []));\n    }\n    return this.closePath();\n  },\n\n  path(path) {\n    SVGPath.apply(this, path);\n    return this;\n  },\n\n  _windingRule(rule) {\n    if (/even-?odd/.test(rule)) {\n      return '*';\n    }\n\n    return '';\n  },\n\n  fill(color, rule) {\n    if (/(even-?odd)|(non-?zero)/.test(color)) {\n      rule = color;\n      color = null;\n    }\n\n    if (color) {\n      this.fillColor(color);\n    }\n    return this.addContent(`f${this._windingRule(rule)}`);\n  },\n\n  stroke(color) {\n    if (color) {\n      this.strokeColor(color);\n    }\n    return this.addContent('S');\n  },\n\n  fillAndStroke(fillColor, strokeColor, rule) {\n    if (strokeColor == null) {\n      strokeColor = fillColor;\n    }\n    const isFillRule = /(even-?odd)|(non-?zero)/;\n    if (isFillRule.test(fillColor)) {\n      rule = fillColor;\n      fillColor = null;\n    }\n\n    if (isFillRule.test(strokeColor)) {\n      rule = strokeColor;\n      strokeColor = fillColor;\n    }\n\n    if (fillColor) {\n      this.fillColor(fillColor);\n      this.strokeColor(strokeColor);\n    }\n\n    return this.addContent(`B${this._windingRule(rule)}`);\n  },\n\n  clip(rule) {\n    return this.addContent(`W${this._windingRule(rule)} n`);\n  },\n\n  transform(m11, m12, m21, m22, dx, dy) {\n    // keep track of the current transformation matrix\n    if (\n      m11 === 1 &&\n      m12 === 0 &&\n      m21 === 0 &&\n      m22 === 1 &&\n      dx === 0 &&\n      dy === 0\n    ) {\n      // Ignore identity transforms\n      return this;\n    }\n    const m = this._ctm;\n    const [m0, m1, m2, m3, m4, m5] = m;\n    m[0] = m0 * m11 + m2 * m12;\n    m[1] = m1 * m11 + m3 * m12;\n    m[2] = m0 * m21 + m2 * m22;\n    m[3] = m1 * m21 + m3 * m22;\n    m[4] = m0 * dx + m2 * dy + m4;\n    m[5] = m1 * dx + m3 * dy + m5;\n\n    const values = [m11, m12, m21, m22, dx, dy].map((v) => number(v)).join(' ');\n    return this.addContent(`${values} cm`);\n  },\n\n  translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  },\n\n  rotate(angle, options = {}) {\n    let y;\n    const rad = (angle * Math.PI) / 180;\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    let x = (y = 0);\n\n    if (options.origin != null) {\n      [x, y] = options.origin;\n      const x1 = x * cos - y * sin;\n      const y1 = x * sin + y * cos;\n      x -= x1;\n      y -= y1;\n    }\n\n    return this.transform(cos, sin, -sin, cos, x, y);\n  },\n\n  scale(xFactor, yFactor, options = {}) {\n    let y;\n    if (yFactor == null) {\n      yFactor = xFactor;\n    }\n    if (typeof yFactor === 'object') {\n      options = yFactor;\n      yFactor = xFactor;\n    }\n\n    let x = (y = 0);\n    if (options.origin != null) {\n      [x, y] = options.origin;\n      x -= xFactor * x;\n      y -= yFactor * y;\n    }\n\n    return this.transform(xFactor, 0, 0, yFactor, x, y);\n  },\n};\n","const WIN_ANSI_MAP = {\n  402: 131,\n  8211: 150,\n  8212: 151,\n  8216: 145,\n  8217: 146,\n  8218: 130,\n  8220: 147,\n  8221: 148,\n  8222: 132,\n  8224: 134,\n  8225: 135,\n  8226: 149,\n  8230: 133,\n  8364: 128,\n  8240: 137,\n  8249: 139,\n  8250: 155,\n  710: 136,\n  8482: 153,\n  338: 140,\n  339: 156,\n  732: 152,\n  352: 138,\n  353: 154,\n  376: 159,\n  381: 142,\n  382: 158,\n};\n\nconst characters = `\\\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n  \nspace         exclam         quotedbl       numbersign\ndollar        percent        ampersand      quotesingle\nparenleft     parenright     asterisk       plus\ncomma         hyphen         period         slash\nzero          one            two            three\nfour          five           six            seven\neight         nine           colon          semicolon\nless          equal          greater        question\n  \nat            A              B              C\nD             E              F              G\nH             I              J              K\nL             M              N              O\nP             Q              R              S\nT             U              V              W\nX             Y              Z              bracketleft\nbackslash     bracketright   asciicircum    underscore\n  \ngrave         a              b              c\nd             e              f              g\nh             i              j              k\nl             m              n              o\np             q              r              s\nt             u              v              w\nx             y              z              braceleft\nbar           braceright     asciitilde     .notdef\n  \nEuro          .notdef        quotesinglbase florin\nquotedblbase  ellipsis       dagger         daggerdbl\ncircumflex    perthousand    Scaron         guilsinglleft\nOE            .notdef        Zcaron         .notdef\n.notdef       quoteleft      quoteright     quotedblleft\nquotedblright bullet         endash         emdash\ntilde         trademark      scaron         guilsinglright\noe            .notdef        zcaron         ydieresis\n  \nspace         exclamdown     cent           sterling\ncurrency      yen            brokenbar      section\ndieresis      copyright      ordfeminine    guillemotleft\nlogicalnot    hyphen         registered     macron\ndegree        plusminus      twosuperior    threesuperior\nacute         mu             paragraph      periodcentered\ncedilla       onesuperior    ordmasculine   guillemotright\nonequarter    onehalf        threequarters  questiondown\n  \nAgrave        Aacute         Acircumflex    Atilde\nAdieresis     Aring          AE             Ccedilla\nEgrave        Eacute         Ecircumflex    Edieresis\nIgrave        Iacute         Icircumflex    Idieresis\nEth           Ntilde         Ograve         Oacute\nOcircumflex   Otilde         Odieresis      multiply\nOslash        Ugrave         Uacute         Ucircumflex\nUdieresis     Yacute         Thorn          germandbls\n  \nagrave        aacute         acircumflex    atilde\nadieresis     aring          ae             ccedilla\negrave        eacute         ecircumflex    edieresis\nigrave        iacute         icircumflex    idieresis\neth           ntilde         ograve         oacute\nocircumflex   otilde         odieresis      divide\noslash        ugrave         uacute         ucircumflex\nudieresis     yacute         thorn          ydieresis\\\n`.split(/\\s+/);\n\nclass AFMFont {\n  /**\n   * @param {string} contents\n   */\n  constructor(contents) {\n    this.attributes = {};\n    this.glyphWidths = {};\n    this.boundingBoxes = {};\n    this.kernPairs = {};\n\n    this.parse(contents);\n\n    this.bbox = this.attributes['FontBBox'].split(/\\s+/).map((e) => +e);\n    this.ascender = +(this.attributes['Ascender'] || 0);\n    this.descender = +(this.attributes['Descender'] || 0);\n    this.xHeight = +(this.attributes['XHeight'] || 0);\n    this.capHeight = +(this.attributes['CapHeight'] || 0);\n    this.lineGap =\n      this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);\n  }\n\n  /**\n   * @param {string} contents\n   */\n  parse(contents) {\n    let section = '';\n    for (let line of contents.split('\\n')) {\n      var match;\n      var a;\n      if ((match = line.match(/^Start(\\w+)/))) {\n        section = match[1];\n        continue;\n      } else if ((match = line.match(/^End(\\w+)/))) {\n        section = '';\n        continue;\n      }\n\n      switch (section) {\n        case 'FontMetrics':\n          match = line.match(/(^\\w+)\\s+(.*)/);\n          var key = match[1];\n          var value = match[2];\n\n          if ((a = this.attributes[key])) {\n            if (!Array.isArray(a)) {\n              a = this.attributes[key] = [a];\n            }\n            a.push(value);\n          } else {\n            this.attributes[key] = value;\n          }\n          break;\n\n        case 'CharMetrics':\n          if (!/^CH?\\s/.test(line)) {\n            continue;\n          }\n          var name = line.match(/\\bN\\s+(\\.?\\w+)\\s*;/)[1];\n          this.glyphWidths[name] = +line.match(/\\bWX\\s+(\\d+)\\s*;/)[1];\n          break;\n\n        case 'KernPairs':\n          match = line.match(/^KPX\\s+(\\.?\\w+)\\s+(\\.?\\w+)\\s+(-?\\d+)/);\n          if (match) {\n            this.kernPairs[match[1] + '\\0' + match[2]] = parseInt(match[3]);\n          }\n          break;\n      }\n    }\n  }\n\n  /**\n   * @param {string} text\n   * @returns\n   */\n  encodeText(text) {\n    const res = [];\n    for (let i = 0, len = text.length; i < len; i++) {\n      let char = text.charCodeAt(i);\n      char = WIN_ANSI_MAP[char] || char;\n      res.push(char.toString(16));\n    }\n\n    return res;\n  }\n\n  glyphsForString(string) {\n    const glyphs = [];\n\n    for (let i = 0, len = string.length; i < len; i++) {\n      const charCode = string.charCodeAt(i);\n      glyphs.push(this.characterToGlyph(charCode));\n    }\n\n    return glyphs;\n  }\n\n  characterToGlyph(character) {\n    return characters[WIN_ANSI_MAP[character] || character] || '.notdef';\n  }\n\n  widthOfGlyph(glyph) {\n    return this.glyphWidths[glyph] || 0;\n  }\n\n  getKernPair(left, right) {\n    return this.kernPairs[left + '\\0' + right] || 0;\n  }\n\n  advancesForGlyphs(glyphs) {\n    const advances = [];\n\n    for (let index = 0; index < glyphs.length; index++) {\n      const left = glyphs[index];\n      const right = glyphs[index + 1];\n      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));\n    }\n\n    return advances;\n  }\n}\n\nexport default AFMFont;\n","class PDFFont {\n  constructor() {}\n\n  encode() {\n    throw new Error('Must be implemented by subclasses');\n  }\n\n  widthOfString() {\n    throw new Error('Must be implemented by subclasses');\n  }\n\n  ref() {\n    return this.dictionary != null\n      ? this.dictionary\n      : (this.dictionary = this.document.ref());\n  }\n\n  finalize() {\n    if (this.embedded || this.dictionary == null) {\n      return;\n    }\n\n    this.embed();\n    this.embedded = true;\n  }\n\n  embed() {\n    throw new Error('Must be implemented by subclasses');\n  }\n\n  lineHeight(size, includeGap = false) {\n    const gap = includeGap ? this.lineGap : 0;\n    return ((this.ascender + gap - this.descender) / 1000) * size;\n  }\n}\n\nexport default PDFFont;\n","import AFMFont from './afm';\nimport PDFFont from '../font';\nimport fs from 'fs';\n\n// This insanity is so bundlers can inline the font files\nconst STANDARD_FONTS = {\n  Courier() {\n    return fs.readFileSync(__dirname + '/data/Courier.afm', 'utf8');\n  },\n  'Courier-Bold'() {\n    return fs.readFileSync(__dirname + '/data/Courier-Bold.afm', 'utf8');\n  },\n  'Courier-Oblique'() {\n    return fs.readFileSync(__dirname + '/data/Courier-Oblique.afm', 'utf8');\n  },\n  'Courier-BoldOblique'() {\n    return fs.readFileSync(__dirname + '/data/Courier-BoldOblique.afm', 'utf8');\n  },\n  Helvetica() {\n    return fs.readFileSync(__dirname + '/data/Helvetica.afm', 'utf8');\n  },\n  'Helvetica-Bold'() {\n    return fs.readFileSync(__dirname + '/data/Helvetica-Bold.afm', 'utf8');\n  },\n  'Helvetica-Oblique'() {\n    return fs.readFileSync(__dirname + '/data/Helvetica-Oblique.afm', 'utf8');\n  },\n  'Helvetica-BoldOblique'() {\n    return fs.readFileSync(\n      __dirname + '/data/Helvetica-BoldOblique.afm',\n      'utf8',\n    );\n  },\n  'Times-Roman'() {\n    return fs.readFileSync(__dirname + '/data/Times-Roman.afm', 'utf8');\n  },\n  'Times-Bold'() {\n    return fs.readFileSync(__dirname + '/data/Times-Bold.afm', 'utf8');\n  },\n  'Times-Italic'() {\n    return fs.readFileSync(__dirname + '/data/Times-Italic.afm', 'utf8');\n  },\n  'Times-BoldItalic'() {\n    return fs.readFileSync(__dirname + '/data/Times-BoldItalic.afm', 'utf8');\n  },\n  Symbol() {\n    return fs.readFileSync(__dirname + '/data/Symbol.afm', 'utf8');\n  },\n  ZapfDingbats() {\n    return fs.readFileSync(__dirname + '/data/ZapfDingbats.afm', 'utf8');\n  },\n};\n\nclass StandardFont extends PDFFont {\n  constructor(document, name, id) {\n    super();\n    this.document = document;\n    this.name = name;\n    this.id = id;\n    this.font = new AFMFont(STANDARD_FONTS[this.name]());\n    ({\n      ascender: this.ascender,\n      descender: this.descender,\n      bbox: this.bbox,\n      lineGap: this.lineGap,\n      xHeight: this.xHeight,\n      capHeight: this.capHeight,\n    } = this.font);\n  }\n\n  embed() {\n    this.dictionary.data = {\n      Type: 'Font',\n      BaseFont: this.name,\n      Subtype: 'Type1',\n      Encoding: 'WinAnsiEncoding',\n    };\n\n    return this.dictionary.end();\n  }\n\n  encode(text) {\n    const encoded = this.font.encodeText(text);\n    const glyphs = this.font.glyphsForString(`${text}`);\n    const advances = this.font.advancesForGlyphs(glyphs);\n    const positions = [];\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      positions.push({\n        xAdvance: advances[i],\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n        advanceWidth: this.font.widthOfGlyph(glyph),\n      });\n    }\n\n    return [encoded, positions];\n  }\n\n  widthOfString(string, size) {\n    const glyphs = this.font.glyphsForString(`${string}`);\n    const advances = this.font.advancesForGlyphs(glyphs);\n\n    let width = 0;\n    for (let advance of advances) {\n      width += advance;\n    }\n\n    const scale = size / 1000;\n    return width * scale;\n  }\n\n  static isStandardFont(name) {\n    return name in STANDARD_FONTS;\n  }\n}\n\nexport default StandardFont;\n","import PDFFont from '../font';\n\nconst toHex = function (num) {\n  return `0000${num.toString(16)}`.slice(-4);\n};\n\nclass EmbeddedFont extends PDFFont {\n  constructor(document, font, id) {\n    super();\n    this.document = document;\n    this.font = font;\n    this.id = id;\n    this.subset = this.font.createSubset();\n    this.unicode = [[0]];\n    this.widths = [this.font.getGlyph(0).advanceWidth];\n\n    this.name = this.font.postscriptName;\n    this.scale = 1000 / this.font.unitsPerEm;\n    this.ascender = this.font.ascent * this.scale;\n    this.descender = this.font.descent * this.scale;\n    this.xHeight = this.font.xHeight * this.scale;\n    this.capHeight = this.font.capHeight * this.scale;\n    this.lineGap = this.font.lineGap * this.scale;\n    this.bbox = this.font.bbox;\n\n    if (document.options.fontLayoutCache !== false) {\n      this.layoutCache = Object.create(null);\n    }\n  }\n\n  layoutRun(text, features) {\n    const run = this.font.layout(text, features);\n\n    // Normalize position values\n    for (let i = 0; i < run.positions.length; i++) {\n      const position = run.positions[i];\n      for (let key in position) {\n        position[key] *= this.scale;\n      }\n\n      position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;\n    }\n\n    return run;\n  }\n\n  layoutCached(text) {\n    if (!this.layoutCache) {\n      return this.layoutRun(text);\n    }\n    let cached;\n    if ((cached = this.layoutCache[text])) {\n      return cached;\n    }\n\n    const run = this.layoutRun(text);\n    this.layoutCache[text] = run;\n    return run;\n  }\n\n  layout(text, features, onlyWidth) {\n    // Skip the cache if any user defined features are applied\n    if (features) {\n      return this.layoutRun(text, features);\n    }\n\n    let glyphs = onlyWidth ? null : [];\n    let positions = onlyWidth ? null : [];\n    let advanceWidth = 0;\n\n    // Split the string by words to increase cache efficiency.\n    // For this purpose, spaces and tabs are a good enough delimeter.\n    let last = 0;\n    let index = 0;\n    while (index <= text.length) {\n      var needle;\n      if (\n        (index === text.length && last < index) ||\n        ((needle = text.charAt(index)), [' ', '\\t'].includes(needle))\n      ) {\n        const run = this.layoutCached(text.slice(last, ++index));\n        if (!onlyWidth) {\n          glyphs = glyphs.concat(run.glyphs);\n          positions = positions.concat(run.positions);\n        }\n\n        advanceWidth += run.advanceWidth;\n        last = index;\n      } else {\n        index++;\n      }\n    }\n\n    return { glyphs, positions, advanceWidth };\n  }\n\n  encode(text, features) {\n    const { glyphs, positions } = this.layout(text, features);\n\n    const res = [];\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      const gid = this.subset.includeGlyph(glyph.id);\n      res.push(`0000${gid.toString(16)}`.slice(-4));\n\n      if (this.widths[gid] == null) {\n        this.widths[gid] = glyph.advanceWidth * this.scale;\n      }\n      if (this.unicode[gid] == null) {\n        this.unicode[gid] = glyph.codePoints;\n      }\n    }\n\n    return [res, positions];\n  }\n\n  widthOfString(string, size, features) {\n    const width = this.layout(string, features, true).advanceWidth;\n    const scale = size / 1000;\n    return width * scale;\n  }\n\n  embed() {\n    const isCFF = this.subset.cff != null;\n    const fontFile = this.document.ref();\n\n    if (isCFF) {\n      fontFile.data.Subtype = 'CIDFontType0C';\n    }\n\n    fontFile.end(this.subset.encode());\n\n    const familyClass =\n      ((this.font['OS/2'] != null\n        ? this.font['OS/2'].sFamilyClass\n        : undefined) || 0) >> 8;\n    let flags = 0;\n    if (this.font.post.isFixedPitch) {\n      flags |= 1 << 0;\n    }\n    if (1 <= familyClass && familyClass <= 7) {\n      flags |= 1 << 1;\n    }\n    flags |= 1 << 2; // assume the font uses non-latin characters\n    if (familyClass === 10) {\n      flags |= 1 << 3;\n    }\n    if (this.font.head.macStyle.italic) {\n      flags |= 1 << 6;\n    }\n\n    // generate a tag (6 uppercase letters. 17 is the char code offset from '0' to 'A'. 73 will map to 'Z')\n    const tag = [1, 2, 3, 4, 5, 6]\n      .map((i) => String.fromCharCode((this.id.charCodeAt(i) || 73) + 17))\n      .join('');\n    const name = tag + '+' + this.font.postscriptName?.replaceAll(' ', '_');\n\n    const { bbox } = this.font;\n    const descriptor = this.document.ref({\n      Type: 'FontDescriptor',\n      FontName: name,\n      Flags: flags,\n      FontBBox: [\n        bbox.minX * this.scale,\n        bbox.minY * this.scale,\n        bbox.maxX * this.scale,\n        bbox.maxY * this.scale,\n      ],\n      ItalicAngle: this.font.italicAngle,\n      Ascent: this.ascender,\n      Descent: this.descender,\n      CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,\n      XHeight: (this.font.xHeight || 0) * this.scale,\n      StemV: 0,\n    }); // not sure how to calculate this\n\n    if (isCFF) {\n      descriptor.data.FontFile3 = fontFile;\n    } else {\n      descriptor.data.FontFile2 = fontFile;\n    }\n\n    if (this.document.subset && this.document.subset === 1) {\n      const CIDSet = Buffer.from('FFFFFFFFC0', 'hex');\n      const CIDSetRef = this.document.ref();\n      CIDSetRef.write(CIDSet);\n      CIDSetRef.end();\n\n      descriptor.data.CIDSet = CIDSetRef;\n    }\n\n    descriptor.end();\n\n    const descendantFontData = {\n      Type: 'Font',\n      Subtype: 'CIDFontType0',\n      BaseFont: name,\n      CIDSystemInfo: {\n        Registry: new String('Adobe'),\n        Ordering: new String('Identity'),\n        Supplement: 0,\n      },\n      FontDescriptor: descriptor,\n      W: [0, this.widths],\n    };\n\n    if (!isCFF) {\n      descendantFontData.Subtype = 'CIDFontType2';\n      descendantFontData.CIDToGIDMap = 'Identity';\n    }\n\n    const descendantFont = this.document.ref(descendantFontData);\n\n    descendantFont.end();\n\n    this.dictionary.data = {\n      Type: 'Font',\n      Subtype: 'Type0',\n      BaseFont: name,\n      Encoding: 'Identity-H',\n      DescendantFonts: [descendantFont],\n      ToUnicode: this.toUnicodeCmap(),\n    };\n\n    return this.dictionary.end();\n  }\n\n  // Maps the glyph ids encoded in the PDF back to unicode strings\n  // Because of ligature substitutions and the like, there may be one or more\n  // unicode characters represented by each glyph.\n  toUnicodeCmap() {\n    const cmap = this.document.ref();\n\n    const entries = [];\n    for (let codePoints of this.unicode) {\n      const encoded = [];\n\n      // encode codePoints to utf16\n      for (let value of codePoints) {\n        if (value > 0xffff) {\n          value -= 0x10000;\n          encoded.push(toHex(((value >>> 10) & 0x3ff) | 0xd800));\n          value = 0xdc00 | (value & 0x3ff);\n        }\n\n        encoded.push(toHex(value));\n      }\n\n      entries.push(`<${encoded.join(' ')}>`);\n    }\n\n    const chunkSize = 256;\n    const chunks = Math.ceil(entries.length / chunkSize);\n    const ranges = [];\n    for (let i = 0; i < chunks; i++) {\n      const start = i * chunkSize;\n      const end = Math.min((i + 1) * chunkSize, entries.length);\n      ranges.push(\n        `<${toHex(start)}> <${toHex(end - 1)}> [${entries.slice(start, end).join(' ')}]`,\n      );\n    }\n\n    cmap.end(`\\\n/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n1 beginbfrange\n${ranges.join('\\n')}\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend\\\n`);\n\n    return cmap;\n  }\n}\n\nexport default EmbeddedFont;\n","import fs from 'fs';\nimport * as fontkit from 'fontkit';\nimport StandardFont from './font/standard';\nimport EmbeddedFont from './font/embedded';\n\nclass PDFFontFactory {\n  static open(document, src, family, id) {\n    let font;\n    if (typeof src === 'string') {\n      if (StandardFont.isStandardFont(src)) {\n        return new StandardFont(document, src, id);\n      }\n\n      src = fs.readFileSync(src);\n    }\n    if (src instanceof Uint8Array) {\n      font = fontkit.create(src, family);\n    } else if (src instanceof ArrayBuffer) {\n      font = fontkit.create(new Uint8Array(src), family);\n    }\n\n    if (font == null) {\n      throw new Error('Not a supported font format or standard PDF font.');\n    }\n\n    return new EmbeddedFont(document, font, id);\n  }\n}\n\nexport default PDFFontFactory;\n","import PDFFontFactory from '../font_factory';\nimport { CM_TO_IN, IN_TO_PT, MM_TO_CM, PC_TO_PT, PX_TO_IN } from '../utils';\n\nconst isEqualFont = (font1, font2) => {\n  // compare font checksum\n  if (\n    font1.font._tables?.head?.checkSumAdjustment !==\n    font2.font._tables?.head?.checkSumAdjustment\n  ) {\n    return false;\n  }\n\n  // compare font name table\n  if (\n    JSON.stringify(font1.font._tables?.name?.records) !==\n    JSON.stringify(font2.font._tables?.name?.records)\n  ) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default {\n  initFonts(\n    defaultFont = 'Helvetica',\n    defaultFontFamily = null,\n    defaultFontSize = 12,\n  ) {\n    // Lookup table for embedded fonts\n    this._fontFamilies = {};\n    this._fontCount = 0;\n\n    // Font state\n    // Useful to export the font builder so that someone can create a snapshot of the current state\n    // (e.g. Reverting back to the previous font)\n    this._fontSource = defaultFont;\n    this._fontFamily = defaultFontFamily;\n    this._fontSize = defaultFontSize;\n    this._font = null;\n\n    // rem size is fixed per document as the document is the root element\n    this._remSize = defaultFontSize;\n\n    this._registeredFonts = {};\n\n    // Set the default font\n    if (defaultFont) {\n      this.font(defaultFont, defaultFontFamily);\n    }\n  },\n\n  font(src, family, size) {\n    let cacheKey, font;\n    if (typeof family === 'number') {\n      size = family;\n      family = null;\n    }\n\n    // check registered fonts if src is a string\n    if (typeof src === 'string' && this._registeredFonts[src]) {\n      cacheKey = src;\n      ({ src, family } = this._registeredFonts[src]);\n    } else {\n      cacheKey = family || src;\n      if (typeof cacheKey !== 'string') {\n        cacheKey = null;\n      }\n    }\n\n    this._fontSource = src;\n    this._fontFamily = family;\n    if (size != null) {\n      this.fontSize(size);\n    }\n\n    // fast path: check if the font is already in the PDF\n    if ((font = this._fontFamilies[cacheKey])) {\n      this._font = font;\n      return this;\n    }\n\n    // load the font\n    const id = `F${++this._fontCount}`;\n    this._font = PDFFontFactory.open(this, src, family, id);\n\n    // check for existing font familes with the same name already in the PDF\n    // useful if the font was passed as a buffer\n    if (\n      (font = this._fontFamilies[this._font.name]) &&\n      isEqualFont(this._font, font)\n    ) {\n      this._font = font;\n      return this;\n    }\n\n    // save the font for reuse later\n    if (cacheKey) {\n      this._fontFamilies[cacheKey] = this._font;\n    }\n\n    if (this._font.name) {\n      this._fontFamilies[this._font.name] = this._font;\n    }\n\n    return this;\n  },\n\n  fontSize(_fontSize) {\n    this._fontSize = this.sizeToPoint(_fontSize);\n    return this;\n  },\n\n  currentLineHeight(includeGap) {\n    return this._font.lineHeight(this._fontSize, includeGap);\n  },\n\n  registerFont(name, src, family) {\n    this._registeredFonts[name] = {\n      src,\n      family,\n    };\n\n    return this;\n  },\n\n  /**\n   * Convert a {@link Size} into a point measurement\n   *\n   * @param {Size | boolean | undefined} size - The size to convert\n   * @param {Size | boolean | undefined} defaultValue - The default value when undefined\n   * @param {PDFPage} page - The page used for computing font sizes\n   * @param {number} [percentageWidth] - The value to use for computing size based on `%`\n   *\n   * @returns number\n   */\n  sizeToPoint(\n    size,\n    defaultValue = 0,\n    page = this.page,\n    percentageWidth = undefined,\n  ) {\n    if (!percentageWidth) percentageWidth = this._fontSize;\n    if (typeof defaultValue !== 'number')\n      defaultValue = this.sizeToPoint(defaultValue);\n    if (size === undefined) return defaultValue;\n    if (typeof size === 'number') return size;\n    if (typeof size === 'boolean') return Number(size);\n\n    const match = String(size).match(\n      /((\\d+)?(\\.\\d+)?)(em|in|px|cm|mm|pc|ex|ch|rem|vw|vh|vmin|vmax|%|pt)?/,\n    );\n    if (!match) throw new Error(`Unsupported size '${size}'`);\n    let multiplier;\n    switch (match[4]) {\n      case 'em':\n        multiplier = this._fontSize;\n        break;\n      case 'in':\n        multiplier = IN_TO_PT;\n        break;\n      case 'px':\n        multiplier = PX_TO_IN * IN_TO_PT;\n        break;\n      case 'cm':\n        multiplier = CM_TO_IN * IN_TO_PT;\n        break;\n      case 'mm':\n        multiplier = MM_TO_CM * CM_TO_IN * IN_TO_PT;\n        break;\n      case 'pc':\n        multiplier = PC_TO_PT;\n        break;\n      case 'ex':\n        multiplier = this.currentLineHeight();\n        break;\n      case 'ch':\n        multiplier = this.widthOfString('0');\n        break;\n      case 'rem':\n        multiplier = this._remSize;\n        break;\n      case 'vw':\n        multiplier = page.width / 100;\n        break;\n      case 'vh':\n        multiplier = page.height / 100;\n        break;\n      case 'vmin':\n        multiplier = Math.min(page.width, page.height) / 100;\n        break;\n      case 'vmax':\n        multiplier = Math.max(page.width, page.height) / 100;\n        break;\n      case '%':\n        multiplier = percentageWidth / 100;\n        break;\n      case 'pt':\n      default:\n        multiplier = 1;\n    }\n\n    return multiplier * Number(match[1]);\n  },\n};\n","import { EventEmitter } from 'events';\r\nimport LineBreaker from 'linebreak';\r\nimport { PDFNumber } from './utils';\r\n\r\nconst SOFT_HYPHEN = '\\u00AD';\r\nconst HYPHEN = '-';\r\n\r\nclass LineWrapper extends EventEmitter {\r\n  constructor(document, options) {\r\n    super();\r\n    this.document = document;\r\n    this.horizontalScaling = options.horizontalScaling || 100;\r\n    this.indent = ((options.indent || 0) * this.horizontalScaling) / 100;\r\n    this.characterSpacing =\r\n      ((options.characterSpacing || 0) * this.horizontalScaling) / 100;\r\n    this.wordSpacing =\r\n      ((options.wordSpacing === 0) * this.horizontalScaling) / 100;\r\n    this.columns = options.columns || 1;\r\n    this.columnGap =\r\n      ((options.columnGap != null ? options.columnGap : 18) *\r\n        this.horizontalScaling) /\r\n      100; // 1/4 inch\r\n    this.lineWidth =\r\n      ((options.width * this.horizontalScaling) / 100 -\r\n        this.columnGap * (this.columns - 1)) /\r\n      this.columns;\r\n    this.spaceLeft = this.lineWidth;\r\n    this.startX = this.document.x;\r\n    this.startY = this.document.y;\r\n    this.column = 1;\r\n    this.ellipsis = options.ellipsis;\r\n    this.continuedX = 0;\r\n    this.features = options.features;\r\n\r\n    // calculate the maximum Y position the text can appear at\r\n    if (options.height != null) {\r\n      this.height = options.height;\r\n      this.maxY = PDFNumber(this.startY + options.height);\r\n    } else {\r\n      this.maxY = PDFNumber(this.document.page.maxY());\r\n    }\r\n\r\n    // handle paragraph indents\r\n    this.on('firstLine', (options) => {\r\n      // if this is the first line of the text segment, and\r\n      // we're continuing where we left off, indent that much\r\n      // otherwise use the user specified indent option\r\n      const indent = this.continuedX || this.indent;\r\n      this.document.x += indent;\r\n      this.lineWidth -= indent;\r\n\r\n      // if indentAllLines is set to true\r\n      // we're not resetting the indentation for this paragraph after the first line\r\n      if (options.indentAllLines) {\r\n        return;\r\n      }\r\n\r\n      // otherwise we start the next line without indent\r\n      this.once('line', () => {\r\n        this.document.x -= indent;\r\n        this.lineWidth += indent;\r\n        if (options.continued && !this.continuedX) {\r\n          this.continuedX = this.indent;\r\n        }\r\n        if (!options.continued) {\r\n          this.continuedX = 0;\r\n        }\r\n      });\r\n    });\r\n\r\n    // handle left aligning last lines of paragraphs\r\n    this.on('lastLine', (options) => {\r\n      const { align } = options;\r\n      if (align === 'justify') {\r\n        options.align = 'left';\r\n      }\r\n      this.lastLine = true;\r\n\r\n      this.once('line', () => {\r\n        this.document.y += options.paragraphGap || 0;\r\n        options.align = align;\r\n        return (this.lastLine = false);\r\n      });\r\n    });\r\n  }\r\n\r\n  wordWidth(word) {\r\n    return PDFNumber(\r\n      this.document.widthOfString(word, this) +\r\n        this.characterSpacing +\r\n        this.wordSpacing,\r\n    );\r\n  }\r\n\r\n  canFit(word, w) {\r\n    if (word[word.length - 1] != SOFT_HYPHEN) {\r\n      return w <= this.spaceLeft;\r\n    }\r\n    return w + this.wordWidth(HYPHEN) <= this.spaceLeft;\r\n  }\r\n\r\n  eachWord(text, fn) {\r\n    // setup a unicode line breaker\r\n    let bk;\r\n    const breaker = new LineBreaker(text);\r\n    let last = null;\r\n    const wordWidths = Object.create(null);\r\n\r\n    while ((bk = breaker.nextBreak())) {\r\n      var shouldContinue;\r\n      let word = text.slice(\r\n        (last != null ? last.position : undefined) || 0,\r\n        bk.position,\r\n      );\r\n      let w =\r\n        wordWidths[word] != null\r\n          ? wordWidths[word]\r\n          : (wordWidths[word] = this.wordWidth(word));\r\n\r\n      // if the word is longer than the whole line, chop it up\r\n      // TODO: break by grapheme clusters, not JS string characters\r\n      if (w > this.lineWidth + this.continuedX) {\r\n        // make some fake break objects\r\n        let lbk = last;\r\n        const fbk = {};\r\n\r\n        while (word.length) {\r\n          // fit as much of the word as possible into the space we have\r\n          var l, mightGrow;\r\n          if (w > this.spaceLeft) {\r\n            // start our check at the end of our available space - this method is faster than a loop of each character and it resolves\r\n            // an issue with long loops when processing massive words, such as a huge number of spaces\r\n            l = Math.ceil(this.spaceLeft / (w / word.length));\r\n            w = this.wordWidth(word.slice(0, l));\r\n            mightGrow = w <= this.spaceLeft && l < word.length;\r\n          } else {\r\n            l = word.length;\r\n          }\r\n          let mustShrink = w > this.spaceLeft && l > 0;\r\n          // shrink or grow word as necessary after our near-guess above\r\n          while (mustShrink || mightGrow) {\r\n            if (mustShrink) {\r\n              w = this.wordWidth(word.slice(0, --l));\r\n              mustShrink = w > this.spaceLeft && l > 0;\r\n            } else {\r\n              w = this.wordWidth(word.slice(0, ++l));\r\n              mustShrink = w > this.spaceLeft && l > 0;\r\n              mightGrow = w <= this.spaceLeft && l < word.length;\r\n            }\r\n          }\r\n\r\n          // check for the edge case where a single character cannot fit into a line.\r\n          if (l === 0 && this.spaceLeft === this.lineWidth) {\r\n            l = 1;\r\n          }\r\n\r\n          // send a required break unless this is the last piece and a linebreak is not specified\r\n          fbk.required = bk.required || l < word.length;\r\n          shouldContinue = fn(word.slice(0, l), w, fbk, lbk);\r\n          lbk = { required: false };\r\n\r\n          // get the remaining piece of the word\r\n          word = word.slice(l);\r\n          w = this.wordWidth(word);\r\n\r\n          if (shouldContinue === false) {\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        // otherwise just emit the break as it was given to us\r\n        shouldContinue = fn(word, w, bk, last);\r\n      }\r\n\r\n      if (shouldContinue === false) {\r\n        break;\r\n      }\r\n      last = bk;\r\n    }\r\n  }\r\n\r\n  wrap(text, options) {\r\n    // override options from previous continued fragments\r\n    this.horizontalScaling = options.horizontalScaling || 100;\r\n    if (options.indent != null) {\r\n      this.indent = (options.indent * this.horizontalScaling) / 100;\r\n    }\r\n    if (options.characterSpacing != null) {\r\n      this.characterSpacing =\r\n        (options.characterSpacing * this.horizontalScaling) / 100;\r\n    }\r\n    if (options.wordSpacing != null) {\r\n      this.wordSpacing = (options.wordSpacing * this.horizontalScaling) / 100;\r\n    }\r\n    if (options.ellipsis != null) {\r\n      this.ellipsis = options.ellipsis;\r\n    }\r\n\r\n    // make sure we're actually on the page\r\n    // and that the first line of is never by\r\n    // itself at the bottom of a page (orphans)\r\n    const nextY = this.document.y + this.document.currentLineHeight(true);\r\n    if (this.document.y > this.maxY || nextY > this.maxY) {\r\n      this.nextSection();\r\n    }\r\n\r\n    let buffer = '';\r\n    let textWidth = 0;\r\n    let wc = 0;\r\n    let lc = 0;\r\n\r\n    let { y } = this.document; // used to reset Y pos if options.continued (below)\r\n    const emitLine = () => {\r\n      options.textWidth = textWidth + this.wordSpacing * (wc - 1);\r\n      options.wordCount = wc;\r\n      options.lineWidth = this.lineWidth;\r\n      ({ y } = this.document);\r\n      this.emit('line', buffer, options, this);\r\n      return lc++;\r\n    };\r\n\r\n    this.emit('sectionStart', options, this);\r\n\r\n    this.eachWord(text, (word, w, bk, last) => {\r\n      if (last == null || last.required) {\r\n        this.emit('firstLine', options, this);\r\n        this.spaceLeft = this.lineWidth;\r\n      }\r\n\r\n      if (this.canFit(word, w)) {\r\n        buffer += word;\r\n        textWidth += w;\r\n        wc++;\r\n      }\r\n\r\n      if (bk.required || !this.canFit(word, w)) {\r\n        // if the user specified a max height and an ellipsis, and is about to pass the\r\n        // max height and max columns after the next line, append the ellipsis\r\n        const lh = this.document.currentLineHeight(true);\r\n        if (\r\n          this.height != null &&\r\n          this.ellipsis &&\r\n          PDFNumber(this.document.y + lh * 2) > this.maxY &&\r\n          this.column >= this.columns\r\n        ) {\r\n          if (this.ellipsis === true) {\r\n            this.ellipsis = '…';\r\n          } // map default ellipsis character\r\n          buffer = buffer.replace(/\\s+$/, '');\r\n          textWidth = this.wordWidth(buffer + this.ellipsis);\r\n\r\n          // remove characters from the buffer until the ellipsis fits\r\n          // to avoid infinite loop need to stop while-loop if buffer is empty string\r\n          while (buffer && textWidth > this.lineWidth) {\r\n            buffer = buffer.slice(0, -1).replace(/\\s+$/, '');\r\n            textWidth = this.wordWidth(buffer + this.ellipsis);\r\n          }\r\n          // need to add ellipsis only if there is enough space for it\r\n          if (textWidth <= this.lineWidth) {\r\n            buffer = buffer + this.ellipsis;\r\n          }\r\n\r\n          textWidth = this.wordWidth(buffer);\r\n        }\r\n\r\n        if (bk.required) {\r\n          if (w > this.spaceLeft) {\r\n            emitLine();\r\n            buffer = word;\r\n            textWidth = w;\r\n            wc = 1;\r\n          }\r\n\r\n          this.emit('lastLine', options, this);\r\n        }\r\n\r\n        // Previous entry is a soft hyphen - add visible hyphen.\r\n        if (buffer[buffer.length - 1] == SOFT_HYPHEN) {\r\n          buffer = buffer.slice(0, -1) + HYPHEN;\r\n          this.spaceLeft -= this.wordWidth(HYPHEN);\r\n        }\r\n\r\n        emitLine();\r\n\r\n        // if we've reached the edge of the page,\r\n        // continue on a new page or column\r\n        if (PDFNumber(this.document.y + lh) > this.maxY) {\r\n          const shouldContinue = this.nextSection();\r\n\r\n          // stop if we reached the maximum height\r\n          if (!shouldContinue) {\r\n            wc = 0;\r\n            buffer = '';\r\n            return false;\r\n          }\r\n        }\r\n\r\n        // reset the space left and buffer\r\n        if (bk.required) {\r\n          this.spaceLeft = this.lineWidth;\r\n          buffer = '';\r\n          textWidth = 0;\r\n          return (wc = 0);\r\n        } else {\r\n          // reset the space left and buffer\r\n          this.spaceLeft = this.lineWidth - w;\r\n          buffer = word;\r\n          textWidth = w;\r\n          return (wc = 1);\r\n        }\r\n      } else {\r\n        return (this.spaceLeft -= w);\r\n      }\r\n    });\r\n\r\n    if (wc > 0) {\r\n      this.emit('lastLine', options, this);\r\n      emitLine();\r\n    }\r\n\r\n    this.emit('sectionEnd', options, this);\r\n\r\n    // if the wrap is set to be continued, save the X position\r\n    // to start the first line of the next segment at, and reset\r\n    // the y position\r\n    if (options.continued === true) {\r\n      if (lc > 1) {\r\n        this.continuedX = 0;\r\n      }\r\n      this.continuedX += options.textWidth || 0;\r\n      this.document.y = y;\r\n    } else {\r\n      this.document.x = this.startX;\r\n    }\r\n  }\r\n\r\n  nextSection(options) {\r\n    this.emit('sectionEnd', options, this);\r\n\r\n    if (++this.column > this.columns) {\r\n      // if a max height was specified by the user, we're done.\r\n      // otherwise, the default is to make a new page at the bottom.\r\n      if (this.height != null) {\r\n        return false;\r\n      }\r\n\r\n      this.document.continueOnNewPage();\r\n      this.column = 1;\r\n      this.startY = this.document.page.margins.top;\r\n      this.maxY = this.document.page.maxY();\r\n      this.document.x = this.startX;\r\n      if (this.document._fillColor) {\r\n        this.document.fillColor(...this.document._fillColor);\r\n      }\r\n      this.emit('pageBreak', options, this);\r\n    } else {\r\n      this.document.x += this.lineWidth + this.columnGap;\r\n      this.document.y = this.startY;\r\n      this.emit('columnBreak', options, this);\r\n    }\r\n\r\n    this.emit('sectionStart', options, this);\r\n    return true;\r\n  }\r\n}\r\n\r\nexport default LineWrapper;\r\n","import LineWrapper from '../line_wrapper';\nimport PDFObject from '../object';\nimport { cosine, sine } from '../utils';\n\nconst { number } = PDFObject;\n\nexport default {\n  initText() {\n    this._line = this._line.bind(this);\n    // Current coordinates\n    this.x = 0;\n    this.y = 0;\n    this._lineGap = 0;\n  },\n\n  lineGap(_lineGap) {\n    this._lineGap = _lineGap;\n    return this;\n  },\n\n  moveDown(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n    this.y += this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n\n  moveUp(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n    this.y -= this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n\n  _text(text, x, y, options, lineCallback) {\n    options = this._initOptions(x, y, options);\n\n    // Convert text to a string\n    text = text == null ? '' : `${text}`;\n\n    // if the wordSpacing option is specified, remove multiple consecutive spaces\n    if (options.wordSpacing) {\n      text = text.replace(/\\s{2,}/g, ' ');\n    }\n\n    const addStructure = () => {\n      if (options.structParent) {\n        options.structParent.add(\n          this.struct(options.structType || 'P', [\n            this.markStructureContent(options.structType || 'P'),\n          ]),\n        );\n      }\n    };\n\n    // We can save some bytes if there is no rotation\n    if (options.rotation !== 0) {\n      this.save();\n      this.rotate(-options.rotation, { origin: [this.x, this.y] });\n    }\n\n    // word wrapping\n    if (options.width) {\n      let wrapper = this._wrapper;\n      if (!wrapper) {\n        wrapper = new LineWrapper(this, options);\n        wrapper.on('line', lineCallback);\n        wrapper.on('firstLine', addStructure);\n      }\n\n      this._wrapper = options.continued ? wrapper : null;\n      this._textOptions = options.continued ? options : null;\n      wrapper.wrap(text, options);\n\n      // render paragraphs as single lines\n    } else {\n      for (let line of text.split('\\n')) {\n        addStructure();\n        lineCallback(line, options);\n      }\n    }\n\n    // Cleanup if there was a rotation\n    if (options.rotation !== 0) this.restore();\n\n    return this;\n  },\n\n  text(text, x, y, options) {\n    return this._text(text, x, y, options, this._line);\n  },\n\n  widthOfString(string, options = {}) {\n    const horizontalScaling = options.horizontalScaling || 100;\n    return (\n      ((this._font.widthOfString(string, this._fontSize, options.features) +\n        (options.characterSpacing || 0) * (string.length - 1)) *\n        horizontalScaling) /\n      100\n    );\n  },\n\n  /**\n   * Compute the bounding box of a string\n   * based on what will actually be rendered by `doc.text()`\n   *\n   * @param string - The string\n   * @param x - X position of text (defaults to this.x)\n   * @param y - Y position of text (defaults to this.y)\n   * @param options - Any text options (The same you would apply to `doc.text()`)\n   * @returns {{x: number, y: number, width: number, height: number}}\n   */\n  boundsOfString(string, x, y, options) {\n    options = this._initOptions(x, y, options);\n    ({ x, y } = this);\n    const lineGap = options.lineGap ?? this._lineGap ?? 0;\n    const lineHeight = this.currentLineHeight(true) + lineGap;\n    let contentWidth = 0;\n    // Convert text to a string\n    string = String(string ?? '');\n\n    // if the wordSpacing option is specified, remove multiple consecutive spaces\n    if (options.wordSpacing) {\n      string = string.replace(/\\s{2,}/g, ' ');\n    }\n\n    // word wrapping\n    if (options.width) {\n      let wrapper = new LineWrapper(this, options);\n      wrapper.on('line', (text, options) => {\n        this.y += lineHeight;\n        text = text.replace(/\\n/g, '');\n\n        if (text.length) {\n          // handle options\n          let wordSpacing = options.wordSpacing ?? 0;\n          const characterSpacing = options.characterSpacing ?? 0;\n\n          // justify alignments\n          if (options.width && options.align === 'justify') {\n            // calculate the word spacing value\n            const words = text.trim().split(/\\s+/);\n            const textWidth = this.widthOfString(\n              text.replace(/\\s+/g, ''),\n              options,\n            );\n            const spaceWidth = this.widthOfString(' ') + characterSpacing;\n            wordSpacing = Math.max(\n              0,\n              (options.lineWidth - textWidth) / Math.max(1, words.length - 1) -\n                spaceWidth,\n            );\n          }\n\n          // calculate the actual rendered width of the string after word and character spacing\n          contentWidth = Math.max(\n            contentWidth,\n            options.textWidth +\n              wordSpacing * (options.wordCount - 1) +\n              characterSpacing * (text.length - 1),\n          );\n        }\n      });\n      wrapper.wrap(string, options);\n    } else {\n      // render paragraphs as single lines\n      for (let line of string.split('\\n')) {\n        const lineWidth = this.widthOfString(line, options);\n        this.y += lineHeight;\n        contentWidth = Math.max(contentWidth, lineWidth);\n      }\n    }\n\n    let contentHeight = this.y - y;\n    // Clamp height to max height\n    if (options.height) contentHeight = Math.min(contentHeight, options.height);\n\n    this.x = x;\n    this.y = y;\n\n    /**\n     * Rotates around top left corner\n     * [x1,y1]  >  [x2,y2]\n     *    ⌃           ⌄\n     * [x4,y4]  <  [x3,y3]\n     */\n    if (options.rotation === 0) {\n      // No rotation so we can use the existing values\n      return { x, y, width: contentWidth, height: contentHeight };\n      // Use fast computation without explicit trig\n    } else if (options.rotation === 90) {\n      return {\n        x: x,\n        y: y - contentWidth,\n        width: contentHeight,\n        height: contentWidth,\n      };\n    } else if (options.rotation === 180) {\n      return {\n        x: x - contentWidth,\n        y: y - contentHeight,\n        width: contentWidth,\n        height: contentHeight,\n      };\n    } else if (options.rotation === 270) {\n      return {\n        x: x - contentHeight,\n        y: y,\n        width: contentHeight,\n        height: contentWidth,\n      };\n    }\n\n    // Non-trivial values so time for trig\n    const cos = cosine(options.rotation);\n    const sin = sine(options.rotation);\n\n    const x1 = x;\n    const y1 = y;\n    const x2 = x + contentWidth * cos;\n    const y2 = y - contentWidth * sin;\n    const x3 = x + contentWidth * cos + contentHeight * sin;\n    const y3 = y - contentWidth * sin + contentHeight * cos;\n    const x4 = x + contentHeight * sin;\n    const y4 = y + contentHeight * cos;\n\n    const xMin = Math.min(x1, x2, x3, x4);\n    const xMax = Math.max(x1, x2, x3, x4);\n    const yMin = Math.min(y1, y2, y3, y4);\n    const yMax = Math.max(y1, y2, y3, y4);\n\n    return { x: xMin, y: yMin, width: xMax - xMin, height: yMax - yMin };\n  },\n\n  heightOfString(text, options) {\n    const { x, y } = this;\n\n    options = this._initOptions(options);\n    options.height = Infinity; // don't break pages\n\n    const lineGap = options.lineGap || this._lineGap || 0;\n    this._text(text, this.x, this.y, options, () => {\n      this.y += this.currentLineHeight(true) + lineGap;\n    });\n\n    const height = this.y - y;\n    this.x = x;\n    this.y = y;\n\n    return height;\n  },\n\n  list(list, x, y, options, wrapper) {\n    options = this._initOptions(x, y, options);\n\n    const listType = options.listType || 'bullet';\n    const unit = Math.round((this._font.ascender / 1000) * this._fontSize);\n    const midLine = unit / 2;\n    const r = options.bulletRadius || unit / 3;\n    const indent =\n      options.textIndent || (listType === 'bullet' ? r * 5 : unit * 2);\n    const itemIndent =\n      options.bulletIndent || (listType === 'bullet' ? r * 8 : unit * 2);\n\n    let level = 1;\n    const items = [];\n    const levels = [];\n    const numbers = [];\n\n    var flatten = function (list) {\n      let n = 1;\n      for (let i = 0; i < list.length; i++) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n          level++;\n          flatten(item);\n          level--;\n        } else {\n          items.push(item);\n          levels.push(level);\n          if (listType !== 'bullet') {\n            numbers.push(n++);\n          }\n        }\n      }\n    };\n\n    flatten(list);\n\n    const label = function (n) {\n      switch (listType) {\n        case 'numbered':\n          return `${n}.`;\n        case 'lettered':\n          var letter = String.fromCharCode(((n - 1) % 26) + 65);\n          var times = Math.floor((n - 1) / 26 + 1);\n          var text = Array(times + 1).join(letter);\n          return `${text}.`;\n      }\n    };\n\n    const drawListItem = function (listItem, i) {\n      wrapper = new LineWrapper(this, options);\n      wrapper.on('line', this._line);\n\n      level = 1;\n      wrapper.once('firstLine', () => {\n        let item, itemType, labelType, bodyType;\n        if (options.structParent) {\n          if (options.structTypes) {\n            [itemType, labelType, bodyType] = options.structTypes;\n          } else {\n            [itemType, labelType, bodyType] = ['LI', 'Lbl', 'LBody'];\n          }\n        }\n\n        if (itemType) {\n          item = this.struct(itemType);\n          options.structParent.add(item);\n        } else if (options.structParent) {\n          item = options.structParent;\n        }\n\n        let l;\n        if ((l = levels[i++]) !== level) {\n          const diff = itemIndent * (l - level);\n          this.x += diff;\n          wrapper.lineWidth -= diff;\n          level = l;\n        }\n\n        if (item && (labelType || bodyType)) {\n          item.add(\n            this.struct(labelType || bodyType, [\n              this.markStructureContent(labelType || bodyType),\n            ]),\n          );\n        }\n        switch (listType) {\n          case 'bullet':\n            this.circle(this.x - indent + r, this.y + midLine, r);\n            this.fill();\n            break;\n          case 'numbered':\n          case 'lettered':\n            var text = label(numbers[i - 1]);\n            this._fragment(text, this.x - indent, this.y, options);\n            break;\n        }\n\n        if (item && labelType && bodyType) {\n          item.add(\n            this.struct(bodyType, [this.markStructureContent(bodyType)]),\n          );\n        }\n        if (item && item !== options.structParent) {\n          item.end();\n        }\n      });\n\n      wrapper.on('sectionStart', () => {\n        const pos = indent + itemIndent * (level - 1);\n        this.x += pos;\n        wrapper.lineWidth -= pos;\n      });\n\n      wrapper.on('sectionEnd', () => {\n        const pos = indent + itemIndent * (level - 1);\n        this.x -= pos;\n        wrapper.lineWidth += pos;\n      });\n\n      wrapper.wrap(listItem, options);\n    };\n\n    for (let i = 0; i < items.length; i++) {\n      drawListItem.call(this, items[i], i);\n    }\n\n    return this;\n  },\n\n  _initOptions(x = {}, y, options = {}) {\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n\n    // clone options object\n    const result = Object.assign({}, options);\n\n    // extend options with previous values for continued text\n    if (this._textOptions) {\n      for (let key in this._textOptions) {\n        const val = this._textOptions[key];\n        if (key !== 'continued') {\n          if (result[key] === undefined) {\n            result[key] = val;\n          }\n        }\n      }\n    }\n\n    // Update the current position\n    if (x != null) {\n      this.x = x;\n    }\n    if (y != null) {\n      this.y = y;\n    }\n\n    // wrap to margins if no x or y position passed\n    if (result.lineBreak !== false) {\n      if (result.width == null) {\n        result.width = this.page.width - this.x - this.page.margins.right;\n      }\n      result.width = Math.max(result.width, 0);\n    }\n\n    if (!result.columns) {\n      result.columns = 0;\n    }\n    if (result.columnGap == null) {\n      result.columnGap = 18;\n    } // 1/4 inch\n\n    // Normalize rotation to between 0 - 360\n    result.rotation = Number(options.rotation ?? 0) % 360;\n    if (result.rotation < 0) result.rotation += 360;\n\n    return result;\n  },\n\n  _line(text, options = {}, wrapper) {\n    this._fragment(text, this.x, this.y, options);\n    const lineGap = options.lineGap || this._lineGap || 0;\n\n    if (!wrapper) {\n      this.x += this.widthOfString(text, options);\n    } else {\n      this.y += this.currentLineHeight(true) + lineGap;\n    }\n  },\n\n  _fragment(text, x, y, options) {\n    let dy, encoded, i, positions, textWidth, words;\n    text = `${text}`.replace(/\\n/g, '');\n    if (text.length === 0) {\n      return;\n    }\n\n    // handle options\n    const align = options.align || 'left';\n    let wordSpacing = options.wordSpacing || 0;\n    const characterSpacing = options.characterSpacing || 0;\n    const horizontalScaling = options.horizontalScaling || 100;\n\n    // text alignments\n    if (options.width) {\n      switch (align) {\n        case 'right':\n          textWidth = this.widthOfString(text.replace(/\\s+$/, ''), options);\n          x += options.lineWidth - textWidth;\n          break;\n\n        case 'center':\n          x += options.lineWidth / 2 - options.textWidth / 2;\n          break;\n\n        case 'justify':\n          // calculate the word spacing value\n          words = text.trim().split(/\\s+/);\n          textWidth = this.widthOfString(text.replace(/\\s+/g, ''), options);\n          var spaceWidth = this.widthOfString(' ') + characterSpacing;\n          wordSpacing = Math.max(\n            0,\n            (options.lineWidth - textWidth) / Math.max(1, words.length - 1) -\n              spaceWidth,\n          );\n          break;\n      }\n    }\n\n    // text baseline alignments based on http://wiki.apache.org/xmlgraphics-fop/LineLayout/AlignmentHandling\n    if (typeof options.baseline === 'number') {\n      dy = -options.baseline;\n    } else {\n      switch (options.baseline) {\n        case 'svg-middle':\n          dy = 0.5 * this._font.xHeight;\n          break;\n        case 'middle':\n        case 'svg-central':\n          dy = 0.5 * (this._font.descender + this._font.ascender);\n          break;\n        case 'bottom':\n        case 'ideographic':\n          dy = this._font.descender;\n          break;\n        case 'alphabetic':\n          dy = 0;\n          break;\n        case 'mathematical':\n          dy = 0.5 * this._font.ascender;\n          break;\n        case 'hanging':\n          dy = 0.8 * this._font.ascender;\n          break;\n        case 'top':\n          dy = this._font.ascender;\n          break;\n        default:\n          dy = this._font.ascender;\n      }\n      dy = (dy / 1000) * this._fontSize;\n    }\n\n    // calculate the actual rendered width of the string after word and character spacing\n    const renderedWidth =\n      options.textWidth +\n      wordSpacing * (options.wordCount - 1) +\n      characterSpacing * (text.length - 1);\n\n    // create link annotations if the link option is given\n    if (options.link != null) {\n      this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);\n    }\n    if (options.goTo != null) {\n      this.goTo(x, y, renderedWidth, this.currentLineHeight(), options.goTo);\n    }\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    }\n\n    // create underline\n    if (options.underline) {\n      this.save();\n      if (!options.stroke) {\n        this.strokeColor(...(this._fillColor || []));\n      }\n\n      const lineWidth =\n        this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n\n      let lineY = y + this.currentLineHeight() - lineWidth;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    }\n\n    // create strikethrough line\n    if (options.strike) {\n      this.save();\n      if (!options.stroke) {\n        this.strokeColor(...(this._fillColor || []));\n      }\n\n      const lineWidth =\n        this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n\n      let lineY = y + this.currentLineHeight() / 2;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    }\n\n    this.save();\n\n    // oblique (angle in degrees or boolean)\n    if (options.oblique) {\n      let skew;\n      if (typeof options.oblique === 'number') {\n        skew = -Math.tan((options.oblique * Math.PI) / 180);\n      } else {\n        skew = -0.25;\n      }\n      this.transform(1, 0, 0, 1, x, y);\n      this.transform(1, 0, skew, 1, -skew * dy, 0);\n      this.transform(1, 0, 0, 1, -x, -y);\n    }\n\n    // flip coordinate system\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n    y = this.page.height - y - dy;\n\n    // add current font to page if necessary\n    if (this.page.fonts[this._font.id] == null) {\n      this.page.fonts[this._font.id] = this._font.ref();\n    }\n\n    // begin the text object\n    this.addContent('BT');\n\n    // text position\n    this.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n\n    // font and font size\n    this.addContent(`/${this._font.id} ${number(this._fontSize)} Tf`);\n\n    // rendering mode\n    const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;\n    if (mode) {\n      this.addContent(`${mode} Tr`);\n    }\n\n    // Character spacing\n    if (characterSpacing) {\n      this.addContent(`${number(characterSpacing)} Tc`);\n    }\n\n    // Horizontal scaling\n    if (horizontalScaling !== 100) {\n      this.addContent(`${horizontalScaling} Tz`);\n    }\n\n    // Add the actual text\n    // If we have a word spacing value, we need to encode each word separately\n    // since the normal Tw operator only works on character code 32, which isn't\n    // used for embedded fonts.\n    if (wordSpacing) {\n      words = text.trim().split(/\\s+/);\n      wordSpacing += this.widthOfString(' ') + characterSpacing;\n      wordSpacing *= 1000 / this._fontSize;\n\n      encoded = [];\n      positions = [];\n      for (let word of words) {\n        const [encodedWord, positionsWord] = this._font.encode(\n          word,\n          options.features,\n        );\n        encoded = encoded.concat(encodedWord);\n        positions = positions.concat(positionsWord);\n\n        // add the word spacing to the end of the word\n        // clone object because of cache\n        const space = {};\n        const object = positions[positions.length - 1];\n        for (let key in object) {\n          const val = object[key];\n          space[key] = val;\n        }\n        space.xAdvance += wordSpacing;\n        positions[positions.length - 1] = space;\n      }\n    } else {\n      [encoded, positions] = this._font.encode(text, options.features);\n    }\n\n    const scale = this._fontSize / 1000;\n    const commands = [];\n    let last = 0;\n    let hadOffset = false;\n\n    // Adds a segment of text to the TJ command buffer\n    const addSegment = (cur) => {\n      if (last < cur) {\n        const hex = encoded.slice(last, cur).join('');\n        const advance =\n          positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n        commands.push(`<${hex}> ${number(-advance)}`);\n      }\n\n      last = cur;\n    };\n\n    // Flushes the current TJ commands to the output stream\n    const flush = (i) => {\n      addSegment(i);\n\n      if (commands.length > 0) {\n        this.addContent(`[${commands.join(' ')}] TJ`);\n        commands.length = 0;\n      }\n    };\n\n    for (i = 0; i < positions.length; i++) {\n      // If we have an x or y offset, we have to break out of the current TJ command\n      // so we can move the text position.\n      const pos = positions[i];\n      if (pos.xOffset || pos.yOffset) {\n        // Flush the current buffer\n        flush(i);\n\n        // Move the text position and flush just the current character\n        this.addContent(\n          `1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(\n            y + pos.yOffset * scale,\n          )} Tm`,\n        );\n        flush(i + 1);\n\n        hadOffset = true;\n      } else {\n        // If the last character had an offset, reset the text position\n        if (hadOffset) {\n          this.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n          hadOffset = false;\n        }\n\n        // Group segments that don't have any advance adjustments\n        if (pos.xAdvance - pos.advanceWidth !== 0) {\n          addSegment(i + 1);\n        }\n      }\n\n      x += pos.xAdvance * scale;\n    }\n\n    // Flush any remaining commands\n    flush(i);\n\n    // end the text object\n    this.addContent('ET');\n\n    // restore flipped coordinate system\n    this.restore();\n  },\n};\n","import exif from 'jpeg-exif';\n\nconst MARKERS = [\n  0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9,\n  0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf,\n];\n\nconst COLOR_SPACE_MAP = {\n  1: 'DeviceGray',\n  3: 'DeviceRGB',\n  4: 'DeviceCMYK',\n};\n\nclass JPEG {\n  constructor(data, label) {\n    let marker;\n    this.data = data;\n    this.label = label;\n    if (this.data.readUInt16BE(0) !== 0xffd8) {\n      throw 'SOI not found in JPEG';\n    }\n\n    // Parse the EXIF orientation\n    this.orientation = exif.fromBuffer(this.data).Orientation || 1;\n\n    let pos = 2;\n    while (pos < this.data.length) {\n      marker = this.data.readUInt16BE(pos);\n      pos += 2;\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n      pos += this.data.readUInt16BE(pos);\n    }\n\n    if (!MARKERS.includes(marker)) {\n      throw 'Invalid JPEG.';\n    }\n    pos += 2;\n\n    this.bits = this.data[pos++];\n    this.height = this.data.readUInt16BE(pos);\n    pos += 2;\n\n    this.width = this.data.readUInt16BE(pos);\n    pos += 2;\n\n    const channels = this.data[pos++];\n    this.colorSpace = COLOR_SPACE_MAP[channels];\n\n    this.obj = null;\n  }\n\n  embed(document) {\n    if (this.obj) {\n      return;\n    }\n\n    this.obj = document.ref({\n      Type: 'XObject',\n      Subtype: 'Image',\n      BitsPerComponent: this.bits,\n      Width: this.width,\n      Height: this.height,\n      ColorSpace: this.colorSpace,\n      Filter: 'DCTDecode',\n    });\n\n    // add extra decode params for CMYK images. By swapping the\n    // min and max values from the default, we invert the colors. See\n    // section 4.8.4 of the spec.\n    if (this.colorSpace === 'DeviceCMYK') {\n      this.obj.data['Decode'] = [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0];\n    }\n\n    this.obj.end(this.data);\n\n    // free memory\n    return (this.data = null);\n  }\n}\n\nexport default JPEG;\n","import zlib from 'zlib';\nimport PNG from 'png-js';\n\nclass PNGImage {\n  constructor(data, label) {\n    this.label = label;\n    this.image = new PNG(data);\n    this.width = this.image.width;\n    this.height = this.image.height;\n    this.imgData = this.image.imgData;\n    this.obj = null;\n  }\n\n  embed(document) {\n    let dataDecoded = false;\n\n    this.document = document;\n    if (this.obj) {\n      return;\n    }\n\n    const hasAlphaChannel = this.image.hasAlphaChannel;\n    const isInterlaced = this.image.interlaceMethod === 1;\n\n    this.obj = this.document.ref({\n      Type: 'XObject',\n      Subtype: 'Image',\n      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,\n      Width: this.width,\n      Height: this.height,\n      Filter: 'FlateDecode',\n    });\n\n    if (!hasAlphaChannel) {\n      const params = this.document.ref({\n        Predictor: isInterlaced ? 1 : 15,\n        Colors: this.image.colors,\n        BitsPerComponent: this.image.bits,\n        Columns: this.width,\n      });\n\n      this.obj.data['DecodeParms'] = params;\n      params.end();\n    }\n\n    if (this.image.palette.length === 0) {\n      this.obj.data['ColorSpace'] = this.image.colorSpace;\n    } else {\n      // embed the color palette in the PDF as an object stream\n      const palette = this.document.ref();\n      palette.end(Buffer.from(this.image.palette));\n\n      // build the color space array for the image\n      this.obj.data['ColorSpace'] = [\n        'Indexed',\n        'DeviceRGB',\n        this.image.palette.length / 3 - 1,\n        palette,\n      ];\n    }\n\n    // For PNG color types 0, 2 and 3, the transparency data is stored in\n    // a dedicated PNG chunk.\n    if (this.image.transparency.grayscale != null) {\n      // Use Color Key Masking (spec section 4.8.5)\n      // An array with N elements, where N is two times the number of color components.\n      const val = this.image.transparency.grayscale;\n      this.obj.data['Mask'] = [val, val];\n    } else if (this.image.transparency.rgb) {\n      // Use Color Key Masking (spec section 4.8.5)\n      // An array with N elements, where N is two times the number of color components.\n      const { rgb } = this.image.transparency;\n      const mask = [];\n      for (let x of rgb) {\n        mask.push(x, x);\n      }\n\n      this.obj.data['Mask'] = mask;\n    } else if (this.image.transparency.indexed) {\n      // Create a transparency SMask for the image based on the data\n      // in the PLTE and tRNS sections. See below for details on SMasks.\n      dataDecoded = true;\n      return this.loadIndexedAlphaChannel();\n    } else if (hasAlphaChannel) {\n      // For PNG color types 4 and 6, the transparency data is stored as a alpha\n      // channel mixed in with the main image data. Separate this data out into an\n      // SMask object and store it separately in the PDF.\n      dataDecoded = true;\n      return this.splitAlphaChannel();\n    }\n\n    if (isInterlaced && !dataDecoded) {\n      return this.decodeData();\n    }\n\n    this.finalize();\n  }\n\n  finalize() {\n    if (this.alphaChannel) {\n      const sMask = this.document.ref({\n        Type: 'XObject',\n        Subtype: 'Image',\n        Height: this.height,\n        Width: this.width,\n        BitsPerComponent: 8,\n        Filter: 'FlateDecode',\n        ColorSpace: 'DeviceGray',\n        Decode: [0, 1],\n      });\n\n      sMask.end(this.alphaChannel);\n      this.obj.data['SMask'] = sMask;\n    }\n\n    // add the actual image data\n    this.obj.end(this.imgData);\n\n    // free memory\n    this.image = null;\n    return (this.imgData = null);\n  }\n\n  splitAlphaChannel() {\n    return this.image.decodePixels((pixels) => {\n      let a, p;\n      const colorCount = this.image.colors;\n      const pixelCount = this.width * this.height;\n      const imgData = Buffer.alloc(pixelCount * colorCount);\n      const alphaChannel = Buffer.alloc(pixelCount);\n\n      let i = (p = a = 0);\n      const len = pixels.length;\n      // For 16bit images copy only most significant byte (MSB) - PNG data is always stored in network byte order (MSB first)\n      const skipByteCount = this.image.bits === 16 ? 1 : 0;\n      while (i < len) {\n        for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {\n          imgData[p++] = pixels[i++];\n          i += skipByteCount;\n        }\n        alphaChannel[a++] = pixels[i++];\n        i += skipByteCount;\n      }\n\n      this.imgData = zlib.deflateSync(imgData);\n      this.alphaChannel = zlib.deflateSync(alphaChannel);\n      return this.finalize();\n    });\n  }\n\n  loadIndexedAlphaChannel() {\n    const transparency = this.image.transparency.indexed;\n    return this.image.decodePixels((pixels) => {\n      const alphaChannel = Buffer.alloc(this.width * this.height);\n\n      let i = 0;\n      for (let j = 0, end = pixels.length; j < end; j++) {\n        alphaChannel[i++] = transparency[pixels[j]];\n      }\n\n      this.alphaChannel = zlib.deflateSync(alphaChannel);\n      return this.finalize();\n    });\n  }\n\n  decodeData() {\n    this.image.decodePixels((pixels) => {\n      this.imgData = zlib.deflateSync(pixels);\n      this.finalize();\n    });\n  }\n}\n\nexport default PNGImage;\n","/*\r\nPDFImage - embeds images in PDF documents\r\nBy Devon Govett\r\n*/\r\n\r\nimport fs from 'fs';\r\nimport JPEG from './image/jpeg';\r\nimport PNG from './image/png';\r\n\r\nclass PDFImage {\r\n  static open(src, label) {\r\n    let data;\r\n    if (Buffer.isBuffer(src)) {\r\n      data = src;\r\n    } else if (src instanceof ArrayBuffer) {\r\n      data = Buffer.from(new Uint8Array(src));\r\n    } else {\r\n      const match = /^data:.+?;base64,(.*)$/.exec(src);\r\n      if (match) {\r\n        data = Buffer.from(match[1], 'base64');\r\n      } else {\r\n        data = fs.readFileSync(src);\r\n        if (!data) {\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (data[0] === 0xff && data[1] === 0xd8) {\r\n      return new JPEG(data, label);\r\n    } else if (data[0] === 0x89 && data.toString('ascii', 1, 4) === 'PNG') {\r\n      return new PNG(data, label);\r\n    } else {\r\n      throw new Error('Unknown image format.');\r\n    }\r\n  }\r\n}\r\n\r\nexport default PDFImage;\r\n","import PDFImage from '../image';\n\nexport default {\n  initImages() {\n    this._imageRegistry = {};\n    this._imageCount = 0;\n  },\n\n  image(src, x, y, options = {}) {\n    let bh, bp, bw, image, ip, left, left1, originX, originY;\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n\n    // Ignore orientation based on document options or image options\n    const ignoreOrientation =\n      options.ignoreOrientation ||\n      (options.ignoreOrientation !== false && this.options.ignoreOrientation);\n\n    const inDocumentFlow = typeof y !== 'number';\n\n    x = (left = x != null ? x : options.x) != null ? left : this.x;\n    y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;\n\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n\n    if (!image) {\n      if (src.width && src.height) {\n        image = src;\n      } else {\n        image = this.openImage(src);\n      }\n    }\n\n    if (!image.obj) {\n      image.embed(this);\n    }\n\n    if (this.page.xobjects[image.label] == null) {\n      this.page.xobjects[image.label] = image.obj;\n    }\n\n    let { width, height } = image;\n\n    // If EXIF orientation calls for it, swap width and height\n    if (!ignoreOrientation && image.orientation > 4) {\n      [width, height] = [height, width];\n    }\n\n    let w = options.width || width;\n    let h = options.height || height;\n\n    if (options.width && !options.height) {\n      const wp = w / width;\n      w = width * wp;\n      h = height * wp;\n    } else if (options.height && !options.width) {\n      const hp = h / height;\n      w = width * hp;\n      h = height * hp;\n    } else if (options.scale) {\n      w = width * options.scale;\n      h = height * options.scale;\n    } else if (options.fit) {\n      [bw, bh] = options.fit;\n      bp = bw / bh;\n      ip = width / height;\n      if (ip > bp) {\n        w = bw;\n        h = bw / ip;\n      } else {\n        h = bh;\n        w = bh * ip;\n      }\n    } else if (options.cover) {\n      [bw, bh] = options.cover;\n      bp = bw / bh;\n      ip = width / height;\n      if (ip > bp) {\n        h = bh;\n        w = bh * ip;\n      } else {\n        w = bw;\n        h = bw / ip;\n      }\n    }\n\n    if (options.fit || options.cover) {\n      if (options.align === 'center') {\n        x = x + bw / 2 - w / 2;\n      } else if (options.align === 'right') {\n        x = x + bw - w;\n      }\n\n      if (options.valign === 'center') {\n        y = y + bh / 2 - h / 2;\n      } else if (options.valign === 'bottom') {\n        y = y + bh - h;\n      }\n    }\n\n    // need to flip image by default because of the default transform matrix on the document\n    let rotateAngle = 0;\n    let xTransform = x;\n    let yTransform = y;\n    let hTransform = h;\n    let wTransform = w;\n\n    if (!ignoreOrientation) {\n      switch (image.orientation) {\n        // No orientation (need to flip image, though, because of the default transform matrix on the document)\n        default:\n        case 1:\n          hTransform = -h;\n          yTransform += h;\n\n          break;\n        // Flip Horizontal\n        case 2:\n          wTransform = -w;\n          hTransform = -h;\n          xTransform += w;\n          yTransform += h;\n\n          break;\n        // Rotate 180 degrees\n        case 3:\n          originX = x;\n          originY = y;\n\n          hTransform = -h;\n          xTransform -= w;\n\n          rotateAngle = 180;\n          break;\n        // Flip vertical\n        case 4:\n          // Do nothing, image will be flipped\n\n          break;\n        // Flip horizontally and rotate 270 degrees CW\n        case 5:\n          originX = x;\n          originY = y;\n\n          wTransform = h;\n          hTransform = w;\n          yTransform -= hTransform;\n\n          rotateAngle = 90;\n          break;\n        // Rotate 90 degrees CW\n        case 6:\n          originX = x;\n          originY = y;\n\n          wTransform = h;\n          hTransform = -w;\n\n          rotateAngle = 90;\n          break;\n        // Flip horizontally and rotate 90 degrees CW\n        case 7:\n          originX = x;\n          originY = y;\n\n          hTransform = -w;\n          wTransform = -h;\n          xTransform += h;\n\n          rotateAngle = 90;\n          break;\n        // Rotate 270 degrees CW\n        case 8:\n          originX = x;\n          originY = y;\n\n          wTransform = h;\n          hTransform = -w;\n          xTransform -= h;\n          yTransform += w;\n\n          rotateAngle = -90;\n          break;\n      }\n    } else {\n      hTransform = -h;\n      yTransform += h;\n    }\n\n    // create link annotations if the link option is given\n    if (options.link != null) {\n      this.link(x, y, w, h, options.link);\n    }\n    if (options.goTo != null) {\n      this.goTo(x, y, w, h, options.goTo);\n    }\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    }\n\n    // Set the current y position to below the image if it is in the document flow\n    if (inDocumentFlow) {\n      this.y += h;\n    }\n\n    this.save();\n\n    if (rotateAngle) {\n      this.rotate(rotateAngle, {\n        origin: [originX, originY],\n      });\n    }\n\n    this.transform(wTransform, 0, 0, hTransform, xTransform, yTransform);\n    this.addContent(`/${image.label} Do`);\n    this.restore();\n\n    return this;\n  },\n\n  openImage(src) {\n    let image;\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n\n    if (!image) {\n      image = PDFImage.open(src, `I${++this._imageCount}`);\n      if (typeof src === 'string') {\n        this._imageRegistry[src] = image;\n      }\n    }\n\n    return image;\n  },\n};\n","export default {\n  annotate(x, y, w, h, options) {\n    options.Type = 'Annot';\n    options.Rect = this._convertRect(x, y, w, h);\n    options.Border = [0, 0, 0];\n\n    if (options.Subtype === 'Link' && typeof options.F === 'undefined') {\n      options.F = 1 << 2; // Print Annotation Flag\n    }\n\n    if (options.Subtype !== 'Link') {\n      if (options.C == null) {\n        options.C = this._normalizeColor(options.color || [0, 0, 0]);\n      }\n    } // convert colors\n    delete options.color;\n\n    if (typeof options.Dest === 'string') {\n      options.Dest = new String(options.Dest);\n    }\n\n    // Capitalize keys\n    for (let key in options) {\n      const val = options[key];\n      options[key[0].toUpperCase() + key.slice(1)] = val;\n    }\n\n    const ref = this.ref(options);\n    this.page.annotations.push(ref);\n    ref.end();\n    return this;\n  },\n\n  note(x, y, w, h, contents, options = {}) {\n    options.Subtype = 'Text';\n    options.Contents = new String(contents);\n    if (options.Name == null) {\n      options.Name = 'Comment';\n    }\n    if (options.color == null) {\n      options.color = [243, 223, 92];\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n\n  goTo(x, y, w, h, name, options = {}) {\n    options.Subtype = 'Link';\n    options.A = this.ref({\n      S: 'GoTo',\n      D: new String(name),\n    });\n    options.A.end();\n    return this.annotate(x, y, w, h, options);\n  },\n\n  link(x, y, w, h, url, options = {}) {\n    options.Subtype = 'Link';\n\n    if (typeof url === 'number') {\n      // Link to a page in the document (the page must already exist)\n      const pages = this._root.data.Pages.data;\n      if (url >= 0 && url < pages.Kids.length) {\n        options.A = this.ref({\n          S: 'GoTo',\n          D: [pages.Kids[url], 'XYZ', null, null, null],\n        });\n        options.A.end();\n      } else {\n        throw new Error(`The document has no page ${url}`);\n      }\n    } else {\n      // Link to an external url\n      options.A = this.ref({\n        S: 'URI',\n        URI: new String(url),\n      });\n      options.A.end();\n    }\n\n    return this.annotate(x, y, w, h, options);\n  },\n\n  _markup(x, y, w, h, options = {}) {\n    const [x1, y1, x2, y2] = this._convertRect(x, y, w, h);\n    options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n\n  highlight(x, y, w, h, options = {}) {\n    options.Subtype = 'Highlight';\n    if (options.color == null) {\n      options.color = [241, 238, 148];\n    }\n    return this._markup(x, y, w, h, options);\n  },\n\n  underline(x, y, w, h, options = {}) {\n    options.Subtype = 'Underline';\n    return this._markup(x, y, w, h, options);\n  },\n\n  strike(x, y, w, h, options = {}) {\n    options.Subtype = 'StrikeOut';\n    return this._markup(x, y, w, h, options);\n  },\n\n  lineAnnotation(x1, y1, x2, y2, options = {}) {\n    options.Subtype = 'Line';\n    options.Contents = new String();\n    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];\n    return this.annotate(x1, y1, x2, y2, options);\n  },\n\n  rectAnnotation(x, y, w, h, options = {}) {\n    options.Subtype = 'Square';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n\n  ellipseAnnotation(x, y, w, h, options = {}) {\n    options.Subtype = 'Circle';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n\n  textAnnotation(x, y, w, h, text, options = {}) {\n    options.Subtype = 'FreeText';\n    options.Contents = new String(text);\n    options.DA = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n\n  fileAnnotation(x, y, w, h, file = {}, options = {}) {\n    // create hidden file\n    const filespec = this.file(file.src, Object.assign({ hidden: true }, file));\n\n    options.Subtype = 'FileAttachment';\n    options.FS = filespec;\n\n    // add description from filespec unless description (Contents) has already been set\n    if (options.Contents) {\n      options.Contents = new String(options.Contents);\n    } else if (filespec.data.Desc) {\n      options.Contents = filespec.data.Desc;\n    }\n\n    return this.annotate(x, y, w, h, options);\n  },\n\n  _convertRect(x1, y1, w, h) {\n    // flip y1 and y2\n    let y2 = y1;\n    y1 += h;\n\n    // make x2\n    let x2 = x1 + w;\n\n    // apply current transformation matrix to points\n    const [m0, m1, m2, m3, m4, m5] = this._ctm;\n    x1 = m0 * x1 + m2 * y1 + m4;\n    y1 = m1 * x1 + m3 * y1 + m5;\n    x2 = m0 * x2 + m2 * y2 + m4;\n    y2 = m1 * x2 + m3 * y2 + m5;\n\n    return [x1, y1, x2, y2];\n  },\n};\n","class PDFOutline {\n  constructor(document, parent, title, dest, options = { expanded: false }) {\n    this.document = document;\n    this.options = options;\n    this.outlineData = {};\n\n    if (dest !== null) {\n      this.outlineData['Dest'] = [dest.dictionary, 'Fit'];\n    }\n\n    if (parent !== null) {\n      this.outlineData['Parent'] = parent;\n    }\n\n    if (title !== null) {\n      this.outlineData['Title'] = new String(title);\n    }\n\n    this.dictionary = this.document.ref(this.outlineData);\n    this.children = [];\n  }\n\n  addItem(title, options = { expanded: false }) {\n    const result = new PDFOutline(\n      this.document,\n      this.dictionary,\n      title,\n      this.document.page,\n      options,\n    );\n    this.children.push(result);\n\n    return result;\n  }\n\n  endOutline() {\n    if (this.children.length > 0) {\n      if (this.options.expanded) {\n        this.outlineData.Count = this.children.length;\n      }\n\n      const first = this.children[0],\n        last = this.children[this.children.length - 1];\n      this.outlineData.First = first.dictionary;\n      this.outlineData.Last = last.dictionary;\n\n      for (let i = 0, len = this.children.length; i < len; i++) {\n        const child = this.children[i];\n        if (i > 0) {\n          child.outlineData.Prev = this.children[i - 1].dictionary;\n        }\n        if (i < this.children.length - 1) {\n          child.outlineData.Next = this.children[i + 1].dictionary;\n        }\n        child.endOutline();\n      }\n    }\n\n    return this.dictionary.end();\n  }\n}\n\nexport default PDFOutline;\n","import PDFOutline from '../outline';\n\nexport default {\n  initOutline() {\n    this.outline = new PDFOutline(this, null, null, null);\n  },\n\n  endOutline() {\n    this.outline.endOutline();\n    if (this.outline.children.length > 0) {\n      this._root.data.Outlines = this.outline.dictionary;\n      return (this._root.data.PageMode = 'UseOutlines');\n    }\n  },\n};\n","/*\nPDFStructureContent - a reference to a marked structure content\nBy Ben Schmidt\n*/\n\nclass PDFStructureContent {\n  constructor(pageRef, mcid) {\n    this.refs = [{ pageRef, mcid }];\n  }\n\n  push(structContent) {\n    structContent.refs.forEach((ref) => this.refs.push(ref));\n  }\n}\n\nexport default PDFStructureContent;\n","/*\nPDFStructureElement - represents an element in the PDF logical structure tree\nBy Ben Schmidt\n*/\n\nimport PDFStructureContent from './structure_content';\n\nclass PDFStructureElement {\n  constructor(document, type, options = {}, children = null) {\n    this.document = document;\n\n    this._attached = false;\n    this._ended = false;\n    this._flushed = false;\n    this.dictionary = document.ref({\n      // Type: \"StructElem\",\n      S: type,\n    });\n\n    const data = this.dictionary.data;\n\n    if (Array.isArray(options) || this._isValidChild(options)) {\n      children = options;\n      options = {};\n    }\n\n    if (typeof options.title !== 'undefined') {\n      data.T = new String(options.title);\n    }\n    if (typeof options.lang !== 'undefined') {\n      data.Lang = new String(options.lang);\n    }\n    if (typeof options.alt !== 'undefined') {\n      data.Alt = new String(options.alt);\n    }\n    if (typeof options.expanded !== 'undefined') {\n      data.E = new String(options.expanded);\n    }\n    if (typeof options.actual !== 'undefined') {\n      data.ActualText = new String(options.actual);\n    }\n\n    this._children = [];\n\n    if (children) {\n      if (!Array.isArray(children)) {\n        children = [children];\n      }\n      children.forEach((child) => this.add(child));\n      this.end();\n    }\n  }\n\n  add(child) {\n    if (this._ended) {\n      throw new Error(`Cannot add child to already-ended structure element`);\n    }\n\n    if (!this._isValidChild(child)) {\n      throw new Error(`Invalid structure element child`);\n    }\n\n    if (child instanceof PDFStructureElement) {\n      child.setParent(this.dictionary);\n      if (this._attached) {\n        child.setAttached();\n      }\n    }\n\n    if (child instanceof PDFStructureContent) {\n      this._addContentToParentTree(child);\n    }\n\n    if (typeof child === 'function' && this._attached) {\n      // _contentForClosure() adds the content to the parent tree\n      child = this._contentForClosure(child);\n    }\n\n    this._children.push(child);\n\n    return this;\n  }\n\n  _addContentToParentTree(content) {\n    content.refs.forEach(({ pageRef, mcid }) => {\n      const pageStructParents = this.document\n        .getStructParentTree()\n        .get(pageRef.data.StructParents);\n      pageStructParents[mcid] = this.dictionary;\n    });\n  }\n\n  setParent(parentRef) {\n    if (this.dictionary.data.P) {\n      throw new Error(`Structure element added to more than one parent`);\n    }\n\n    this.dictionary.data.P = parentRef;\n\n    this._flush();\n  }\n\n  setAttached() {\n    if (this._attached) {\n      return;\n    }\n\n    this._children.forEach((child, index) => {\n      if (child instanceof PDFStructureElement) {\n        child.setAttached();\n      }\n      if (typeof child === 'function') {\n        this._children[index] = this._contentForClosure(child);\n      }\n    });\n\n    this._attached = true;\n\n    this._flush();\n  }\n\n  end() {\n    if (this._ended) {\n      return;\n    }\n\n    this._children\n      .filter((child) => child instanceof PDFStructureElement)\n      .forEach((child) => child.end());\n\n    this._ended = true;\n\n    this._flush();\n  }\n\n  _isValidChild(child) {\n    return (\n      child instanceof PDFStructureElement ||\n      child instanceof PDFStructureContent ||\n      typeof child === 'function'\n    );\n  }\n\n  _contentForClosure(closure) {\n    const content = this.document.markStructureContent(this.dictionary.data.S);\n    closure();\n    this.document.endMarkedContent();\n\n    this._addContentToParentTree(content);\n\n    return content;\n  }\n\n  _isFlushable() {\n    if (!this.dictionary.data.P || !this._ended) {\n      return false;\n    }\n\n    return this._children.every((child) => {\n      if (typeof child === 'function') {\n        return false;\n      }\n      if (child instanceof PDFStructureElement) {\n        return child._isFlushable();\n      }\n      return true;\n    });\n  }\n\n  _flush() {\n    if (this._flushed || !this._isFlushable()) {\n      return;\n    }\n\n    this.dictionary.data.K = [];\n\n    this._children.forEach((child) => this._flushChild(child));\n\n    this.dictionary.end();\n\n    // free memory used by children; the dictionary itself may still be\n    // referenced by a parent structure element or root, but we can\n    // at least trim the tree here\n    this._children = [];\n    this.dictionary.data.K = null;\n\n    this._flushed = true;\n  }\n\n  _flushChild(child) {\n    if (child instanceof PDFStructureElement) {\n      this.dictionary.data.K.push(child.dictionary);\n    }\n\n    if (child instanceof PDFStructureContent) {\n      child.refs.forEach(({ pageRef, mcid }) => {\n        if (!this.dictionary.data.Pg) {\n          this.dictionary.data.Pg = pageRef;\n        }\n\n        if (this.dictionary.data.Pg === pageRef) {\n          this.dictionary.data.K.push(mcid);\n        } else {\n          this.dictionary.data.K.push({\n            Type: 'MCR',\n            Pg: pageRef,\n            MCID: mcid,\n          });\n        }\n      });\n    }\n  }\n}\n\nexport default PDFStructureElement;\n","/*\nPDFNumberTree - represents a number tree object\n*/\n\nimport PDFTree from './tree';\n\nclass PDFNumberTree extends PDFTree {\n  _compareKeys(a, b) {\n    return parseInt(a) - parseInt(b);\n  }\n\n  _keysName() {\n    return 'Nums';\n  }\n\n  _dataForKey(k) {\n    return parseInt(k);\n  }\n}\n\nexport default PDFNumberTree;\n","/*\nMarkings mixin - support marked content sequences in content streams\nBy Ben Schmidt\n*/\n\nimport PDFStructureElement from '../structure_element';\nimport PDFStructureContent from '../structure_content';\nimport PDFNumberTree from '../number_tree';\nimport PDFObject from '../object';\n\nexport default {\n  initMarkings(options) {\n    this.structChildren = [];\n\n    if (options.tagged) {\n      this.getMarkInfoDictionary().data.Marked = true;\n      this.getStructTreeRoot();\n    }\n  },\n\n  markContent(tag, options = null) {\n    if (tag === 'Artifact' || (options && options.mcid)) {\n      let toClose = 0;\n      this.page.markings.forEach((marking) => {\n        if (toClose || marking.structContent || marking.tag === 'Artifact') {\n          toClose++;\n        }\n      });\n      while (toClose--) {\n        this.endMarkedContent();\n      }\n    }\n\n    if (!options) {\n      this.page.markings.push({ tag });\n      this.addContent(`/${tag} BMC`);\n      return this;\n    }\n\n    this.page.markings.push({ tag, options });\n\n    const dictionary = {};\n\n    if (typeof options.mcid !== 'undefined') {\n      dictionary.MCID = options.mcid;\n    }\n    if (tag === 'Artifact') {\n      if (typeof options.type === 'string') {\n        dictionary.Type = options.type;\n      }\n      if (Array.isArray(options.bbox)) {\n        dictionary.BBox = [\n          options.bbox[0],\n          this.page.height - options.bbox[3],\n          options.bbox[2],\n          this.page.height - options.bbox[1],\n        ];\n      }\n      if (\n        Array.isArray(options.attached) &&\n        options.attached.every((val) => typeof val === 'string')\n      ) {\n        dictionary.Attached = options.attached;\n      }\n    }\n    if (tag === 'Span') {\n      if (options.lang) {\n        dictionary.Lang = new String(options.lang);\n      }\n      if (options.alt) {\n        dictionary.Alt = new String(options.alt);\n      }\n      if (options.expanded) {\n        dictionary.E = new String(options.expanded);\n      }\n      if (options.actual) {\n        dictionary.ActualText = new String(options.actual);\n      }\n    }\n\n    this.addContent(`/${tag} ${PDFObject.convert(dictionary)} BDC`);\n    return this;\n  },\n\n  markStructureContent(tag, options = {}) {\n    const pageStructParents = this.getStructParentTree().get(\n      this.page.structParentTreeKey,\n    );\n    const mcid = pageStructParents.length;\n    pageStructParents.push(null);\n\n    this.markContent(tag, { ...options, mcid });\n\n    const structContent = new PDFStructureContent(this.page.dictionary, mcid);\n    this.page.markings.slice(-1)[0].structContent = structContent;\n    return structContent;\n  },\n\n  endMarkedContent() {\n    this.page.markings.pop();\n    this.addContent('EMC');\n    return this;\n  },\n\n  struct(type, options = {}, children = null) {\n    return new PDFStructureElement(this, type, options, children);\n  },\n\n  addStructure(structElem) {\n    const structTreeRoot = this.getStructTreeRoot();\n    structElem.setParent(structTreeRoot);\n    structElem.setAttached();\n    this.structChildren.push(structElem);\n    if (!structTreeRoot.data.K) {\n      structTreeRoot.data.K = [];\n    }\n    structTreeRoot.data.K.push(structElem.dictionary);\n    return this;\n  },\n\n  initPageMarkings(pageMarkings) {\n    pageMarkings.forEach((marking) => {\n      if (marking.structContent) {\n        const structContent = marking.structContent;\n        const newStructContent = this.markStructureContent(\n          marking.tag,\n          marking.options,\n        );\n        structContent.push(newStructContent);\n        this.page.markings.slice(-1)[0].structContent = structContent;\n      } else {\n        this.markContent(marking.tag, marking.options);\n      }\n    });\n  },\n\n  endPageMarkings(page) {\n    const pageMarkings = page.markings;\n    pageMarkings.forEach(() => page.write('EMC'));\n    page.markings = [];\n    return pageMarkings;\n  },\n\n  getMarkInfoDictionary() {\n    if (!this._root.data.MarkInfo) {\n      this._root.data.MarkInfo = this.ref({});\n    }\n    return this._root.data.MarkInfo;\n  },\n\n  hasMarkInfoDictionary() {\n    return !!this._root.data.MarkInfo;\n  },\n\n  getStructTreeRoot() {\n    if (!this._root.data.StructTreeRoot) {\n      this._root.data.StructTreeRoot = this.ref({\n        Type: 'StructTreeRoot',\n        ParentTree: new PDFNumberTree(),\n        ParentTreeNextKey: 0,\n      });\n    }\n    return this._root.data.StructTreeRoot;\n  },\n\n  getStructParentTree() {\n    return this.getStructTreeRoot().data.ParentTree;\n  },\n\n  createStructParentTreeNextKey() {\n    // initialise the MarkInfo dictionary\n    this.getMarkInfoDictionary();\n\n    const structTreeRoot = this.getStructTreeRoot();\n    const key = structTreeRoot.data.ParentTreeNextKey++;\n    structTreeRoot.data.ParentTree.add(key, []);\n    return key;\n  },\n\n  endMarkings() {\n    const structTreeRoot = this._root.data.StructTreeRoot;\n    if (structTreeRoot) {\n      structTreeRoot.end();\n      this.structChildren.forEach((structElem) => structElem.end());\n    }\n    if (this._root.data.MarkInfo) {\n      this._root.data.MarkInfo.end();\n    }\n  },\n};\n","const FIELD_FLAGS = {\n  readOnly: 1,\n  required: 2,\n  noExport: 4,\n  multiline: 0x1000,\n  password: 0x2000,\n  toggleToOffButton: 0x4000,\n  radioButton: 0x8000,\n  pushButton: 0x10000,\n  combo: 0x20000,\n  edit: 0x40000,\n  sort: 0x80000,\n  multiSelect: 0x200000,\n  noSpell: 0x400000,\n};\nconst FIELD_JUSTIFY = {\n  left: 0,\n  center: 1,\n  right: 2,\n};\nconst VALUE_MAP = { value: 'V', defaultValue: 'DV' };\nconst FORMAT_SPECIAL = {\n  zip: '0',\n  zipPlus4: '1',\n  zip4: '1',\n  phone: '2',\n  ssn: '3',\n};\nconst FORMAT_DEFAULT = {\n  number: {\n    nDec: 0,\n    sepComma: false,\n    negStyle: 'MinusBlack',\n    currency: '',\n    currencyPrepend: true,\n  },\n  percent: {\n    nDec: 0,\n    sepComma: false,\n  },\n};\n\nexport default {\n  /**\n   * Must call if adding AcroForms to a document. Must also call font() before\n   * this method to set the default font.\n   */\n  initForm() {\n    if (!this._font) {\n      throw new Error('Must set a font before calling initForm method');\n    }\n    this._acroform = {\n      fonts: {},\n      defaultFont: this._font.name,\n    };\n    this._acroform.fonts[this._font.id] = this._font.ref();\n\n    let data = {\n      Fields: [],\n      NeedAppearances: true,\n      DA: new String(`/${this._font.id} 0 Tf 0 g`),\n      DR: {\n        Font: {},\n      },\n    };\n    data.DR.Font[this._font.id] = this._font.ref();\n    const AcroForm = this.ref(data);\n    this._root.data.AcroForm = AcroForm;\n    return this;\n  },\n\n  /**\n   * Called automatically by document.js\n   */\n  endAcroForm() {\n    if (this._root.data.AcroForm) {\n      if (\n        !Object.keys(this._acroform.fonts).length &&\n        !this._acroform.defaultFont\n      ) {\n        throw new Error('No fonts specified for PDF form');\n      }\n      let fontDict = this._root.data.AcroForm.data.DR.Font;\n      Object.keys(this._acroform.fonts).forEach((name) => {\n        fontDict[name] = this._acroform.fonts[name];\n      });\n      this._root.data.AcroForm.data.Fields.forEach((fieldRef) => {\n        this._endChild(fieldRef);\n      });\n      this._root.data.AcroForm.end();\n    }\n    return this;\n  },\n\n  _endChild(ref) {\n    if (Array.isArray(ref.data.Kids)) {\n      ref.data.Kids.forEach((childRef) => {\n        this._endChild(childRef);\n      });\n      ref.end();\n    }\n    return this;\n  },\n\n  /**\n   * Creates and adds a form field to the document. Form fields are intermediate\n   * nodes in a PDF form that are used to specify form name heirarchy and form\n   * value defaults.\n   * @param {string} name - field name (T attribute in field dictionary)\n   * @param {object} options  - other attributes to include in field dictionary\n   */\n  formField(name, options = {}) {\n    let fieldDict = this._fieldDict(name, null, options);\n    let fieldRef = this.ref(fieldDict);\n    this._addToParent(fieldRef);\n    return fieldRef;\n  },\n\n  /**\n   * Creates and adds a Form Annotation to the document. Form annotations are\n   * called Widget annotations internally within a PDF file.\n   * @param {string} name - form field name (T attribute of widget annotation\n   * dictionary)\n   * @param {number} x\n   * @param {number} y\n   * @param {number} w\n   * @param {number} h\n   * @param {object} options\n   */\n  formAnnotation(name, type, x, y, w, h, options = {}) {\n    let fieldDict = this._fieldDict(name, type, options);\n    fieldDict.Subtype = 'Widget';\n    if (fieldDict.F === undefined) {\n      fieldDict.F = 4; // print the annotation\n    }\n\n    // Add Field annot to page, and get it's ref\n    this.annotate(x, y, w, h, fieldDict);\n    let annotRef = this.page.annotations[this.page.annotations.length - 1];\n\n    return this._addToParent(annotRef);\n  },\n\n  formText(name, x, y, w, h, options = {}) {\n    return this.formAnnotation(name, 'text', x, y, w, h, options);\n  },\n\n  formPushButton(name, x, y, w, h, options = {}) {\n    return this.formAnnotation(name, 'pushButton', x, y, w, h, options);\n  },\n\n  formCombo(name, x, y, w, h, options = {}) {\n    return this.formAnnotation(name, 'combo', x, y, w, h, options);\n  },\n\n  formList(name, x, y, w, h, options = {}) {\n    return this.formAnnotation(name, 'list', x, y, w, h, options);\n  },\n\n  formRadioButton(name, x, y, w, h, options = {}) {\n    return this.formAnnotation(name, 'radioButton', x, y, w, h, options);\n  },\n\n  formCheckbox(name, x, y, w, h, options = {}) {\n    return this.formAnnotation(name, 'checkbox', x, y, w, h, options);\n  },\n\n  _addToParent(fieldRef) {\n    let parent = fieldRef.data.Parent;\n    if (parent) {\n      if (!parent.data.Kids) {\n        parent.data.Kids = [];\n      }\n      parent.data.Kids.push(fieldRef);\n    } else {\n      this._root.data.AcroForm.data.Fields.push(fieldRef);\n    }\n    return this;\n  },\n\n  _fieldDict(name, type, options = {}) {\n    if (!this._acroform) {\n      throw new Error(\n        'Call document.initForm() method before adding form elements to document',\n      );\n    }\n    let opts = Object.assign({}, options);\n    if (type !== null) {\n      opts = this._resolveType(type, options);\n    }\n    opts = this._resolveFlags(opts);\n    opts = this._resolveJustify(opts);\n    opts = this._resolveFont(opts);\n    opts = this._resolveStrings(opts);\n    opts = this._resolveColors(opts);\n    opts = this._resolveFormat(opts);\n    opts.T = new String(name);\n    if (opts.parent) {\n      opts.Parent = opts.parent;\n      delete opts.parent;\n    }\n    return opts;\n  },\n\n  _resolveType(type, opts) {\n    if (type === 'text') {\n      opts.FT = 'Tx';\n    } else if (type === 'pushButton') {\n      opts.FT = 'Btn';\n      opts.pushButton = true;\n    } else if (type === 'radioButton') {\n      opts.FT = 'Btn';\n      opts.radioButton = true;\n    } else if (type === 'checkbox') {\n      opts.FT = 'Btn';\n    } else if (type === 'combo') {\n      opts.FT = 'Ch';\n      opts.combo = true;\n    } else if (type === 'list') {\n      opts.FT = 'Ch';\n    } else {\n      throw new Error(`Invalid form annotation type '${type}'`);\n    }\n    return opts;\n  },\n\n  _resolveFormat(opts) {\n    const f = opts.format;\n    if (f && f.type) {\n      let fnKeystroke;\n      let fnFormat;\n      let params = '';\n      if (FORMAT_SPECIAL[f.type] !== undefined) {\n        fnKeystroke = `AFSpecial_Keystroke`;\n        fnFormat = `AFSpecial_Format`;\n        params = FORMAT_SPECIAL[f.type];\n      } else {\n        let format = f.type.charAt(0).toUpperCase() + f.type.slice(1);\n        fnKeystroke = `AF${format}_Keystroke`;\n        fnFormat = `AF${format}_Format`;\n\n        if (f.type === 'date') {\n          fnKeystroke += 'Ex';\n          params = String(f.param);\n        } else if (f.type === 'time') {\n          params = String(f.param);\n        } else if (f.type === 'number') {\n          let p = Object.assign({}, FORMAT_DEFAULT.number, f);\n          params = String(\n            [\n              String(p.nDec),\n              p.sepComma ? '0' : '1',\n              '\"' + p.negStyle + '\"',\n              'null',\n              '\"' + p.currency + '\"',\n              String(p.currencyPrepend),\n            ].join(','),\n          );\n        } else if (f.type === 'percent') {\n          let p = Object.assign({}, FORMAT_DEFAULT.percent, f);\n          params = String([String(p.nDec), p.sepComma ? '0' : '1'].join(','));\n        }\n      }\n      opts.AA = opts.AA ? opts.AA : {};\n      opts.AA.K = {\n        S: 'JavaScript',\n        JS: new String(`${fnKeystroke}(${params});`),\n      };\n      opts.AA.F = {\n        S: 'JavaScript',\n        JS: new String(`${fnFormat}(${params});`),\n      };\n    }\n    delete opts.format;\n    return opts;\n  },\n\n  _resolveColors(opts) {\n    let color = this._normalizeColor(opts.backgroundColor);\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n      opts.MK.BG = color;\n    }\n    color = this._normalizeColor(opts.borderColor);\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n      opts.MK.BC = color;\n    }\n    delete opts.backgroundColor;\n    delete opts.borderColor;\n    return opts;\n  },\n\n  _resolveFlags(options) {\n    let result = 0;\n    Object.keys(options).forEach((key) => {\n      if (FIELD_FLAGS[key]) {\n        if (options[key]) {\n          result |= FIELD_FLAGS[key];\n        }\n        delete options[key];\n      }\n    });\n    if (result !== 0) {\n      options.Ff = options.Ff ? options.Ff : 0;\n      options.Ff |= result;\n    }\n    return options;\n  },\n\n  _resolveJustify(options) {\n    let result = 0;\n    if (options.align !== undefined) {\n      if (typeof FIELD_JUSTIFY[options.align] === 'number') {\n        result = FIELD_JUSTIFY[options.align];\n      }\n      delete options.align;\n    }\n    if (result !== 0) {\n      options.Q = result; // default\n    }\n    return options;\n  },\n\n  _resolveFont(options) {\n    // add current font to document-level AcroForm dict if necessary\n    if (this._acroform.fonts[this._font.id] == null) {\n      this._acroform.fonts[this._font.id] = this._font.ref();\n    }\n\n    // add current font to field's resource dict (RD) if not the default acroform font\n    if (this._acroform.defaultFont !== this._font.name) {\n      options.DR = { Font: {} };\n\n      // Get the fontSize option. If not set use auto sizing\n      const fontSize = options.fontSize || 0;\n\n      options.DR.Font[this._font.id] = this._font.ref();\n      options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);\n    }\n    return options;\n  },\n\n  _resolveStrings(options) {\n    let select = [];\n    function appendChoices(a) {\n      if (Array.isArray(a)) {\n        for (let idx = 0; idx < a.length; idx++) {\n          if (typeof a[idx] === 'string') {\n            select.push(new String(a[idx]));\n          } else {\n            select.push(a[idx]);\n          }\n        }\n      }\n    }\n    appendChoices(options.Opt);\n    if (options.select) {\n      appendChoices(options.select);\n      delete options.select;\n    }\n    if (select.length) {\n      options.Opt = select;\n    }\n\n    Object.keys(VALUE_MAP).forEach((key) => {\n      if (options[key] !== undefined) {\n        options[VALUE_MAP[key]] = options[key];\n        delete options[key];\n      }\n    });\n    ['V', 'DV'].forEach((key) => {\n      if (typeof options[key] === 'string') {\n        options[key] = new String(options[key]);\n      }\n    });\n\n    if (options.MK && options.MK.CA) {\n      options.MK.CA = new String(options.MK.CA);\n    }\n    if (options.label) {\n      options.MK = options.MK ? options.MK : {};\n      options.MK.CA = new String(options.label);\n      delete options.label;\n    }\n    return options;\n  },\n};\n","import fs from 'fs';\r\nimport CryptoJS from 'crypto-js';\r\n\r\nexport default {\r\n  /**\r\n   * Embed contents of `src` in PDF\r\n   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file\r\n   * @param {object} options\r\n   *  * options.name: filename to be shown in PDF, will use `src` if none set\r\n   *  * options.type: filetype to be shown in PDF\r\n   *  * options.description: description to be shown in PDF\r\n   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations\r\n   *  * options.creationDate: override creation date\r\n   *  * options.modifiedDate: override modified date\r\n   *  * options.relationship: Relationship between the PDF document and its attached file. Can be 'Alternative', 'Data', 'Source', 'Supplement' or 'Unspecified'.\r\n   * @returns filespec reference\r\n   */\r\n  file(src, options = {}) {\r\n    options.name = options.name || src;\r\n    options.relationship = options.relationship || 'Unspecified';\r\n\r\n    const refBody = {\r\n      Type: 'EmbeddedFile',\r\n      Params: {},\r\n    };\r\n    let data;\r\n\r\n    if (!src) {\r\n      throw new Error('No src specified');\r\n    }\r\n    if (Buffer.isBuffer(src)) {\r\n      data = src;\r\n    } else if (src instanceof ArrayBuffer) {\r\n      data = Buffer.from(new Uint8Array(src));\r\n    } else {\r\n      const match = /^data:(.*?);base64,(.*)$/.exec(src);\r\n      if (match) {\r\n        if (match[1]) {\r\n          refBody.Subtype = match[1].replace('/', '#2F');\r\n        }\r\n        data = Buffer.from(match[2], 'base64');\r\n      } else {\r\n        data = fs.readFileSync(src);\r\n        if (!data) {\r\n          throw new Error(`Could not read contents of file at filepath ${src}`);\r\n        }\r\n\r\n        // update CreationDate and ModDate\r\n        const { birthtime, ctime } = fs.statSync(src);\r\n        refBody.Params.CreationDate = birthtime;\r\n        refBody.Params.ModDate = ctime;\r\n      }\r\n    }\r\n\r\n    // override creation date and modified date\r\n    if (options.creationDate instanceof Date) {\r\n      refBody.Params.CreationDate = options.creationDate;\r\n    }\r\n    if (options.modifiedDate instanceof Date) {\r\n      refBody.Params.ModDate = options.modifiedDate;\r\n    }\r\n    // add optional subtype\r\n    if (options.type) {\r\n      refBody.Subtype = options.type.replace('/', '#2F');\r\n    }\r\n\r\n    // add checksum and size information\r\n    const checksum = CryptoJS.MD5(\r\n      CryptoJS.lib.WordArray.create(new Uint8Array(data)),\r\n    );\r\n    refBody.Params.CheckSum = new String(checksum);\r\n    refBody.Params.Size = data.byteLength;\r\n\r\n    // save some space when embedding the same file again\r\n    // if a file with the same name and metadata exists, reuse its reference\r\n    let ref;\r\n    if (!this._fileRegistry) this._fileRegistry = {};\r\n    let file = this._fileRegistry[options.name];\r\n    if (file && isEqual(refBody, file)) {\r\n      ref = file.ref;\r\n    } else {\r\n      ref = this.ref(refBody);\r\n      ref.end(data);\r\n\r\n      this._fileRegistry[options.name] = { ...refBody, ref };\r\n    }\r\n    // add filespec for embedded file\r\n    const fileSpecBody = {\r\n      Type: 'Filespec',\r\n      AFRelationship: options.relationship,\r\n      F: new String(options.name),\r\n      EF: { F: ref },\r\n      UF: new String(options.name),\r\n    };\r\n    if (options.description) {\r\n      fileSpecBody.Desc = new String(options.description);\r\n    }\r\n    const filespec = this.ref(fileSpecBody);\r\n    filespec.end();\r\n\r\n    if (!options.hidden) {\r\n      this.addNamedEmbeddedFile(options.name, filespec);\r\n    }\r\n\r\n    // Add file to the catalogue to be PDF/A3 compliant\r\n    if (this._root.data.AF) {\r\n      this._root.data.AF.push(filespec);\r\n    } else {\r\n      this._root.data.AF = [filespec];\r\n    }\r\n\r\n    return filespec;\r\n  },\r\n};\r\n\r\n/** check two embedded file metadata objects for equality */\r\nfunction isEqual(a, b) {\r\n  return (\r\n    a.Subtype === b.Subtype &&\r\n    a.Params.CheckSum.toString() === b.Params.CheckSum.toString() &&\r\n    a.Params.Size === b.Params.Size &&\r\n    a.Params.CreationDate.getTime() === b.Params.CreationDate.getTime() &&\r\n    ((a.Params.ModDate === undefined && b.Params.ModDate === undefined) ||\r\n      a.Params.ModDate.getTime() === b.Params.ModDate.getTime())\r\n  );\r\n}\r\n","import fs from 'fs';\n\nexport default {\n  initPDFA(pSubset) {\n    if (pSubset.charAt(pSubset.length - 3) === '-') {\n      this.subset_conformance = pSubset\n        .charAt(pSubset.length - 1)\n        .toUpperCase();\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));\n    } else {\n      // Default to Basic conformance when user doesn't specify\n      this.subset_conformance = 'B';\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));\n    }\n  },\n\n  endSubset() {\n    this._addPdfaMetadata();\n    this._addColorOutputIntent();\n  },\n\n  _addColorOutputIntent() {\n    const iccProfile = fs.readFileSync(\n      `${__dirname}/data/sRGB_IEC61966_2_1.icc`,\n    );\n\n    const colorProfileRef = this.ref({\n      Length: iccProfile.length,\n      N: 3,\n    });\n    colorProfileRef.write(iccProfile);\n    colorProfileRef.end();\n\n    const intentRef = this.ref({\n      Type: 'OutputIntent',\n      S: 'GTS_PDFA1',\n      Info: new String('sRGB IEC61966-2.1'),\n      OutputConditionIdentifier: new String('sRGB IEC61966-2.1'),\n      DestOutputProfile: colorProfileRef,\n    });\n    intentRef.end();\n\n    this._root.data.OutputIntents = [intentRef];\n  },\n\n  _getPdfaid() {\n    return `\n        <rdf:Description xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\" rdf:about=\"\">\n            <pdfaid:part>${this.subset}</pdfaid:part>\n            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>\n        </rdf:Description>\n        `;\n  },\n\n  _addPdfaMetadata() {\n    this.appendXML(this._getPdfaid());\n  },\n};\n","export default {\n  initPDFUA() {\n    this.subset = 1;\n  },\n\n  endSubset() {\n    this._addPdfuaMetadata();\n  },\n\n  _addPdfuaMetadata() {\n    this.appendXML(this._getPdfuaid());\n  },\n\n  _getPdfuaid() {\n    return `\n        <rdf:Description xmlns:pdfuaid=\"http://www.aiim.org/pdfua/ns/id/\" rdf:about=\"\">\n            <pdfuaid:part>${this.subset}</pdfuaid:part>\n        </rdf:Description>\n        `;\n  },\n};\n","import PDFA from './pdfa';\nimport PDFUA from './pdfua';\n\nexport default {\n  _importSubset(subset) {\n    Object.assign(this, subset);\n  },\n\n  initSubset(options) {\n    switch (options.subset) {\n      case 'PDF/A-1':\n      case 'PDF/A-1a':\n      case 'PDF/A-1b':\n      case 'PDF/A-2':\n      case 'PDF/A-2a':\n      case 'PDF/A-2b':\n      case 'PDF/A-3':\n      case 'PDF/A-3a':\n      case 'PDF/A-3b':\n        this._importSubset(PDFA);\n        this.initPDFA(options.subset);\n        break;\n      case 'PDF/UA':\n        this._importSubset(PDFUA);\n        this.initPDFUA();\n        break;\n    }\n  },\n};\n","/**\r\n * @template T\r\n * @typedef {function(number): T} Dynamic<T | undefined>\r\n */\r\n\r\n/**\r\n * @typedef {Object} Font\r\n * @property {PDFFontSource} [src]\r\n * The name of the font\r\n *\r\n * Defaults to the current document font source `doc._fontSrc`\r\n * @property {string} [family]\r\n * The font family of the font\r\n *\r\n * Defaults to the current document font family `doc._fontFamily`\r\n * @property {Size} [size]\r\n * The size of the font\r\n *\r\n * Defaults to the current document font size `doc._fontSize`\r\n */\r\n\r\n/**\r\n * Measurement of how wide something is, false means 0 and true means 1\r\n *\r\n * @typedef {Size | boolean} Wideness\r\n */\r\n\r\n/**\r\n * The value of the text of a cell\r\n * @typedef {string | null | undefined} TableCellText\r\n */\r\n\r\n/** @typedef {Object} TableCellStyle\r\n *\r\n * @property {TableCellText} [text]\r\n * The text of the table cell\r\n * @property {number} [rowSpan]\r\n * Number of rows the cell spans.\r\n *\r\n * Defaults to `1`.\r\n * @property {number} [colSpan]\r\n * Number of columns the cell spans.\r\n *\r\n * Defaults to `1`.\r\n * @property {SideDefinition<Wideness>} [padding]\r\n * Controls the padding of the cell text\r\n *\r\n * Defaults to `0.25em`\r\n * @property {SideDefinition<Wideness>} [border]\r\n * Controls the thickness of the cells borders.\r\n *\r\n * Defaults to `[1, 1, 1, 1]`.\r\n * @property {SideDefinition<PDFColor>} [borderColor]\r\n * Color of the border on each side of the cell.\r\n *\r\n * Defaults to the border color defined by the given table layout, or `black` on all sides.\r\n * @property {Font} [font]\r\n * Font options for the cell\r\n *\r\n * Defaults to the documents current font\r\n * @property {PDFColor} [backgroundColor]\r\n * Set the background color of the cell\r\n *\r\n * Defaults to transparent\r\n * @property {'center' | ExpandedAlign} [align]\r\n * Sets the text alignment of the cells text\r\n *\r\n * Defaults to `{x: 'left', y: 'top'}`\r\n * @property {Size} [textStroke]\r\n * Sets the text stroke width of the cells text\r\n *\r\n * Defaults to `0`\r\n * @property {PDFColor} [textStrokeColor]\r\n * Sets the text stroke color of the cells text\r\n *\r\n * Defaults to `black`\r\n * @property {PDFColor} [textColor]\r\n * Sets the text color of the cells text\r\n *\r\n * Defaults to `black`\r\n * @property {'TH' | 'TD'} [type]\r\n * Sets the cell type (for accessibility)\r\n *\r\n * Defaults to `TD`\r\n * @property {Object} [textOptions]\r\n * Sets any advanced text options passed into the cell renderer\r\n *\r\n * Same as the options you pass to `doc.text()`\r\n *\r\n * Will override any defaults set by the cell if set\r\n * @property {string} [title]\r\n * Sets the accessible title for the cell\r\n * @property {'Column' | 'Row' | 'Both'} [scope]\r\n * Sets the accessible scope for the cell\r\n * @property {string} [id]\r\n * Sets the accessible id for the cell\r\n *\r\n * Defaults to `<tableId>-<rowIndex>-<colIndex>`\r\n * @property {boolean} [debug]\r\n * Whether to show the debug lines for the cell\r\n *\r\n * Defaults to `false`\r\n */\r\n/** @typedef {TableCellText | TableCellStyle} TableCell **/\r\n\r\n/**\r\n * The width of the column\r\n *\r\n * - `*` distributes equally, filling the whole available space\r\n * - `%` computes the proportion of the max size\r\n *\r\n * Defaults to `*`\r\n * @typedef {Size | '*'} ColumnWidth\r\n */\r\n\r\n/**\r\n * @typedef {Object} ColumnStyle\r\n * @extends TableCellStyle\r\n *\r\n * @property {ColumnWidth} [width]\r\n * @property {Size} [minWidth]\r\n * The minimum width of the column\r\n *\r\n * Defaults to `0`\r\n * @property {Size} [maxWidth]\r\n * The maximum width of the column\r\n *\r\n * Defaults to `undefined` meaning no max\r\n */\r\n/** @typedef {ColumnStyle | ColumnWidth} Column **/\r\n\r\n/**\r\n * @typedef {Object} NormalizedColumnStyle\r\n * @extends ColumnStyle\r\n *\r\n * @property {number | '*'} width\r\n * @property {number} minWidth\r\n * @property {number} maxWidth\r\n */\r\n\r\n/**\r\n * The height of the row\r\n *\r\n * - A fixed value sets an absolute height for every row.\r\n * - `auto` sets the height based on the text.\r\n *\r\n * `%` values are based on page content height\r\n *\r\n * Defaults to `auto`\r\n * @typedef {Size | 'auto'} RowHeight\r\n */\r\n\r\n/**\r\n * @typedef {Object} RowStyle\r\n * @extends TableCellStyle\r\n *\r\n * @property {RowHeight} [height]\r\n * @property {Size} [minHeight]\r\n * The minimum height of the row\r\n *\r\n * `%` values are based on page content height\r\n *\r\n * Defaults to `0`\r\n * @property {Size} [maxHeight]\r\n * The maximum height of the row\r\n *\r\n * `%` values are based on page content height\r\n *\r\n * Defaults to `undefined` meaning no max\r\n */\r\n/** @typedef {RowStyle | RowHeight} Row **/\r\n\r\n/**\r\n * @typedef {Object} NormalizedRowStyle\r\n * @extends RowStyle\r\n *\r\n * @property {number | 'auto'} height\r\n * @property {number} minHeight\r\n * @property {number} maxHeight\r\n */\r\n\r\n/** @typedef {'left' | 'center' | 'right' | 'justify'} AlignX **/\r\n/** @typedef {'top' | 'center' | 'bottom'} AlignY **/\r\n/**\r\n * @typedef {Object} ExpandedAlign\r\n * @property {AlignX} [x]\r\n * @property {AlignY} [y]\r\n */\r\n\r\n/**\r\n * @typedef {Object} DefaultTableCellStyle\r\n *\r\n * @extends ColumnStyle\r\n * @extends RowStyle\r\n * @extends TableCellStyle\r\n */\r\n/** @typedef {TableCellText | DefaultTableCellStyle} DefaultTableCell **/\r\n\r\n/**\r\n * @typedef {Object} NormalizedDefaultTableCellStyle\r\n *\r\n * @extends NormalizedColumnStyle\r\n * @extends NormalizedRowStyle\r\n * @extends TableCellStyle\r\n */\r\n\r\n/**\r\n * @typedef {Object} NormalizedTableCellStyle\r\n *\r\n * @extends NormalizedColumnStyle\r\n * @extends NormalizedRowStyle\r\n * @extends TableCellStyle\r\n *\r\n * @property {number} rowIndex\r\n * @property {number} rowSpan\r\n * @property {number} colIndex\r\n * @property {number} colSpan\r\n *\r\n * @property {string} text\r\n * @property {Font} font\r\n * @property {boolean} customFont\r\n * @property {ExpandedSideDefinition<number>} padding\r\n * @property {ExpandedSideDefinition<number>} border\r\n * @property {ExpandedSideDefinition<PDFColor>} borderColor\r\n * @property {ExpandedAlign} align\r\n * @property {number} textStroke\r\n * @property {PDFColor} textStrokeColor\r\n * @property {PDFColor} textColor\r\n * @property {number} minWidth\r\n * @property {number} maxWidth\r\n * @property {number} minHeight\r\n * @property {number} maxHeight\r\n * @property {Object} textOptions\r\n */\r\n\r\n/**\r\n * @typedef {Object} SizedNormalizedTableCellStyle\r\n *\r\n * @extends {NormalizedTableCellStyle}\r\n *\r\n * @property {number} x\r\n * @property {number} y\r\n * @property {number} textX\r\n * @property {number} textY\r\n * @property {number} width\r\n * @property {number} height\r\n * @property {number} textAllocatedWidth\r\n * @property {number} textAllocatedHeight\r\n * @property {{x: number, y: number, width: number, height: number}} textBounds\r\n */\r\n\r\n/**\r\n * @typedef {Object} Table\r\n *\r\n * @property {Position} [position]\r\n * The position of the table\r\n *\r\n * Defaults to the current document position `{x: doc.x, y: doc.y}`\r\n * @property {Size} [maxWidth]\r\n * The maximum width the table can expand to\r\n *\r\n * Defaults to the remaining content width (offset from the tables position)\r\n * @property {Column | Column[] | Dynamic<Column>} [columnStyles]\r\n * Column definitions of the table.\r\n * - A fixed value sets the config for every column\r\n * - Use an array or a callback function to control the column config for each column individually.\r\n *\r\n * Defaults to `auto`\r\n * @property {Row | Row[] | Dynamic<Row>} [rowStyles]\r\n * Row definitions of the table.\r\n * - A fixed value sets the config for every column\r\n * - Use an array or a callback function to control the row config of each row individually.\r\n *\r\n * The given values are ignored for rows whose text is higher.\r\n *\r\n * Defaults to `*`.\r\n * @property {DefaultTableCell} [defaultStyle]\r\n * Defaults to apply to every cell\r\n * @property {Iterable<Iterable<TableCell>>} [data]\r\n * Two-dimensional iterable that defines the table's data.\r\n *\r\n * With the first dimension being the row, and the second being the column\r\n *\r\n * If provided the table will be automatically ended after the last row has been written,\r\n * Otherwise it is up to the user to call `table.end()` or `table.row([], true)`\r\n * @property {PDFStructureElement} [structParent]\r\n * The parent structure to mount to\r\n *\r\n * This will cause the entire table to be enclosed in a Table structure\r\n * with TR and TD/TH for cells\r\n * @property {string} [id]\r\n * Sets the accessible id for the table\r\n *\r\n * Defaults to `table-<number>`\r\n * @property {boolean} [debug]\r\n * Whether to show the debug lines for all the cells\r\n *\r\n * Defaults to `false`\r\n */\r\n\r\n/**\r\n * Fields exclusive to row styles\r\n * @type {string[]}\r\n */\r\nexport const ROW_FIELDS = ['height', 'minHeight', 'maxHeight'];\r\n/**\r\n * Fields exclusive to column styles\r\n * @type {string[]}\r\n */\r\nexport const COLUMN_FIELDS = ['width', 'minWidth', 'maxWidth'];\r\n\r\nexport function memoize(fn, maxSize) {\r\n  const cache = new Map();\r\n  return function (...args) {\r\n    const key = args[0];\r\n    if (!cache.has(key)) {\r\n      cache.set(key, fn(...args));\r\n      if (cache.size > maxSize) cache.delete(cache.keys().next());\r\n    }\r\n    return cache.get(key);\r\n  };\r\n}\r\n\r\n/**\r\n * Simple object check.\r\n * @param item\r\n * @returns {boolean}\r\n */\r\nfunction isObject(item) {\r\n  return item && typeof item === 'object' && !Array.isArray(item);\r\n}\r\n\r\n/**\r\n * Deep merge two objects.\r\n *\r\n * @template T\r\n * @param {T} target\r\n * @param sources\r\n * @returns {T}\r\n */\r\nexport function deepMerge(target, ...sources) {\r\n  if (!isObject(target)) return target;\r\n  target = deepClone(target);\r\n\r\n  for (const source of sources) {\r\n    if (isObject(source)) {\r\n      for (const key in source) {\r\n        if (isObject(source[key])) {\r\n          if (!(key in target)) target[key] = {};\r\n          target[key] = deepMerge(target[key], source[key]);\r\n        } else if (source[key] !== undefined) {\r\n          target[key] = deepClone(source[key]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction deepClone(obj) {\r\n  let result = obj;\r\n  if (obj && typeof obj == 'object') {\r\n    result = Array.isArray(obj) ? [] : {};\r\n    for (const key in obj) result[key] = deepClone(obj[key]);\r\n  }\r\n  return result;\r\n}\r\n","import { COLUMN_FIELDS, deepMerge, ROW_FIELDS } from './utils';\nimport { normalizeSides } from '../utils';\n\n/**\n * Normalize the row config\n * @note The context here is the cell not the document\n *\n * @param {DefaultTableCell} [defaultStyleInternal]\n * @returns {{\n *  defaultStyle: TableCellStyle,\n *  defaultRowStyle: RowStyle,\n *  defaultColStyle: ColumnStyle\n * }}\n * @private\n */\nexport function normalizedDefaultStyle(defaultStyleInternal) {\n  let defaultStyle = defaultStyleInternal;\n  // Force object form\n  if (typeof defaultStyle !== 'object') defaultStyle = { text: defaultStyle };\n\n  const defaultRowStyle = Object.fromEntries(\n    Object.entries(defaultStyle).filter(([k]) => ROW_FIELDS.includes(k)),\n  );\n  const defaultColStyle = Object.fromEntries(\n    Object.entries(defaultStyle).filter(([k]) => COLUMN_FIELDS.includes(k)),\n  );\n\n  defaultStyle.padding = normalizeSides(defaultStyle.padding);\n  defaultStyle.border = normalizeSides(defaultStyle.border);\n  defaultStyle.borderColor = normalizeSides(defaultStyle.borderColor);\n  defaultStyle.align = normalizeAlignment(defaultStyle.align);\n\n  return { defaultStyle, defaultRowStyle, defaultColStyle };\n}\n\n/**\n * Normalize the row config\n *\n * @note The context here is the cell not the document\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {RowStyle} defaultRowStyle\n * @param {Dynamic<Row>} rowStyleInternal\n * @param {number} i The target row\n * @returns {NormalizedRowStyle}\n * @private\n */\nexport function normalizedRowStyle(defaultRowStyle, rowStyleInternal, i) {\n  let rowStyle = rowStyleInternal(i);\n  // Force object form\n  if (rowStyle == null || typeof rowStyle !== 'object') {\n    rowStyle = { height: rowStyle };\n  }\n  // Normalize\n  rowStyle.padding = normalizeSides(rowStyle.padding);\n  rowStyle.border = normalizeSides(rowStyle.border);\n  rowStyle.borderColor = normalizeSides(rowStyle.borderColor);\n  rowStyle.align = normalizeAlignment(rowStyle.align);\n\n  // Merge defaults\n  rowStyle = deepMerge(defaultRowStyle, rowStyle);\n\n  const document = this.document;\n  const page = document.page;\n  const contentHeight = page.contentHeight;\n\n  if (rowStyle.height == null || rowStyle.height === 'auto') {\n    rowStyle.height = 'auto';\n  } else {\n    rowStyle.height = document.sizeToPoint(\n      rowStyle.height,\n      0,\n      page,\n      contentHeight,\n    );\n  }\n  rowStyle.minHeight = document.sizeToPoint(\n    rowStyle.minHeight,\n    0,\n    page,\n    contentHeight,\n  );\n  rowStyle.maxHeight = document.sizeToPoint(\n    rowStyle.maxHeight,\n    0,\n    page,\n    contentHeight,\n  );\n\n  return rowStyle;\n}\n\n/**\n * Normalize the column config\n *\n * @note The context here is the document not the cell\n *\n * @param {ColumnStyle} defaultColStyle\n * @param {Dynamic<Column>} colStyleInternal\n * @param {number} i - The target column\n * @returns {NormalizedColumnStyle}\n * @private\n */\nexport function normalizedColumnStyle(defaultColStyle, colStyleInternal, i) {\n  let colStyle = colStyleInternal(i);\n  // Force object form\n  if (colStyle == null || typeof colStyle !== 'object') {\n    colStyle = { width: colStyle };\n  }\n  // Normalize\n  colStyle.padding = normalizeSides(colStyle.padding);\n  colStyle.border = normalizeSides(colStyle.border);\n  colStyle.borderColor = normalizeSides(colStyle.borderColor);\n  colStyle.align = normalizeAlignment(colStyle.align);\n\n  // Merge defaults\n  colStyle = deepMerge(defaultColStyle, colStyle);\n\n  if (colStyle.width == null || colStyle.width === '*') {\n    colStyle.width = '*';\n  } else {\n    colStyle.width = this.document.sizeToPoint(\n      colStyle.width,\n      0,\n      this.document.page,\n      this._maxWidth, // Use table width here for percentage scaling\n    );\n  }\n  colStyle.minWidth = this.document.sizeToPoint(\n    colStyle.minWidth,\n    0,\n    this.document.page,\n    this._maxWidth, // Use table width here for percentage scaling\n  );\n  colStyle.maxWidth = this.document.sizeToPoint(\n    colStyle.maxWidth,\n    0,\n    this.document.page,\n    this._maxWidth, // Use table width here for percentage scaling\n  );\n\n  return colStyle;\n}\n\nexport function normalizeAlignment(align) {\n  return align == null || typeof align === 'string'\n    ? { x: align, y: align }\n    : align;\n}\n","import { deepMerge, memoize } from './utils';\nimport {\n  normalizeAlignment,\n  normalizedColumnStyle,\n  normalizedDefaultStyle,\n  normalizedRowStyle,\n} from './style';\nimport { normalizeSides } from '../utils';\n\n/**\n * Normalize a table\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @private\n */\nexport function normalizeTable() {\n  const doc = this.document;\n  const opts = this.opts;\n\n  // Normalize config\n  let index = doc._tableIndex++;\n  this._id = new String(opts.id ?? `table-${index}`);\n  this._position = {\n    x: doc.sizeToPoint(opts.position?.x, doc.x),\n    y: doc.sizeToPoint(opts.position?.y, doc.y),\n  };\n  this._maxWidth = doc.sizeToPoint(\n    opts.maxWidth,\n    doc.page.width - doc.page.margins.right - this._position.x,\n  );\n\n  const { defaultStyle, defaultColStyle, defaultRowStyle } =\n    normalizedDefaultStyle(opts.defaultStyle);\n  this._defaultStyle = defaultStyle;\n\n  let colStyle;\n  if (opts.columnStyles) {\n    if (Array.isArray(opts.columnStyles)) {\n      colStyle = (i) => opts.columnStyles[i];\n    } else if (typeof opts.columnStyles === 'function') {\n      // memoize all columns\n      colStyle = memoize((i) => opts.columnStyles(i), Infinity);\n    } else if (typeof opts.columnStyles === 'object') {\n      colStyle = () => opts.columnStyles;\n    }\n  }\n  if (!colStyle) colStyle = () => ({});\n  this._colStyle = normalizedColumnStyle.bind(this, defaultColStyle, colStyle);\n\n  let rowStyle;\n  if (opts.rowStyles) {\n    if (Array.isArray(opts.rowStyles)) {\n      rowStyle = (i) => opts.rowStyles[i];\n    } else if (typeof opts.rowStyles === 'function') {\n      // Memoize the row configs in a rolling buffer\n      rowStyle = memoize((i) => opts.rowStyles(i), 10);\n    } else if (typeof opts.rowStyles === 'object') {\n      rowStyle = () => opts.rowStyles;\n    }\n  }\n  if (!rowStyle) rowStyle = () => ({});\n  this._rowStyle = normalizedRowStyle.bind(this, defaultRowStyle, rowStyle);\n}\n\n/**\n * Convert text into a string\n * - null and undefined are preserved (as they will be ignored)\n * - everything else is run through `String()`\n *\n * @param {*} text\n * @returns {string}\n * @private\n */\nexport function normalizeText(text) {\n  // Parse out text\n  if (text != null) text = `${text}`;\n  return text;\n}\n\n/**\n * Normalize a cell config\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {TableCellStyle} cell - The cell to mutate\n * @param {number} rowIndex - The cells row\n * @param {number} colIndex - The cells column\n * @returns {NormalizedTableCellStyle}\n * @private\n */\nexport function normalizeCell(cell, rowIndex, colIndex) {\n  const colStyle = this._colStyle(colIndex);\n  let rowStyle = this._rowStyle(rowIndex);\n\n  const font = deepMerge({}, colStyle.font, rowStyle.font, cell.font);\n  const customFont = Object.values(font).filter((v) => v != null).length > 0;\n  const doc = this.document;\n\n  // Initialize cell context\n  const rollbackFont = doc._fontSource;\n  const rollbackFontSize = doc._fontSize;\n  const rollbackFontFamily = doc._fontFamily;\n  if (customFont) {\n    if (font.src) doc.font(font.src, font.family);\n    if (font.size) doc.fontSize(font.size);\n\n    // Refetch rowStyle to reflect font changes\n    rowStyle = this._rowStyle(rowIndex);\n  }\n\n  cell.padding = normalizeSides(cell.padding);\n  cell.border = normalizeSides(cell.border);\n  cell.borderColor = normalizeSides(cell.borderColor);\n\n  // Cell takes highest priority, then row, then column, then defaultConfig\n  const config = deepMerge(this._defaultStyle, colStyle, rowStyle, cell);\n  config.rowIndex = rowIndex;\n  config.colIndex = colIndex;\n  config.font = font ?? {};\n  config.customFont = customFont;\n\n  // Normalize config\n  config.text = normalizeText(config.text);\n  config.rowSpan = config.rowSpan ?? 1;\n  config.colSpan = config.colSpan ?? 1;\n  config.padding = normalizeSides(config.padding, '0.25em', (x) =>\n    doc.sizeToPoint(x, '0.25em'),\n  );\n  config.border = normalizeSides(config.border, 1, (x) =>\n    doc.sizeToPoint(x, 1),\n  );\n  config.borderColor = normalizeSides(\n    config.borderColor,\n    'black',\n    (x) => x ?? 'black',\n  );\n  config.align = normalizeAlignment(config.align);\n  config.align.x = config.align.x ?? 'left';\n  config.align.y = config.align.y ?? 'top';\n  config.textStroke = doc.sizeToPoint(config.textStroke, 0);\n  config.textStrokeColor = config.textStrokeColor ?? 'black';\n  config.textColor = config.textColor ?? 'black';\n  config.textOptions = config.textOptions ?? {};\n\n  // Accessibility settings\n  config.id = new String(config.id ?? `${this._id}-${rowIndex}-${colIndex}`);\n  config.type = config.type?.toUpperCase() === 'TH' ? 'TH' : 'TD';\n  if (config.scope) {\n    config.scope = config.scope.toLowerCase();\n    if (config.scope === 'row') config.scope = 'Row';\n    else if (config.scope === 'both') config.scope = 'Both';\n    else if (config.scope === 'column') config.scope = 'Column';\n  }\n\n  if (typeof this.opts.debug === 'boolean') config.debug = this.opts.debug;\n\n  // Rollback font\n  if (customFont) doc.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n\n  return config;\n}\n\n/**\n * Normalize a row\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {TableCell[]} row\n * @param {number} rowIndex\n * @returns {NormalizedTableCellStyle[]}\n * @private\n */\nexport function normalizeRow(row, rowIndex) {\n  if (!this._cellClaim) this._cellClaim = new Set();\n\n  let colIndex = 0;\n  return row.map((cell) => {\n    // Ensure TableCell\n    if (cell == null || typeof cell !== 'object') cell = { text: cell };\n\n    // Find the starting column of the cell\n    // Skipping over the claimed cells\n    while (this._cellClaim.has(`${rowIndex},${colIndex}`)) {\n      colIndex++;\n    }\n\n    cell = normalizeCell.call(this, cell, rowIndex, colIndex);\n\n    // Claim any spanning cells\n    for (let i = 0; i < cell.rowSpan; i++) {\n      for (let j = 0; j < cell.colSpan; j++) {\n        this._cellClaim.add(`${rowIndex + i},${colIndex + j}`);\n      }\n    }\n\n    colIndex += cell.colSpan;\n    return cell;\n  });\n}\n","import { cosine, sine } from '../utils';\n\n/**\n * Compute the widths of the columns, ensuring to distribute the star widths\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {NormalizedTableCellStyle[]} row\n * @private\n */\nexport function ensure(row) {\n  // Width init\n  /** @type number[] **/\n  this._columnWidths = [];\n  ensureColumnWidths.call(\n    this,\n    row.reduce((a, cell) => a + cell.colSpan, 0),\n  );\n\n  // Height init\n  /** @type number[] **/\n  this._rowHeights = [];\n  /** @type number[] **/\n  this._rowYPos = [this._position.y];\n  /** @type {Set<NormalizedTableCellStyle>} **/\n  this._rowBuffer = new Set();\n}\n\n/**\n * Compute the widths of the columns, ensuring to distribute the star widths\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {number} numCols\n * @private\n */\nfunction ensureColumnWidths(numCols) {\n  // Compute the widths\n  let starColumnIndexes = [];\n  let starMinAcc = 0;\n  let unclaimedWidth = this._maxWidth;\n\n  for (let i = 0; i < numCols; i++) {\n    let col = this._colStyle(i);\n    if (col.width === '*') {\n      starColumnIndexes[i] = col;\n      starMinAcc += col.minWidth;\n    } else {\n      unclaimedWidth -= col.width;\n      this._columnWidths[i] = col.width;\n    }\n  }\n\n  let starColCount = starColumnIndexes.reduce((x) => x + 1, 0);\n\n  if (starMinAcc >= unclaimedWidth) {\n    // case 1 - there's no way to fit all columns within available width\n    // that's actually pretty bad situation with PDF as we have no horizontal scroll\n    starColumnIndexes.forEach((cell, i) => {\n      this._columnWidths[i] = cell.minWidth;\n    });\n  } else if (starColCount > 0) {\n    // Otherwise we distribute evenly factoring in the cell bounds\n    starColumnIndexes.forEach((col, i) => {\n      let starSize = unclaimedWidth / starColCount;\n      this._columnWidths[i] = Math.max(starSize, col.minWidth);\n      if (col.maxWidth > 0) {\n        this._columnWidths[i] = Math.min(this._columnWidths[i], col.maxWidth);\n      }\n      unclaimedWidth -= this._columnWidths[i];\n      starColCount--;\n    });\n  }\n\n  let tempX = this._position.x;\n  this._columnXPos = Array.from(this._columnWidths, (v) => {\n    const t = tempX;\n    tempX += v;\n    return t;\n  });\n}\n\n/**\n * Compute the dimensions of the cells\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {NormalizedTableCellStyle[]} row\n * @param {number} rowIndex\n * @returns {{newPage: boolean, toRender: SizedNormalizedTableCellStyle[]}}\n * @private\n */\nexport function measure(row, rowIndex) {\n  // ===================\n  // Add cells to buffer\n  // ===================\n  row.forEach((cell) => this._rowBuffer.add(cell));\n\n  if (rowIndex > 0) {\n    this._rowYPos[rowIndex] =\n      this._rowYPos[rowIndex - 1] + this._rowHeights[rowIndex - 1];\n  }\n\n  const rowStyle = this._rowStyle(rowIndex);\n\n  // ========================================================\n  // Find any cells which are to finish rendering on this row\n  // ========================================================\n  /** @type {SizedNormalizedTableCellStyle[]} */\n  let toRender = [];\n  this._rowBuffer.forEach((cell) => {\n    if (cell.rowIndex + cell.rowSpan - 1 === rowIndex) {\n      toRender.push(measureCell.call(this, cell, rowStyle.height));\n      this._rowBuffer.delete(cell);\n    }\n  });\n\n  // =====================================================\n  // Find the shared height for the row based on the cells\n  // =====================================================\n  let rowHeight = rowStyle.height;\n  if (rowHeight === 'auto') {\n    // Compute remaining height on cells\n    rowHeight = toRender.reduce((acc, cell) => {\n      let minHeight =\n        cell.textBounds.height + cell.padding.top + cell.padding.bottom;\n      for (let i = 0; i < cell.rowSpan - 1; i++) {\n        minHeight -= this._rowHeights[cell.rowIndex + i];\n      }\n      return Math.max(acc, minHeight);\n    }, 0);\n  }\n\n  rowHeight = Math.max(rowHeight, rowStyle.minHeight);\n  if (rowStyle.maxHeight > 0) {\n    rowHeight = Math.min(rowHeight, rowStyle.maxHeight);\n  }\n  this._rowHeights[rowIndex] = rowHeight;\n\n  let newPage = false;\n  if (rowHeight > this.document.page.contentHeight) {\n    // We are unable to render this row on a single page, for now we log a warning and disable the newPage\n    console.warn(\n      new Error(\n        `Row ${rowIndex} requested more than the safe page height, row has been clamped`,\n      ).stack.slice(7),\n    );\n    this._rowHeights[rowIndex] =\n      this.document.page.maxY() - this._rowYPos[rowIndex];\n  } else if (this._rowYPos[rowIndex] + rowHeight >= this.document.page.maxY()) {\n    // If row is going to go over the safe page height then move it over to new page\n    this._rowYPos[rowIndex] = this.document.page.margins.top;\n    newPage = true;\n  }\n\n  // =====================================================\n  // Re-measure the cells using the know known height\n  // =====================================================\n  return {\n    newPage,\n    toRender: toRender.map((cell) => measureCell.call(this, cell, rowHeight)),\n  };\n}\n\n/**\n * Compute the dimensions of the cell and its text\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {NormalizedTableCellStyle} cell\n * @param {number | 'auto'} rowHeight\n * @returns {SizedNormalizedTableCellStyle}\n * @private\n */\nfunction measureCell(cell, rowHeight) {\n  // ====================\n  // Calculate cell width\n  // ====================\n  let cellWidth = 0;\n\n  // Traverse all the columns of the cell\n  for (let i = 0; i < cell.colSpan; i++) {\n    cellWidth += this._columnWidths[cell.colIndex + i];\n  }\n\n  // =====================\n  // Calculate cell height\n  // =====================\n  let cellHeight = rowHeight;\n  if (cellHeight === 'auto') {\n    // The cells height is effectively infinite\n    // (although we clamp it to the page content size)\n    cellHeight = this.document.page.contentHeight;\n  } else {\n    // Add all the spanning rows heights to the cell\n    for (let i = 0; i < cell.rowSpan - 1; i++) {\n      cellHeight += this._rowHeights[cell.rowIndex + i];\n    }\n  }\n\n  // Allocated text space\n  const textAllocatedWidth = cellWidth - cell.padding.left - cell.padding.right;\n\n  const textAllocatedHeight =\n    cellHeight - cell.padding.top - cell.padding.bottom;\n\n  // Compute the text bounds\n  const rotation = cell.textOptions.rotation ?? 0;\n  const { width: textMaxWidth, height: textMaxHeight } = computeBounds(\n    rotation,\n    textAllocatedWidth,\n    textAllocatedHeight,\n  );\n\n  const textOptions = {\n    // Alignment is handled internally\n    align: cell.align.x,\n    ellipsis: true, // Default make overflowing text ellipsis\n    stroke: cell.textStroke > 0,\n    fill: true, // To fix the stroke issue\n    width: textMaxWidth,\n    height: textMaxHeight,\n    rotation,\n    // Allow the user to define any custom fields\n    ...cell.textOptions,\n  };\n\n  // ========================\n  // Calculate text height\n  // ========================\n\n  // Compute rendered bounds of the text given the constraints of the cell\n  let textBounds = { x: 0, y: 0, width: 0, height: 0 };\n  if (cell.text) {\n    const rollbackFont = this.document._fontSource;\n    const rollbackFontSize = this.document._fontSize;\n    const rollbackFontFamily = this.document._fontFamily;\n    if (cell.font?.src) this.document.font(cell.font.src, cell.font?.family);\n    if (cell.font?.size) this.document.fontSize(cell.font.size);\n\n    // We first compute the un-rotated bounds so that we can calculate the width of the text\n    const unRotatedTextBounds = this.document.boundsOfString(cell.text, 0, 0, {\n      ...textOptions,\n      rotation: 0,\n    });\n    textOptions.width = unRotatedTextBounds.width;\n    textOptions.height = unRotatedTextBounds.height;\n\n    // Then compute the rendered bounds\n    textBounds = this.document.boundsOfString(cell.text, 0, 0, textOptions);\n\n    this.document.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n  }\n\n  return {\n    ...cell,\n    textOptions,\n    x: this._columnXPos[cell.colIndex],\n    y: this._rowYPos[cell.rowIndex],\n    textX: this._columnXPos[cell.colIndex] + cell.padding.left,\n    textY: this._rowYPos[cell.rowIndex] + cell.padding.top,\n    width: cellWidth,\n    height: cellHeight,\n    textAllocatedHeight,\n    textAllocatedWidth,\n    textBounds,\n  };\n}\n\n/**\n * Compute the horizon-locked bounding box of a rect\n *\n * @param {number} rotation\n * @param {number} allocWidth\n * @param {number} allocHeight\n *\n * @returns {{width: number, height: number}}\n */\nfunction computeBounds(rotation, allocWidth, allocHeight) {\n  let textMaxWidth, textMaxHeight;\n\n  // We use these a lot so pre-compute\n  const cos = cosine(rotation);\n  const sin = sine(rotation);\n\n  // <---------------allocWidth---------------->\n  // A════════════════════F════════════════════B\n  // ║                  ■■ ■                   ║\n  // ║                ■■   ■                   ║\n  // ║              ■■      ■                  ║\n  // ║            ■■        ■                  ║\n  // ║          ■■           ■                 ║\n  // ║        ■■             ■                 ║\n  // ║      ■■░░              ■                ║\n  // ║    ■■    ░              ■               ║\n  // ║  ■■   Θ   ░             ■               ║\n  // ║■■          ░             ■              ║\n  // E- - - - - - - - - - - - - ■ - - - - - - -║\n  // ║■                          ■             ║\n  // ║■                           ■            ║\n  // ║ ■                          ■            ║\n  // ║ ■                           ■           ║\n  // ║  ■                          ■           ║\n  // ║  ■                           ■          ║\n  // ║   ■                          ■          ║\n  // ║   ■                           ■         ║\n  // ║    ■                           ■        ║\n  // ║     ■                          ■        ║\n  // ║     ■                           ■       ║\n  // ║      ■                          ■       ║\n  // ║      ■                           ■      ║\n  // ║       ■                           ■     ║\n  // ║       ■                           ■     ║\n  // ║        ■                           ■    ║\n  // ║        ■                           ■    ║\n  // ║         ■                           ■   ║\n  // ║         ■                           ■   ║\n  // ║          ■                           ■  ║\n  // ║           ■                           ■ ║\n  // ║           ■                           ■ ║\n  // ║            ■                           ■║\n  // ║            ■                           ■║\n  // ║             ■                           G\n  // ║             ■                         ■■║\n  // ║              ■                      ■■  ║\n  // ║              ■                     ■    ║\n  // ║               ■                  ■■     ║\n  // ║                ■                ■       ║\n  // ║                ■              ■■        ║\n  // ║                 ■           ■■          ║\n  // ║                 ■          ■            ║\n  // ║                  ■       ■■             ║\n  // ║                  ■      ■               ║\n  // ║                   ■   ■■                ║\n  // ║                   ■ ■■                  ║\n  // D════════════════════H════════════════════C\n  //\n  // Given a rectangle ABCD with a fixed side AB of width allocWidth.\n  // Find the largest (by area) inscribed rectangle EFGH,\n  // where the angle Θ is equal to rotation (between 0-90 degrees)\n  //\n  // From above we can infer\n  // > AF = EF * cos(Θ)\n  // > FB = AB - AF\n  // > FB = FG * sin(Θ)\n  // Rearrange\n  // > FG = FB / sin(Θ)\n  // Substitute\n  // > FG = (AB - EF*cos(Θ)) / sin(Θ)\n  // Area of a rectangle\n  // > A = EF * FG\n  // Substitute\n  // > A = EF * (AB - EF*cos(Θ)) / sin(Θ)\n  // > dA/dEF = (AB - 2*EF*cos(Θ)) / sin(Θ)\n  // Find peak at dA/dEF = 0\n  // > 0 = (AB - 2*EF*cos(Θ)) / sin(Θ)\n  // > EF = AB / (2*cos(Θ))\n  // Substitute\n  // > FG = (AB - (AB*cos(Θ)) / (2*cos(Θ))) / sin(Θ)\n  // > FG = AB / (2*sin(Θ))\n  //\n  // Final outcome\n  // Length EF = AB / (2*cos(Θ))\n  // Length FG = AB / (2*sin(Θ))\n  if (rotation === 0 || rotation === 180) {\n    textMaxWidth = allocWidth;\n    textMaxHeight = allocHeight;\n  } else if (rotation === 90 || rotation === 270) {\n    textMaxWidth = allocHeight;\n    textMaxHeight = allocWidth;\n  } else if (rotation < 90 || (rotation > 180 && rotation < 270)) {\n    textMaxWidth = allocWidth / (2 * cos);\n    textMaxHeight = allocWidth / (2 * sin);\n  } else {\n    textMaxHeight = allocWidth / (2 * cos);\n    textMaxWidth = allocWidth / (2 * sin);\n  }\n\n  // If The bounding box of the text is beyond the allocHeight\n  // then we need to clamp it and recompute the bounds\n  // This time we are computing the sizes based on the outer box ABCD\n  const EF = sin * textMaxWidth;\n  const FG = cos * textMaxHeight;\n  if (EF + FG > allocHeight) {\n    // > AB = EF * cos(Θ) + FG * sin(Θ)\n    // > BC = BG + GC\n    // > BG = FG * cos(Θ)\n    // > GC = EF * sin(Θ)\n    // > BC = FG * cos(Θ) + EF * sin(Θ)\n    // > AB = EF * cos(Θ) + FG * sin(Θ)\n    // Substitution solve\n    // > EF = (AB*cos(Θ) - BC*sin(Θ)) / (cos^2(Θ)-sin^2(Θ))\n    // > FG = (BC*cos(Θ) - AB*sin(Θ)) / (cos^2(Θ)-sin^2(Θ))\n    const denominator = cos * cos - sin * sin;\n\n    if (rotation === 0 || rotation === 180) {\n      textMaxWidth = allocWidth;\n      textMaxHeight = allocHeight;\n    } else if (rotation === 90 || rotation === 270) {\n      textMaxWidth = allocHeight;\n      textMaxHeight = allocWidth;\n    } else if (rotation < 90 || (rotation > 180 && rotation < 270)) {\n      textMaxWidth = (allocWidth * cos - allocHeight * sin) / denominator;\n      textMaxHeight = (allocHeight * cos - allocWidth * sin) / denominator;\n    } else {\n      textMaxHeight = (allocWidth * cos - allocHeight * sin) / denominator;\n      textMaxWidth = (allocHeight * cos - allocWidth * sin) / denominator;\n    }\n  }\n\n  return { width: Math.abs(textMaxWidth), height: Math.abs(textMaxHeight) };\n}\n","import PDFStructureElement from '../structure_element';\nimport PDFDocument from '../document';\n\n/**\n * Add accessibility to a table\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @private\n */\nexport function accommodateTable() {\n  const structParent = this.opts.structParent;\n  if (structParent) {\n    this._tableStruct = this.document.struct('Table');\n    this._tableStruct.dictionary.data.ID = this._id;\n    if (structParent instanceof PDFStructureElement) {\n      structParent.add(this._tableStruct);\n    } else if (structParent instanceof PDFDocument) {\n      structParent.addStructure(this._tableStruct);\n    }\n    this._headerRowLookup = {};\n    this._headerColumnLookup = {};\n  }\n}\n\n/**\n * Cleanup accessibility on a table\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @private\n */\nexport function accommodateCleanup() {\n  if (this._tableStruct) this._tableStruct.end();\n}\n\n/**\n * Render a row with all its accessibility features\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {SizedNormalizedTableCellStyle[]} row\n * @param {number} rowIndex\n * @param {Function} renderCell\n * @private\n */\nexport function accessibleRow(row, rowIndex, renderCell) {\n  const rowStruct = this.document.struct('TR');\n  rowStruct.dictionary.data.ID = new String(`${this._id}-${rowIndex}`);\n  this._tableStruct.add(rowStruct);\n  row.forEach((cell) => renderCell(cell, rowStruct));\n  rowStruct.end();\n}\n\n/**\n * Render a cell with all its accessibility features\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {SizedNormalizedTableCellStyle} cell\n * @param {PDFStructureElement} rowStruct\n * @param {Function} callback\n * @private\n */\nexport function accessibleCell(cell, rowStruct, callback) {\n  const doc = this.document;\n\n  const cellStruct = doc.struct(cell.type, { title: cell.title });\n  cellStruct.dictionary.data.ID = cell.id;\n\n  rowStruct.add(cellStruct);\n\n  const padding = cell.padding;\n  const border = cell.border;\n  const attributes = {\n    O: 'Table',\n    Width: cell.width,\n    Height: cell.height,\n    Padding: [padding.top, padding.bottom, padding.left, padding.right],\n    RowSpan: cell.rowSpan > 1 ? cell.rowSpan : undefined,\n    ColSpan: cell.colSpan > 1 ? cell.colSpan : undefined,\n    BorderThickness: [border.top, border.bottom, border.left, border.right],\n  };\n\n  // Claim row Headers\n  if (cell.type === 'TH') {\n    if (cell.scope === 'Row' || cell.scope === 'Both') {\n      for (let i = 0; i < cell.rowSpan; i++) {\n        if (!this._headerRowLookup[cell.rowIndex + i]) {\n          this._headerRowLookup[cell.rowIndex + i] = [];\n        }\n        this._headerRowLookup[cell.rowIndex + i].push(cell.id);\n      }\n      attributes.Scope = cell.scope;\n    }\n    if (cell.scope === 'Column' || cell.scope === 'Both') {\n      for (let i = 0; i < cell.colSpan; i++) {\n        if (!this._headerColumnLookup[cell.colIndex + i]) {\n          this._headerColumnLookup[cell.colIndex + i] = [];\n        }\n        this._headerColumnLookup[cell.colIndex + i].push(cell.id);\n      }\n      attributes.Scope = cell.scope;\n    }\n  }\n\n  // Find any cells which are marked as headers for this cell\n  const Headers = new Set(\n    [\n      ...Array.from(\n        { length: cell.colSpan },\n        (_, i) => this._headerColumnLookup[cell.colIndex + i],\n      ).flat(),\n      ...Array.from(\n        { length: cell.rowSpan },\n        (_, i) => this._headerRowLookup[cell.rowIndex + i],\n      ).flat(),\n    ].filter(Boolean),\n  );\n  if (Headers.size) attributes.Headers = Array.from(Headers);\n\n  const normalizeColor = doc._normalizeColor;\n  if (cell.backgroundColor != null) {\n    attributes.BackgroundColor = normalizeColor(cell.backgroundColor);\n  }\n  const hasBorder = [border.top, border.bottom, border.left, border.right];\n  if (hasBorder.some((x) => x)) {\n    const borderColor = cell.borderColor;\n    attributes.BorderColor = [\n      hasBorder[0] ? normalizeColor(borderColor.top) : null,\n      hasBorder[1] ? normalizeColor(borderColor.bottom) : null,\n      hasBorder[2] ? normalizeColor(borderColor.left) : null,\n      hasBorder[3] ? normalizeColor(borderColor.right) : null,\n    ];\n  }\n\n  // Remove any undefined attributes\n  Object.keys(attributes).forEach(\n    (key) => attributes[key] === undefined && delete attributes[key],\n  );\n  cellStruct.dictionary.data.A = doc.ref(attributes);\n  cellStruct.add(callback);\n  cellStruct.end();\n  cellStruct.dictionary.data.A.end();\n}\n","import { accessibleCell, accessibleRow } from './accessibility';\n\n/**\n * Render a cell\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {SizedNormalizedTableCellStyle[]} row\n * @param {number} rowIndex\n * @private\n */\nexport function renderRow(row, rowIndex) {\n  if (this._tableStruct) {\n    accessibleRow.call(this, row, rowIndex, renderCell.bind(this));\n  } else {\n    row.forEach((cell) => renderCell.call(this, cell));\n  }\n\n  return this._rowYPos[rowIndex] + this._rowHeights[rowIndex];\n}\n\n/**\n * Render a cell\n *\n * @this PDFTable\n * @memberOf PDFTable\n * @param {SizedNormalizedTableCellStyle} cell\n * @param {PDFStructureElement} rowStruct\n * @private\n */\nfunction renderCell(cell, rowStruct) {\n  const cellRenderer = () => {\n    // Render cell background\n    if (cell.backgroundColor != null) {\n      this.document\n        .save()\n        .rect(cell.x, cell.y, cell.width, cell.height)\n        .fill(cell.backgroundColor)\n        .restore();\n    }\n\n    // Render border\n    renderBorder.call(\n      this,\n      cell.border,\n      cell.borderColor,\n      cell.x,\n      cell.y,\n      cell.width,\n      cell.height,\n    );\n\n    // Debug cell borders\n    if (cell.debug) {\n      this.document.save();\n      this.document.dash(1, { space: 1 }).lineWidth(1).strokeOpacity(0.3);\n\n      // Debug cell bounds\n      this.document\n        .rect(cell.x, cell.y, cell.width, cell.height)\n        .stroke('green');\n\n      this.document.restore();\n    }\n\n    // Render text\n    if (cell.text) renderCellText.call(this, cell);\n  };\n\n  if (rowStruct) accessibleCell.call(this, cell, rowStruct, cellRenderer);\n  else cellRenderer();\n}\n\n/**\n * @this PDFTable\n * @memberOf PDFTable\n * @param {SizedNormalizedTableCellStyle} cell\n */\nfunction renderCellText(cell) {\n  const doc = this.document;\n\n  // Configure fonts\n  const rollbackFont = doc._fontSource;\n  const rollbackFontSize = doc._fontSize;\n  const rollbackFontFamily = doc._fontFamily;\n  if (cell.customFont) {\n    if (cell.font.src) doc.font(cell.font.src, cell.font.family);\n    if (cell.font.size) doc.fontSize(cell.font.size);\n  }\n\n  const x = cell.textX;\n  const y = cell.textY;\n  const Ah = cell.textAllocatedHeight;\n  const Aw = cell.textAllocatedWidth;\n  const Cw = cell.textBounds.width;\n  const Ch = cell.textBounds.height;\n  const Ox = -cell.textBounds.x;\n  const Oy = -cell.textBounds.y;\n\n  const PxScale =\n    cell.align.x === 'right' ? 1 : cell.align.x === 'center' ? 0.5 : 0;\n  const Px = (Aw - Cw) * PxScale;\n  const PyScale =\n    cell.align.y === 'bottom' ? 1 : cell.align.y === 'center' ? 0.5 : 0;\n  const Py = (Ah - Ch) * PyScale;\n\n  const dx = Px + Ox;\n  const dy = Py + Oy;\n\n  if (cell.debug) {\n    doc.save();\n    doc.dash(1, { space: 1 }).lineWidth(1).strokeOpacity(0.3);\n\n    // Debug actual text bounds\n    if (cell.text) {\n      doc\n        .moveTo(x + Px, y)\n        .lineTo(x + Px, y + Ah)\n        .moveTo(x + Px + Cw, y)\n        .lineTo(x + Px + Cw, y + Ah)\n        .stroke('blue')\n        .moveTo(x, y + Py)\n        .lineTo(x + Aw, y + Py)\n        .moveTo(x, y + Py + Ch)\n        .lineTo(x + Aw, y + Py + Ch)\n        .stroke('green');\n    }\n    // Debug allocated text bounds\n    doc.rect(x, y, Aw, Ah).stroke('orange');\n\n    doc.restore();\n  }\n\n  // Create text mask to cut off any overflowing text\n  // Mask cuts off at the padding not the actual cell, this is intentional!\n  doc.save().rect(x, y, Aw, Ah).clip();\n\n  doc.fillColor(cell.textColor).strokeColor(cell.textStrokeColor);\n  if (cell.textStroke > 0) doc.lineWidth(cell.textStroke);\n\n  // Render the text\n  doc.text(cell.text, x + dx, y + dy, cell.textOptions);\n\n  // Cleanup\n  doc.restore();\n  if (cell.font) doc.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n}\n\n/**\n * @this PDFTable\n * @memberOf PDFTable\n * @param {ExpandedSideDefinition<number>} border\n * @param {ExpandedSideDefinition<PDFColor>} borderColor\n * @param {number} x\n * @param {number} y\n * @param {number} width\n * @param {number} height\n * @param {number[]} [mask]\n * @private\n */\nfunction renderBorder(border, borderColor, x, y, width, height, mask) {\n  border = Object.fromEntries(\n    Object.entries(border).map(([k, v]) => [k, mask && !mask[k] ? 0 : v]),\n  );\n\n  const doc = this.document;\n  if (\n    [border.right, border.bottom, border.left].every(\n      (val) => val === border.top,\n    )\n  ) {\n    if (border.top > 0) {\n      doc\n        .save()\n        .lineWidth(border.top)\n        .rect(x, y, width, height)\n        .stroke(borderColor.top)\n        .restore();\n    }\n  } else {\n    // Top\n    if (border.top > 0) {\n      doc\n        .save()\n        .lineWidth(border.top)\n        .moveTo(x, y)\n        .lineTo(x + width, y)\n        .stroke(borderColor.top)\n        .restore();\n    }\n    // Right\n    if (border.right > 0) {\n      doc\n        .save()\n        .lineWidth(border.right)\n        .moveTo(x + width, y)\n        .lineTo(x + width, y + height)\n        .stroke(borderColor.right)\n        .restore();\n    }\n    // Bottom\n    if (border.bottom > 0) {\n      doc\n        .save()\n        .lineWidth(border.bottom)\n        .moveTo(x + width, y + height)\n        .lineTo(x, y + height)\n        .stroke(borderColor.bottom)\n        .restore();\n    }\n    // Left\n    if (border.left > 0) {\n      doc\n        .save()\n        .lineWidth(border.left)\n        .moveTo(x, y + height)\n        .lineTo(x, y)\n        .stroke(borderColor.left)\n        .restore();\n    }\n  }\n}\n","import { normalizeRow, normalizeTable } from './normalize';\nimport { measure, ensure } from './size';\nimport { renderRow } from './render';\nimport { accommodateCleanup, accommodateTable } from './accessibility';\n\nclass PDFTable {\n  /**\n   * @param {PDFDocument} document\n   * @param {Table} [opts]\n   */\n  constructor(document, opts = {}) {\n    this.document = document;\n    this.opts = Object.freeze(opts);\n\n    normalizeTable.call(this);\n    accommodateTable.call(this);\n\n    this._currRowIndex = 0;\n    this._ended = false;\n\n    // Render cells if present\n    if (opts.data) {\n      for (const row of opts.data) this.row(row);\n      return this.end();\n    }\n  }\n\n  /**\n   * Render a new row in the table\n   *\n   * @param {Iterable<TableCell>} row - The cells to render\n   * @param {boolean} lastRow - Whether this row is the last row\n   * @returns {this} returns the table, unless lastRow is `true` then returns the `PDFDocument`\n   */\n  row(row, lastRow = false) {\n    if (this._ended) {\n      throw new Error(`Table was marked as ended on row ${this._currRowIndex}`);\n    }\n\n    // Convert the iterable into an array\n    row = Array.from(row);\n    // Transform row\n    row = normalizeRow.call(this, row, this._currRowIndex);\n    if (this._currRowIndex === 0) ensure.call(this, row);\n    const { newPage, toRender } = measure.call(this, row, this._currRowIndex);\n    if (newPage) this.document.continueOnNewPage();\n    const yPos = renderRow.call(this, toRender, this._currRowIndex);\n\n    // Position document at base of new row\n    this.document.x = this._position.x;\n    this.document.y = yPos;\n\n    if (lastRow) return this.end();\n\n    this._currRowIndex++;\n    return this;\n  }\n\n  /**\n   * Indicates to the table that it is finished,\n   * allowing the table to flush its cell buffer (which should be empty unless there is rowSpans)\n   *\n   * @returns {PDFDocument} the document\n   */\n  end() {\n    // Flush any remaining cells\n    while (this._rowBuffer?.size) this.row([]);\n    this._ended = true;\n    accommodateCleanup.call(this);\n    return this.document;\n  }\n}\n\nexport default PDFTable;\n","import PDFTable from '../table/index';\n\nexport default {\n  initTables() {\n    this._tableIndex = 0;\n  },\n  /**\n   * @param {Table} [opts]\n   * @returns {PDFTable} returns the table object unless `data` is set,\n   * then it returns the underlying document\n   */\n  table(opts) {\n    return new PDFTable(this, opts);\n  },\n};\n","class PDFMetadata {\n  constructor() {\n    this._metadata = `\n        <?xpacket begin=\"\\ufeff\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\n            <x:xmpmeta xmlns:x=\"adobe:ns:meta/\">\n                <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n        `;\n  }\n\n  _closeTags() {\n    this._metadata = this._metadata.concat(`\n                </rdf:RDF>\n            </x:xmpmeta>\n        <?xpacket end=\"w\"?>\n        `);\n  }\n\n  append(xml, newline = true) {\n    this._metadata = this._metadata.concat(xml);\n    if (newline) this._metadata = this._metadata.concat('\\n');\n  }\n\n  getXML() {\n    return this._metadata;\n  }\n\n  getLength() {\n    return this._metadata.length;\n  }\n\n  end() {\n    this._closeTags();\n    this._metadata = this._metadata.trim();\n  }\n}\n\nexport default PDFMetadata;\n","import PDFMetadata from '../metadata';\n\nexport default {\n  initMetadata() {\n    this.metadata = new PDFMetadata();\n  },\n\n  appendXML(xml, newline = true) {\n    this.metadata.append(xml, newline);\n  },\n\n  _addInfo() {\n    this.appendXML(`\n        <rdf:Description rdf:about=\"\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\">\n            <xmp:CreateDate>${this.info.CreationDate.toISOString().split('.')[0] + 'Z'}</xmp:CreateDate>\n            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>\n        </rdf:Description>\n        `);\n\n    if (this.info.Title || this.info.Author || this.info.Subject) {\n      this.appendXML(`\n            <rdf:Description rdf:about=\"\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n            `);\n\n      if (this.info.Title) {\n        this.appendXML(`\n                <dc:title>\n                    <rdf:Alt>\n                        <rdf:li xml:lang=\"x-default\">${this.info.Title}</rdf:li>\n                    </rdf:Alt>\n                </dc:title>\n                `);\n      }\n\n      if (this.info.Author) {\n        this.appendXML(`\n                <dc:creator>\n                    <rdf:Seq>\n                        <rdf:li>${this.info.Author}</rdf:li>\n                    </rdf:Seq>\n                </dc:creator>\n                `);\n      }\n\n      if (this.info.Subject) {\n        this.appendXML(`\n                <dc:description>\n                    <rdf:Alt>\n                        <rdf:li xml:lang=\"x-default\">${this.info.Subject}</rdf:li>\n                    </rdf:Alt>\n                </dc:description>\n                `);\n      }\n\n      this.appendXML(`\n            </rdf:Description>\n            `);\n    }\n\n    this.appendXML(\n      `\n        <rdf:Description rdf:about=\"\" xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">\n            <pdf:Producer>${this.info.Creator}</pdf:Producer>`,\n      false,\n    );\n\n    if (this.info.Keywords) {\n      this.appendXML(\n        `\n            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`,\n        false,\n      );\n    }\n\n    this.appendXML(`\n        </rdf:Description>\n        `);\n  },\n\n  endMetadata() {\n    this._addInfo();\n\n    this.metadata.end();\n\n    /*\n        Metadata was introduced in PDF 1.4, so adding it to 1.3 \n        will likely only take up more space.\n        */\n    if (this.version != 1.3) {\n      this.metadataRef = this.ref({\n        length: this.metadata.getLength(),\n        Type: 'Metadata',\n        Subtype: 'XML',\n      });\n      this.metadataRef.compress = false;\n      this.metadataRef.write(Buffer.from(this.metadata.getXML(), 'utf-8'));\n      this.metadataRef.end();\n      this._root.data.Metadata = this.metadataRef;\n    }\n  },\n};\n","/*\nPDFDocument - represents an entire PDF document\nBy Devon Govett\n*/\n\nimport stream from 'stream';\nimport PDFObject from './object';\nimport PDFReference from './reference';\nimport PDFPage from './page';\nimport PDFNameTree from './name_tree';\nimport PDFSecurity from './security';\nimport ColorMixin from './mixins/color';\nimport VectorMixin from './mixins/vector';\nimport FontsMixin from './mixins/fonts';\nimport TextMixin from './mixins/text';\nimport ImagesMixin from './mixins/images';\nimport AnnotationsMixin from './mixins/annotations';\nimport OutlineMixin from './mixins/outline';\nimport MarkingsMixin from './mixins/markings';\nimport AcroFormMixin from './mixins/acroform';\nimport AttachmentsMixin from './mixins/attachments';\nimport LineWrapper from './line_wrapper';\nimport SubsetMixin from './mixins/subsets';\nimport TableMixin from './mixins/table';\nimport MetadataMixin from './mixins/metadata';\n\nclass PDFDocument extends stream.Readable {\n  constructor(options = {}) {\n    super(options);\n    this.options = options;\n\n    // PDF version\n    switch (options.pdfVersion) {\n      case '1.4':\n        this.version = 1.4;\n        break;\n      case '1.5':\n        this.version = 1.5;\n        break;\n      case '1.6':\n        this.version = 1.6;\n        break;\n      case '1.7':\n      case '1.7ext3':\n        this.version = 1.7;\n        break;\n      default:\n        this.version = 1.3;\n        break;\n    }\n\n    // Whether streams should be compressed\n    this.compress =\n      this.options.compress != null ? this.options.compress : true;\n\n    this._pageBuffer = [];\n    this._pageBufferStart = 0;\n\n    // The PDF object store\n    this._offsets = [];\n    this._waiting = 0;\n    this._ended = false;\n    this._offset = 0;\n    const Pages = this.ref({\n      Type: 'Pages',\n      Count: 0,\n      Kids: [],\n    });\n\n    const Names = this.ref({\n      Dests: new PDFNameTree(),\n    });\n\n    this._root = this.ref({\n      Type: 'Catalog',\n      Pages,\n      Names,\n    });\n\n    if (this.options.lang) {\n      this._root.data.Lang = new String(this.options.lang);\n    }\n\n    // The current page\n    this.page = null;\n\n    // Initialize mixins\n    this.initMetadata();\n    this.initColor();\n    this.initVector();\n    this.initFonts(options.font);\n    this.initText();\n    this.initImages();\n    this.initOutline();\n    this.initMarkings(options);\n    this.initTables();\n    this.initSubset(options);\n\n    // Initialize the metadata\n    this.info = {\n      Producer: 'PDFKit',\n      Creator: 'PDFKit',\n      CreationDate: new Date(),\n    };\n\n    if (this.options.info) {\n      for (let key in this.options.info) {\n        const val = this.options.info[key];\n        this.info[key] = val;\n      }\n    }\n\n    if (this.options.displayTitle) {\n      this._root.data.ViewerPreferences = this.ref({\n        DisplayDocTitle: true,\n      });\n    }\n\n    // Generate file ID\n    this._id = PDFSecurity.generateFileID(this.info);\n\n    // Initialize security settings\n    this._security = PDFSecurity.create(this, options);\n\n    // Write the header\n    // PDF version\n    this._write(`%PDF-${this.version}`);\n\n    // 4 binary chars, as recommended by the spec\n    this._write('%\\xFF\\xFF\\xFF\\xFF');\n\n    // Add the first page\n    if (this.options.autoFirstPage !== false) {\n      this.addPage();\n    }\n  }\n\n  addPage(options) {\n    if (options == null) {\n      ({ options } = this);\n    }\n\n    // end the current page if needed\n    if (!this.options.bufferPages) {\n      this.flushPages();\n    }\n\n    // create a page object\n    this.page = new PDFPage(this, options);\n    this._pageBuffer.push(this.page);\n\n    // add the page to the object store\n    const pages = this._root.data.Pages.data;\n    pages.Kids.push(this.page.dictionary);\n    pages.Count++;\n\n    // reset x and y coordinates\n    this.x = this.page.margins.left;\n    this.y = this.page.margins.top;\n\n    // flip PDF coordinate system so that the origin is in\n    // the top left rather than the bottom left\n    this._ctm = [1, 0, 0, 1, 0, 0];\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n\n    this.emit('pageAdded');\n\n    return this;\n  }\n\n  continueOnNewPage(options) {\n    const pageMarkings = this.endPageMarkings(this.page);\n\n    this.addPage(options ?? this.page._options);\n\n    this.initPageMarkings(pageMarkings);\n\n    return this;\n  }\n\n  bufferedPageRange() {\n    return { start: this._pageBufferStart, count: this._pageBuffer.length };\n  }\n\n  switchToPage(n) {\n    let page;\n    if (!(page = this._pageBuffer[n - this._pageBufferStart])) {\n      throw new Error(\n        `switchToPage(${n}) out of bounds, current buffer covers pages ${\n          this._pageBufferStart\n        } to ${this._pageBufferStart + this._pageBuffer.length - 1}`,\n      );\n    }\n\n    return (this.page = page);\n  }\n\n  flushPages() {\n    // this local variable exists so we're future-proof against\n    // reentrant calls to flushPages.\n    const pages = this._pageBuffer;\n    this._pageBuffer = [];\n    this._pageBufferStart += pages.length;\n    for (let page of pages) {\n      this.endPageMarkings(page);\n      page.end();\n    }\n  }\n\n  addNamedDestination(name, ...args) {\n    if (args.length === 0) {\n      args = ['XYZ', null, null, null];\n    }\n    if (args[0] === 'XYZ' && args[2] !== null) {\n      args[2] = this.page.height - args[2];\n    }\n    args.unshift(this.page.dictionary);\n    this._root.data.Names.data.Dests.add(name, args);\n  }\n\n  addNamedEmbeddedFile(name, ref) {\n    if (!this._root.data.Names.data.EmbeddedFiles) {\n      // disabling /Limits for this tree fixes attachments not showing in Adobe Reader\n      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({\n        limits: false,\n      });\n    }\n\n    // add filespec to EmbeddedFiles\n    this._root.data.Names.data.EmbeddedFiles.add(name, ref);\n  }\n\n  addNamedJavaScript(name, js) {\n    if (!this._root.data.Names.data.JavaScript) {\n      this._root.data.Names.data.JavaScript = new PDFNameTree();\n    }\n    let data = {\n      JS: new String(js),\n      S: 'JavaScript',\n    };\n    this._root.data.Names.data.JavaScript.add(name, data);\n  }\n\n  ref(data) {\n    const ref = new PDFReference(this, this._offsets.length + 1, data);\n    this._offsets.push(null); // placeholder for this object's offset once it is finalized\n    this._waiting++;\n    return ref;\n  }\n\n  _read() {}\n  // do nothing, but this method is required by node\n\n  _write(data) {\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data + '\\n', 'binary');\n    }\n\n    this.push(data);\n    this._offset += data.length;\n  }\n\n  addContent(data) {\n    this.page.write(data);\n    return this;\n  }\n\n  _refEnd(ref) {\n    this._offsets[ref.id - 1] = ref.offset;\n    if (--this._waiting === 0 && this._ended) {\n      this._finalize();\n      this._ended = false;\n    }\n  }\n\n  end() {\n    this.flushPages();\n\n    this._info = this.ref();\n    for (let key in this.info) {\n      let val = this.info[key];\n      if (typeof val === 'string') {\n        val = new String(val);\n      }\n\n      let entry = this.ref(val);\n      entry.end();\n\n      this._info.data[key] = entry;\n    }\n\n    this._info.end();\n\n    for (let name in this._fontFamilies) {\n      const font = this._fontFamilies[name];\n      font.finalize();\n    }\n\n    this.endOutline();\n    this.endMarkings();\n\n    if (this.subset) {\n      this.endSubset();\n    }\n\n    this.endMetadata();\n\n    this._root.end();\n    this._root.data.Pages.end();\n    this._root.data.Names.end();\n    this.endAcroForm();\n\n    if (this._root.data.ViewerPreferences) {\n      this._root.data.ViewerPreferences.end();\n    }\n\n    if (this._security) {\n      this._security.end();\n    }\n\n    if (this._waiting === 0) {\n      this._finalize();\n    } else {\n      this._ended = true;\n    }\n  }\n\n  _finalize() {\n    // generate xref\n    const xRefOffset = this._offset;\n    this._write('xref');\n    this._write(`0 ${this._offsets.length + 1}`);\n    this._write('0000000000 65535 f ');\n\n    for (let offset of this._offsets) {\n      offset = `0000000000${offset}`.slice(-10);\n      this._write(offset + ' 00000 n ');\n    }\n\n    // trailer\n    const trailer = {\n      Size: this._offsets.length + 1,\n      Root: this._root,\n      Info: this._info,\n      ID: [this._id, this._id],\n    };\n    if (this._security) {\n      trailer.Encrypt = this._security.dictionary;\n    }\n\n    this._write('trailer');\n    this._write(PDFObject.convert(trailer));\n\n    this._write('startxref');\n    this._write(`${xRefOffset}`);\n    this._write('%%EOF');\n\n    // end the stream\n    this.push(null);\n  }\n\n  toString() {\n    return '[object PDFDocument]';\n  }\n}\n\nconst mixin = (methods) => {\n  Object.assign(PDFDocument.prototype, methods);\n};\n\nmixin(MetadataMixin);\nmixin(ColorMixin);\nmixin(VectorMixin);\nmixin(FontsMixin);\nmixin(TextMixin);\nmixin(ImagesMixin);\nmixin(AnnotationsMixin);\nmixin(OutlineMixin);\nmixin(MarkingsMixin);\nmixin(AcroFormMixin);\nmixin(AttachmentsMixin);\nmixin(SubsetMixin);\nmixin(TableMixin);\n\nPDFDocument.LineWrapper = LineWrapper;\n\nexport default PDFDocument;\n"],"names":["PDFAbstractReference","toString","Error","PDFTree","constructor","options","_items","limits","add","key","val","get","sortedKeys","Object","keys","sort","a","b","_compareKeys","out","length","first","last","push","PDFObject","convert","_dataForKey","_keysName","join","SpotColor","doc","name","C","M","Y","K","id","spotColors","values","ref","Range","C0","C1","map","value","FunctionType","Domain","N","end","pad","str","Array","slice","escapableRe","escapable","swapBytes","buff","l","i","object","encryptFn","String","string","isUnicode","charCodeAt","stringBuffer","Buffer","from","valueOf","replace","c","isBuffer","Date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","isArray","items","e","call","number","n","Math","round","PDFReference","document","data","gen","compress","Filter","uncompressedLength","buffer","write","chunk","Uint8Array","Length","finalize","offset","_offset","_security","getEncryptFn","concat","zlib","deflateSync","_write","_refEnd","fArray","Float32Array","uArray","Uint32Array","PDFNumber","rounded","fround","normalizeSides","sides","defaultDefinition","undefined","transformer","v","top","right","bottom","left","vertical","horizontal","MM_TO_CM","CM_TO_IN","PX_TO_IN","IN_TO_PT","PC_TO_PT","cosine","cos","PI","sine","sin","DEFAULT_MARGINS","SIZES","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10","C2","C3","C4","C5","C6","C7","C8","C9","C10","RA0","RA1","RA2","RA3","RA4","SRA0","SRA1","SRA2","SRA3","SRA4","EXECUTIVE","FOLIO","LEGAL","LETTER","TABLOID","PDFPage","_options","size","layout","dimensions","toUpperCase","width","height","content","font","fontFamily","fontSize","margins","margin","x","sizeToPoint","resources","ProcSet","dictionary","Type","Parent","_root","Pages","MediaBox","Contents","Resources","markings","fonts","Font","xobjects","XObject","ext_gstates","ExtGState","patterns","Pattern","colorSpaces","ColorSpace","annotations","Annots","structParentTreeKey","StructParents","createStructParentTreeNextKey","contentWidth","contentHeight","maxY","_setTabOrder","Tabs","hasMarkInfoDictionary","color","PDFNameTree","localeCompare","k","inRange","rangeGroup","startRange","endRange","middleRange","floor","arrayIndex","unassigned_code_points","isUnassignedCodePoint","character","commonly_mapped_to_nothing","isCommonlyMappedToNothing","non_ASCII_space_characters","isNonASCIISpaceCharacter","non_ASCII_controls_characters","non_character_codepoints","prohibited_characters","isProhibitedCharacter","bidirectional_r_al","isBidirectionalRAL","bidirectional_l","isBidirectionalL","mapping2space","mapping2nothing","getCodePoint","codePointAt","toCodePoints","input","codepoints","before","next","saslprep","opts","TypeError","mapped_input","filter","normalized_input","fromCodePoint","apply","normalize","normalized_map","hasProhibited","some","allowUnassigned","hasUnassigned","hasBidiRAL","hasBidiL","isFirstBidiRAL","isLastBidiRAL","PDFSecurity","generateFileID","info","infoStr","CreationDate","getTime","hasOwnProperty","wordArrayToBuffer","CryptoJS","MD5","generateRandomWordArray","bytes","lib","WordArray","random","create","ownerPassword","userPassword","_setupEncryption","pdfVersion","version","encDict","_setupEncryptionV1V2V4","_setupEncryptionV5","r","permissions","keyBits","getPermissionsR2","getPermissionsR3","paddedUserPassword","processPasswordR2R3R4","paddedOwnerPassword","ownerPasswordEntry","getOwnerPasswordR2R3R4","encryptionKey","getEncryptionKeyR2R3R4","_id","userPasswordEntry","getUserPasswordR2","getUserPasswordR3R4","V","CF","StdCF","AuthEvent","CFM","StmF","StrF","R","O","U","P","processedUserPassword","processPasswordR5","processedOwnerPassword","getEncryptionKeyR5","getUserPasswordR5","userKeySalt","words","userEncryptionKeyEntry","getUserEncryptionKeyR5","getOwnerPasswordR5","ownerKeySalt","ownerEncryptionKeyEntry","getOwnerEncryptionKeyR5","permsEntry","getEncryptedPermissionsR5","OE","UE","Perms","obj","digest","clone","sigBytes","min","RC4","encrypt","ciphertext","iv","mode","CBC","padding","Pkcs7","AES","permissionObject","printing","modifying","copying","annotating","fillingForms","contentAccessibility","documentAssembly","documentId","cipher","xorRound","ceil","j","lsbFirstWord","validationSalt","keySalt","SHA256","NoPadding","ECB","password","alloc","index","code","PASSWORD_PADDING","unescape","encodeURIComponent","wordArray","byteArray","PDFGradient","stops","embedded","transform","stop","pos","opacity","_normalizeColor","_colorSpace","max","setTransform","m11","m12","m21","m22","dx","dy","embed","m","fn","stopsLength","matrix","bounds","encode","Functions","Bounds","Encode","_gradCount","shader","pattern","PatternType","Shading","Matrix","grad","opacityGradient","pageBBox","page","form","Subtype","FormType","BBox","Group","S","CS","Sh1","gstate","SMask","G","opacityPattern","PaintType","TilingType","XStep","YStep","Gs1","stroke","m0","m1","m2","m3","m4","m5","_ctm","_setColorSpace","op","addContent","PDFLinearGradient","x1","y1","x2","y2","ShadingType","Coords","Function","Extend","PDFRadialGradient","r1","r2","underlyingColorSpaces","PDFTilingPattern","bBox","xStep","yStep","stream","createPattern","toFixed","embedPatternColorSpaces","forEach","csName","csId","getPatternColorSpaceId","cs","underlyingColorspace","_patternCount","patternColor","normalizedColor","_getColorSpace","Gradient","initColor","_opacityRegistry","_opacityCount","charAt","hex","parseInt","namedColors","part","_setColor","_setColorCore","space","fillColor","set","fillOpacity","_fillColor","strokeColor","strokeOpacity","_doOpacity","ca","CA","linearGradient","radialGradient","bbox","addSpotColor","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","grey","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","cx","cy","px","py","sx","sy","parameters","A","H","h","L","Q","q","s","T","t","Z","z","parse","path","cmd","ret","args","curArg","foundDecimal","params","includes","commands","runners","moveTo","bezierCurveTo","quadraticCurveTo","solveArc","lineTo","closePath","y","coords","rx","ry","rot","large","sweep","ex","ey","segs","arcToSegments","seg","bez","segmentToBezier","rotateX","ox","oy","th","sin_th","cos_th","abs","pl","sqrt","a00","a01","a10","a11","x0","y0","d","sfactor_sq","sfactor","xc","yc","th0","atan2","th1","th_arc","segments","result","th2","th3","th_half","x3","y3","SVGPath","KAPPA","initVector","_ctmStack","save","restore","pop","lineWidth","w","_CAP_STYLES","BUTT","ROUND","SQUARE","lineCap","_JOIN_STYLES","MITER","BEVEL","lineJoin","miterLimit","dash","originalLength","valid","every","Number","isFinite","JSON","stringify","phase","undash","cp1x","cp1y","cp2x","cp2y","cpx","cpy","rect","roundedRect","ellipse","xe","ye","xm","ym","circle","radius","arc","startAngle","endAngle","anticlockwise","TWO_PI","HALF_PI","deltaAng","dir","numSegs","segAng","handleLen","curAng","deltaCx","deltaCy","ax","ay","segIdx","polygon","points","shift","point","_windingRule","rule","test","fill","fillAndStroke","isFillRule","clip","translate","rotate","angle","rad","origin","scale","xFactor","yFactor","WIN_ANSI_MAP","characters","split","AFMFont","contents","attributes","glyphWidths","boundingBoxes","kernPairs","ascender","descender","xHeight","capHeight","lineGap","section","line","match","encodeText","text","res","len","char","glyphsForString","glyphs","charCode","characterToGlyph","widthOfGlyph","glyph","getKernPair","advancesForGlyphs","advances","PDFFont","widthOfString","lineHeight","includeGap","gap","STANDARD_FONTS","Courier","fs","readFileSync","__dirname","Courier-Bold","Courier-Oblique","Courier-BoldOblique","Helvetica","Helvetica-Bold","Helvetica-Oblique","Helvetica-BoldOblique","Times-Roman","Times-Bold","Times-Italic","Times-BoldItalic","Symbol","ZapfDingbats","StandardFont","BaseFont","Encoding","encoded","positions","xAdvance","yAdvance","xOffset","yOffset","advanceWidth","advance","isStandardFont","toHex","num","EmbeddedFont","subset","createSubset","unicode","widths","getGlyph","postscriptName","unitsPerEm","ascent","descent","fontLayoutCache","layoutCache","layoutRun","features","run","position","layoutCached","cached","onlyWidth","needle","gid","includeGlyph","codePoints","isCFF","cff","fontFile","familyClass","sFamilyClass","flags","post","isFixedPitch","head","macStyle","italic","tag","fromCharCode","replaceAll","descriptor","FontName","Flags","FontBBox","minX","minY","maxX","ItalicAngle","italicAngle","Ascent","Descent","CapHeight","XHeight","StemV","FontFile3","FontFile2","CIDSet","CIDSetRef","descendantFontData","CIDSystemInfo","Registry","Ordering","Supplement","FontDescriptor","W","CIDToGIDMap","descendantFont","DescendantFonts","ToUnicode","toUnicodeCmap","cmap","entries","chunkSize","chunks","ranges","start","PDFFontFactory","open","src","family","fontkit","ArrayBuffer","isEqualFont","font1","font2","_tables","checkSumAdjustment","records","initFonts","defaultFont","defaultFontFamily","defaultFontSize","_fontFamilies","_fontCount","_fontSource","_fontFamily","_fontSize","_font","_remSize","_registeredFonts","cacheKey","currentLineHeight","registerFont","defaultValue","percentageWidth","multiplier","SOFT_HYPHEN","HYPHEN","LineWrapper","EventEmitter","horizontalScaling","indent","characterSpacing","wordSpacing","columns","columnGap","spaceLeft","startX","startY","column","ellipsis","continuedX","on","indentAllLines","once","continued","align","lastLine","paragraphGap","wordWidth","word","canFit","eachWord","bk","breaker","LineBreaker","wordWidths","nextBreak","shouldContinue","lbk","fbk","mightGrow","mustShrink","required","wrap","nextY","nextSection","textWidth","wc","lc","emitLine","wordCount","emit","lh","continueOnNewPage","initText","_line","bind","_lineGap","moveDown","lines","moveUp","_text","lineCallback","_initOptions","addStructure","structParent","struct","structType","markStructureContent","rotation","wrapper","_wrapper","_textOptions","boundsOfString","trim","spaceWidth","x4","y4","xMin","xMax","yMin","yMax","heightOfString","Infinity","list","listType","unit","midLine","bulletRadius","textIndent","itemIndent","bulletIndent","level","levels","numbers","flatten","item","label","letter","times","drawListItem","listItem","itemType","labelType","bodyType","structTypes","diff","_fragment","assign","lineBreak","baseline","renderedWidth","link","goTo","destination","addNamedDestination","underline","lineY","strike","oblique","skew","encodedWord","positionsWord","hadOffset","addSegment","cur","flush","MARKERS","COLOR_SPACE_MAP","JPEG","marker","readUInt16BE","orientation","exif","fromBuffer","Orientation","bits","channels","colorSpace","BitsPerComponent","Width","Height","PNGImage","image","PNG","imgData","dataDecoded","hasAlphaChannel","isInterlaced","interlaceMethod","Predictor","Colors","colors","Columns","palette","transparency","grayscale","rgb","mask","indexed","loadIndexedAlphaChannel","splitAlphaChannel","decodeData","alphaChannel","sMask","Decode","decodePixels","pixels","p","colorCount","pixelCount","skipByteCount","colorIndex","PDFImage","exec","initImages","_imageRegistry","_imageCount","bh","bp","bw","ip","left1","originX","originY","ignoreOrientation","inDocumentFlow","openImage","wp","hp","fit","cover","valign","rotateAngle","xTransform","yTransform","hTransform","wTransform","annotate","Rect","_convertRect","Border","F","Dest","note","Name","D","url","pages","Kids","URI","_markup","QuadPoints","highlight","lineAnnotation","rectAnnotation","ellipseAnnotation","textAnnotation","DA","fileAnnotation","file","filespec","hidden","FS","Desc","PDFOutline","parent","title","dest","expanded","outlineData","children","addItem","endOutline","Count","First","Last","child","Prev","Next","initOutline","outline","Outlines","PageMode","PDFStructureContent","pageRef","mcid","refs","structContent","PDFStructureElement","type","_attached","_ended","_flushed","_isValidChild","lang","Lang","alt","Alt","E","actual","ActualText","_children","setParent","setAttached","_addContentToParentTree","_contentForClosure","pageStructParents","getStructParentTree","parentRef","_flush","closure","endMarkedContent","_isFlushable","_flushChild","Pg","MCID","PDFNumberTree","initMarkings","structChildren","tagged","getMarkInfoDictionary","Marked","getStructTreeRoot","markContent","toClose","marking","attached","Attached","structElem","structTreeRoot","initPageMarkings","pageMarkings","newStructContent","endPageMarkings","MarkInfo","StructTreeRoot","ParentTree","ParentTreeNextKey","endMarkings","FIELD_FLAGS","readOnly","noExport","multiline","toggleToOffButton","radioButton","pushButton","combo","edit","multiSelect","noSpell","FIELD_JUSTIFY","center","VALUE_MAP","FORMAT_SPECIAL","zip","zipPlus4","zip4","phone","ssn","FORMAT_DEFAULT","nDec","sepComma","negStyle","currency","currencyPrepend","percent","initForm","_acroform","Fields","NeedAppearances","DR","AcroForm","endAcroForm","fontDict","fieldRef","_endChild","childRef","formField","fieldDict","_fieldDict","_addToParent","formAnnotation","annotRef","formText","formPushButton","formCombo","formList","formRadioButton","formCheckbox","_resolveType","_resolveFlags","_resolveJustify","_resolveFont","_resolveStrings","_resolveColors","_resolveFormat","FT","f","format","fnKeystroke","fnFormat","param","AA","JS","backgroundColor","MK","BG","borderColor","BC","Ff","select","appendChoices","idx","Opt","relationship","refBody","Params","birthtime","ctime","statSync","ModDate","creationDate","modifiedDate","checksum","CheckSum","Size","byteLength","_fileRegistry","isEqual","fileSpecBody","AFRelationship","EF","UF","description","addNamedEmbeddedFile","AF","initPDFA","pSubset","subset_conformance","endSubset","_addPdfaMetadata","_addColorOutputIntent","iccProfile","colorProfileRef","intentRef","Info","OutputConditionIdentifier","DestOutputProfile","OutputIntents","_getPdfaid","appendXML","initPDFUA","_addPdfuaMetadata","_getPdfuaid","_importSubset","initSubset","PDFA","PDFUA","ROW_FIELDS","COLUMN_FIELDS","memoize","maxSize","cache","Map","has","delete","isObject","deepMerge","target","sources","deepClone","source","normalizedDefaultStyle","defaultStyleInternal","defaultStyle","defaultRowStyle","fromEntries","defaultColStyle","border","normalizeAlignment","normalizedRowStyle","rowStyleInternal","rowStyle","minHeight","maxHeight","normalizedColumnStyle","colStyleInternal","colStyle","_maxWidth","minWidth","maxWidth","normalizeTable","_tableIndex","_position","_defaultStyle","columnStyles","_colStyle","rowStyles","_rowStyle","normalizeText","normalizeCell","cell","rowIndex","colIndex","customFont","rollbackFont","rollbackFontSize","rollbackFontFamily","config","rowSpan","colSpan","textStroke","textStrokeColor","textColor","textOptions","scope","toLowerCase","debug","normalizeRow","row","_cellClaim","Set","ensure","_columnWidths","ensureColumnWidths","reduce","_rowHeights","_rowYPos","_rowBuffer","numCols","starColumnIndexes","starMinAcc","unclaimedWidth","col","starColCount","starSize","tempX","_columnXPos","measure","toRender","measureCell","rowHeight","acc","textBounds","newPage","console","warn","stack","cellWidth","cellHeight","textAllocatedWidth","textAllocatedHeight","textMaxWidth","textMaxHeight","computeBounds","unRotatedTextBounds","textX","textY","allocWidth","allocHeight","FG","denominator","accommodateTable","_tableStruct","ID","PDFDocument","_headerRowLookup","_headerColumnLookup","accommodateCleanup","accessibleRow","renderCell","rowStruct","accessibleCell","callback","cellStruct","Padding","RowSpan","ColSpan","BorderThickness","Scope","Headers","_","flat","Boolean","normalizeColor","BackgroundColor","hasBorder","BorderColor","renderRow","cellRenderer","renderBorder","renderCellText","Ah","Aw","Cw","Ch","Ox","Oy","PxScale","Px","PyScale","Py","PDFTable","freeze","_currRowIndex","lastRow","yPos","initTables","table","PDFMetadata","_metadata","_closeTags","append","xml","newline","getXML","getLength","initMetadata","metadata","_addInfo","toISOString","Creator","Title","Author","Subject","Keywords","endMetadata","metadataRef","Metadata","Readable","_pageBuffer","_pageBufferStart","_offsets","_waiting","Names","Dests","Producer","displayTitle","ViewerPreferences","DisplayDocTitle","autoFirstPage","addPage","bufferPages","flushPages","bufferedPageRange","count","switchToPage","unshift","EmbeddedFiles","addNamedJavaScript","js","JavaScript","_read","_finalize","_info","entry","xRefOffset","trailer","Root","Encrypt","mixin","methods","prototype","MetadataMixin","ColorMixin","VectorMixin","FontsMixin","TextMixin","ImagesMixin","AnnotationsMixin","OutlineMixin","MarkingsMixin","AcroFormMixin","AttachmentsMixin","SubsetMixin","TableMixin"],"mappings":"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M,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EACtE,MAAM,EA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