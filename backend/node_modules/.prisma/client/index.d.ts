
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Position
 * 
 */
export type Position = $Result.DefaultSelection<Prisma.$PositionPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model PerformanceEvaluation
 * 
 */
export type PerformanceEvaluation = $Result.DefaultSelection<Prisma.$PerformanceEvaluationPayload>
/**
 * Model Admission
 * 
 */
export type Admission = $Result.DefaultSelection<Prisma.$AdmissionPayload>
/**
 * Model AdmissionDocument
 * 
 */
export type AdmissionDocument = $Result.DefaultSelection<Prisma.$AdmissionDocumentPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model ReportDocument
 * 
 */
export type ReportDocument = $Result.DefaultSelection<Prisma.$ReportDocumentPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model Training
 * 
 */
export type Training = $Result.DefaultSelection<Prisma.$TrainingPayload>
/**
 * Model UserTraining
 * 
 */
export type UserTraining = $Result.DefaultSelection<Prisma.$UserTrainingPayload>
/**
 * Model TrainingDocument
 * 
 */
export type TrainingDocument = $Result.DefaultSelection<Prisma.$TrainingDocumentPayload>
/**
 * Model Supporter
 * 
 */
export type Supporter = $Result.DefaultSelection<Prisma.$SupporterPayload>
/**
 * Model reports
 * 
 */
export type reports = $Result.DefaultSelection<Prisma.$reportsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.performanceEvaluation`: Exposes CRUD operations for the **PerformanceEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceEvaluations
    * const performanceEvaluations = await prisma.performanceEvaluation.findMany()
    * ```
    */
  get performanceEvaluation(): Prisma.PerformanceEvaluationDelegate<ExtArgs>;

  /**
   * `prisma.admission`: Exposes CRUD operations for the **Admission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admissions
    * const admissions = await prisma.admission.findMany()
    * ```
    */
  get admission(): Prisma.AdmissionDelegate<ExtArgs>;

  /**
   * `prisma.admissionDocument`: Exposes CRUD operations for the **AdmissionDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmissionDocuments
    * const admissionDocuments = await prisma.admissionDocument.findMany()
    * ```
    */
  get admissionDocument(): Prisma.AdmissionDocumentDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs>;

  /**
   * `prisma.reportDocument`: Exposes CRUD operations for the **ReportDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportDocuments
    * const reportDocuments = await prisma.reportDocument.findMany()
    * ```
    */
  get reportDocument(): Prisma.ReportDocumentDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs>;

  /**
   * `prisma.training`: Exposes CRUD operations for the **Training** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings
    * const trainings = await prisma.training.findMany()
    * ```
    */
  get training(): Prisma.TrainingDelegate<ExtArgs>;

  /**
   * `prisma.userTraining`: Exposes CRUD operations for the **UserTraining** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTrainings
    * const userTrainings = await prisma.userTraining.findMany()
    * ```
    */
  get userTraining(): Prisma.UserTrainingDelegate<ExtArgs>;

  /**
   * `prisma.trainingDocument`: Exposes CRUD operations for the **TrainingDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingDocuments
    * const trainingDocuments = await prisma.trainingDocument.findMany()
    * ```
    */
  get trainingDocument(): Prisma.TrainingDocumentDelegate<ExtArgs>;

  /**
   * `prisma.supporter`: Exposes CRUD operations for the **Supporter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supporters
    * const supporters = await prisma.supporter.findMany()
    * ```
    */
  get supporter(): Prisma.SupporterDelegate<ExtArgs>;

  /**
   * `prisma.reports`: Exposes CRUD operations for the **reports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.reports.findMany()
    * ```
    */
  get reports(): Prisma.reportsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    Position: 'Position',
    Department: 'Department',
    PerformanceEvaluation: 'PerformanceEvaluation',
    Admission: 'Admission',
    AdmissionDocument: 'AdmissionDocument',
    Task: 'Task',
    Group: 'Group',
    ReportDocument: 'ReportDocument',
    Setting: 'Setting',
    ChatMessage: 'ChatMessage',
    Training: 'Training',
    UserTraining: 'UserTraining',
    TrainingDocument: 'TrainingDocument',
    Supporter: 'Supporter',
    reports: 'reports'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "profile" | "position" | "department" | "performanceEvaluation" | "admission" | "admissionDocument" | "task" | "group" | "reportDocument" | "setting" | "chatMessage" | "training" | "userTraining" | "trainingDocument" | "supporter" | "reports"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Position: {
        payload: Prisma.$PositionPayload<ExtArgs>
        fields: Prisma.PositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findFirst: {
            args: Prisma.PositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findMany: {
            args: Prisma.PositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          create: {
            args: Prisma.PositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          createMany: {
            args: Prisma.PositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          delete: {
            args: Prisma.PositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          update: {
            args: Prisma.PositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          deleteMany: {
            args: Prisma.PositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.PositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      PerformanceEvaluation: {
        payload: Prisma.$PerformanceEvaluationPayload<ExtArgs>
        fields: Prisma.PerformanceEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload>
          }
          findFirst: {
            args: Prisma.PerformanceEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload>
          }
          findMany: {
            args: Prisma.PerformanceEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload>[]
          }
          create: {
            args: Prisma.PerformanceEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload>
          }
          createMany: {
            args: Prisma.PerformanceEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceEvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload>[]
          }
          delete: {
            args: Prisma.PerformanceEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload>
          }
          update: {
            args: Prisma.PerformanceEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceEvaluationPayload>
          }
          aggregate: {
            args: Prisma.PerformanceEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceEvaluation>
          }
          groupBy: {
            args: Prisma.PerformanceEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceEvaluationCountAggregateOutputType> | number
          }
        }
      }
      Admission: {
        payload: Prisma.$AdmissionPayload<ExtArgs>
        fields: Prisma.AdmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findFirst: {
            args: Prisma.AdmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findMany: {
            args: Prisma.AdmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          create: {
            args: Prisma.AdmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          createMany: {
            args: Prisma.AdmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          delete: {
            args: Prisma.AdmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          update: {
            args: Prisma.AdmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          aggregate: {
            args: Prisma.AdmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmission>
          }
          groupBy: {
            args: Prisma.AdmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionCountAggregateOutputType> | number
          }
        }
      }
      AdmissionDocument: {
        payload: Prisma.$AdmissionDocumentPayload<ExtArgs>
        fields: Prisma.AdmissionDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload>
          }
          findFirst: {
            args: Prisma.AdmissionDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload>
          }
          findMany: {
            args: Prisma.AdmissionDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload>[]
          }
          create: {
            args: Prisma.AdmissionDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload>
          }
          createMany: {
            args: Prisma.AdmissionDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload>[]
          }
          delete: {
            args: Prisma.AdmissionDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload>
          }
          update: {
            args: Prisma.AdmissionDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionDocumentPayload>
          }
          aggregate: {
            args: Prisma.AdmissionDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmissionDocument>
          }
          groupBy: {
            args: Prisma.AdmissionDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionDocumentCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      ReportDocument: {
        payload: Prisma.$ReportDocumentPayload<ExtArgs>
        fields: Prisma.ReportDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload>
          }
          findFirst: {
            args: Prisma.ReportDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload>
          }
          findMany: {
            args: Prisma.ReportDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload>[]
          }
          create: {
            args: Prisma.ReportDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload>
          }
          createMany: {
            args: Prisma.ReportDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload>[]
          }
          delete: {
            args: Prisma.ReportDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload>
          }
          update: {
            args: Prisma.ReportDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ReportDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportDocumentPayload>
          }
          aggregate: {
            args: Prisma.ReportDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportDocument>
          }
          groupBy: {
            args: Prisma.ReportDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ReportDocumentCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      Training: {
        payload: Prisma.$TrainingPayload<ExtArgs>
        fields: Prisma.TrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findFirst: {
            args: Prisma.TrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          findMany: {
            args: Prisma.TrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          create: {
            args: Prisma.TrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          createMany: {
            args: Prisma.TrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>[]
          }
          delete: {
            args: Prisma.TrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          update: {
            args: Prisma.TrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingPayload>
          }
          aggregate: {
            args: Prisma.TrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraining>
          }
          groupBy: {
            args: Prisma.TrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingCountAggregateOutputType> | number
          }
        }
      }
      UserTraining: {
        payload: Prisma.$UserTrainingPayload<ExtArgs>
        fields: Prisma.UserTrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload>
          }
          findFirst: {
            args: Prisma.UserTrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload>
          }
          findMany: {
            args: Prisma.UserTrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload>[]
          }
          create: {
            args: Prisma.UserTrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload>
          }
          createMany: {
            args: Prisma.UserTrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload>[]
          }
          delete: {
            args: Prisma.UserTrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload>
          }
          update: {
            args: Prisma.UserTrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload>
          }
          deleteMany: {
            args: Prisma.UserTrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTrainingPayload>
          }
          aggregate: {
            args: Prisma.UserTrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTraining>
          }
          groupBy: {
            args: Prisma.UserTrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTrainingCountArgs<ExtArgs>
            result: $Utils.Optional<UserTrainingCountAggregateOutputType> | number
          }
        }
      }
      TrainingDocument: {
        payload: Prisma.$TrainingDocumentPayload<ExtArgs>
        fields: Prisma.TrainingDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          findFirst: {
            args: Prisma.TrainingDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          findMany: {
            args: Prisma.TrainingDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>[]
          }
          create: {
            args: Prisma.TrainingDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          createMany: {
            args: Prisma.TrainingDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>[]
          }
          delete: {
            args: Prisma.TrainingDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          update: {
            args: Prisma.TrainingDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDocumentPayload>
          }
          aggregate: {
            args: Prisma.TrainingDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingDocument>
          }
          groupBy: {
            args: Prisma.TrainingDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingDocumentCountAggregateOutputType> | number
          }
        }
      }
      Supporter: {
        payload: Prisma.$SupporterPayload<ExtArgs>
        fields: Prisma.SupporterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupporterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupporterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          findFirst: {
            args: Prisma.SupporterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupporterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          findMany: {
            args: Prisma.SupporterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>[]
          }
          create: {
            args: Prisma.SupporterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          createMany: {
            args: Prisma.SupporterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupporterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>[]
          }
          delete: {
            args: Prisma.SupporterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          update: {
            args: Prisma.SupporterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          deleteMany: {
            args: Prisma.SupporterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupporterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupporterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupporterPayload>
          }
          aggregate: {
            args: Prisma.SupporterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupporter>
          }
          groupBy: {
            args: Prisma.SupporterGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupporterGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupporterCountArgs<ExtArgs>
            result: $Utils.Optional<SupporterCountAggregateOutputType> | number
          }
        }
      }
      reports: {
        payload: Prisma.$reportsPayload<ExtArgs>
        fields: Prisma.reportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          findFirst: {
            args: Prisma.reportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          findMany: {
            args: Prisma.reportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>[]
          }
          create: {
            args: Prisma.reportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          createMany: {
            args: Prisma.reportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reportsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>[]
          }
          delete: {
            args: Prisma.reportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          update: {
            args: Prisma.reportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          deleteMany: {
            args: Prisma.reportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportsPayload>
          }
          aggregate: {
            args: Prisma.ReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReports>
          }
          groupBy: {
            args: Prisma.reportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportsCountArgs<ExtArgs>
            result: $Utils.Optional<ReportsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    receivedMessages: number
    sentMessages: number
    performance_evaluations_performance_evaluations_evaluator_idTousers: number
    performance_evaluations_performance_evaluations_user_idTousers: number
    reports: number
    tasks: number
    training_participations: number
    trainings: number
    groups: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    performance_evaluations_performance_evaluations_evaluator_idTousers?: boolean | UserCountOutputTypeCountPerformance_evaluations_performance_evaluations_evaluator_idTousersArgs
    performance_evaluations_performance_evaluations_user_idTousers?: boolean | UserCountOutputTypeCountPerformance_evaluations_performance_evaluations_user_idTousersArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    training_participations?: boolean | UserCountOutputTypeCountTraining_participationsArgs
    trainings?: boolean | UserCountOutputTypeCountTrainingsArgs
    groups?: boolean | UserCountOutputTypeCountGroupsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPerformance_evaluations_performance_evaluations_evaluator_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceEvaluationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPerformance_evaluations_performance_evaluations_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceEvaluationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTraining_participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrainingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    users: number
    admissions: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | PositionCountOutputTypeCountUsersArgs
    admissions?: boolean | PositionCountOutputTypeCountAdmissionsArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    users: number
    admissions: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | DepartmentCountOutputTypeCountUsersArgs
    admissions?: boolean | DepartmentCountOutputTypeCountAdmissionsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * Count Type AdmissionCountOutputType
   */

  export type AdmissionCountOutputType = {
    documents: number
  }

  export type AdmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | AdmissionCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionCountOutputType
     */
    select?: AdmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionDocumentWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    tasks: number
    users: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | GroupCountOutputTypeCountTasksArgs
    users?: boolean | GroupCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type TrainingCountOutputType
   */

  export type TrainingCountOutputType = {
    training_participations: number
    tasks: number
  }

  export type TrainingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    training_participations?: boolean | TrainingCountOutputTypeCountTraining_participationsArgs
    tasks?: boolean | TrainingCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingCountOutputType
     */
    select?: TrainingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountTraining_participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrainingWhereInput
  }

  /**
   * TrainingCountOutputType without action
   */
  export type TrainingCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type UserTrainingCountOutputType
   */

  export type UserTrainingCountOutputType = {
    documents: number
  }

  export type UserTrainingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | UserTrainingCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * UserTrainingCountOutputType without action
   */
  export type UserTrainingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrainingCountOutputType
     */
    select?: UserTrainingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserTrainingCountOutputType without action
   */
  export type UserTrainingCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDocumentWhereInput
  }


  /**
   * Count Type ReportsCountOutputType
   */

  export type ReportsCountOutputType = {
    documents: number
  }

  export type ReportsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | ReportsCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * ReportsCountOutputType without action
   */
  export type ReportsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportsCountOutputType
     */
    select?: ReportsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportsCountOutputType without action
   */
  export type ReportsCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDocumentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    name: string | null
    role: string | null
    isActive: boolean | null
    last_login: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    departmentId: string | null
    positionId: string | null
    surname: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    name: string | null
    role: string | null
    isActive: boolean | null
    last_login: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    departmentId: string | null
    positionId: string | null
    surname: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    name: number
    role: number
    isActive: number
    last_login: number
    createdAt: number
    updatedAt: number
    departmentId: number
    positionId: number
    surname: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    role?: true
    isActive?: true
    last_login?: true
    createdAt?: true
    updatedAt?: true
    departmentId?: true
    positionId?: true
    surname?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    role?: true
    isActive?: true
    last_login?: true
    createdAt?: true
    updatedAt?: true
    departmentId?: true
    positionId?: true
    surname?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    name?: true
    role?: true
    isActive?: true
    last_login?: true
    createdAt?: true
    updatedAt?: true
    departmentId?: true
    positionId?: true
    surname?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password_hash: string
    name: string
    role: string
    isActive: boolean
    last_login: Date | null
    createdAt: Date
    updatedAt: Date
    departmentId: string | null
    positionId: string | null
    surname: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    last_login?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentId?: boolean
    positionId?: boolean
    surname?: boolean
    admissions?: boolean | User$admissionsArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    performance_evaluations_performance_evaluations_evaluator_idTousers?: boolean | User$performance_evaluations_performance_evaluations_evaluator_idTousersArgs<ExtArgs>
    performance_evaluations_performance_evaluations_user_idTousers?: boolean | User$performance_evaluations_performance_evaluations_user_idTousersArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    training_participations?: boolean | User$training_participationsArgs<ExtArgs>
    trainings?: boolean | User$trainingsArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    last_login?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentId?: boolean
    positionId?: boolean
    surname?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    last_login?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departmentId?: boolean
    positionId?: boolean
    surname?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissions?: boolean | User$admissionsArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    performance_evaluations_performance_evaluations_evaluator_idTousers?: boolean | User$performance_evaluations_performance_evaluations_evaluator_idTousersArgs<ExtArgs>
    performance_evaluations_performance_evaluations_user_idTousers?: boolean | User$performance_evaluations_performance_evaluations_user_idTousersArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    training_participations?: boolean | User$training_participationsArgs<ExtArgs>
    trainings?: boolean | User$trainingsArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
    position?: boolean | User$positionArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admissions: Prisma.$AdmissionPayload<ExtArgs> | null
      receivedMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      sentMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      performance_evaluations_performance_evaluations_evaluator_idTousers: Prisma.$PerformanceEvaluationPayload<ExtArgs>[]
      performance_evaluations_performance_evaluations_user_idTousers: Prisma.$PerformanceEvaluationPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      reports: Prisma.$reportsPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      training_participations: Prisma.$UserTrainingPayload<ExtArgs>[]
      trainings: Prisma.$TrainingPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      position: Prisma.$PositionPayload<ExtArgs> | null
      groups: Prisma.$GroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string
      name: string
      role: string
      isActive: boolean
      last_login: Date | null
      createdAt: Date
      updatedAt: Date
      departmentId: string | null
      positionId: string | null
      surname: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admissions<T extends User$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$admissionsArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany"> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany"> | Null>
    performance_evaluations_performance_evaluations_evaluator_idTousers<T extends User$performance_evaluations_performance_evaluations_evaluator_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$performance_evaluations_performance_evaluations_evaluator_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "findMany"> | Null>
    performance_evaluations_performance_evaluations_user_idTousers<T extends User$performance_evaluations_performance_evaluations_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$performance_evaluations_performance_evaluations_user_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "findMany"> | Null>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    training_participations<T extends User$training_participationsArgs<ExtArgs> = {}>(args?: Subset<T, User$training_participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "findMany"> | Null>
    trainings<T extends User$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, User$trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany"> | Null>
    department<T extends User$departmentArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    position<T extends User$positionArgs<ExtArgs> = {}>(args?: Subset<T, User$positionArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    groups<T extends User$groupsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password_hash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly last_login: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly departmentId: FieldRef<"User", 'String'>
    readonly positionId: FieldRef<"User", 'String'>
    readonly surname: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.admissions
   */
  export type User$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.performance_evaluations_performance_evaluations_evaluator_idTousers
   */
  export type User$performance_evaluations_performance_evaluations_evaluator_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    where?: PerformanceEvaluationWhereInput
    orderBy?: PerformanceEvaluationOrderByWithRelationInput | PerformanceEvaluationOrderByWithRelationInput[]
    cursor?: PerformanceEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceEvaluationScalarFieldEnum | PerformanceEvaluationScalarFieldEnum[]
  }

  /**
   * User.performance_evaluations_performance_evaluations_user_idTousers
   */
  export type User$performance_evaluations_performance_evaluations_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    where?: PerformanceEvaluationWhereInput
    orderBy?: PerformanceEvaluationOrderByWithRelationInput | PerformanceEvaluationOrderByWithRelationInput[]
    cursor?: PerformanceEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceEvaluationScalarFieldEnum | PerformanceEvaluationScalarFieldEnum[]
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    where?: reportsWhereInput
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    cursor?: reportsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.training_participations
   */
  export type User$training_participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    where?: UserTrainingWhereInput
    orderBy?: UserTrainingOrderByWithRelationInput | UserTrainingOrderByWithRelationInput[]
    cursor?: UserTrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTrainingScalarFieldEnum | UserTrainingScalarFieldEnum[]
  }

  /**
   * User.trainings
   */
  export type User$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    cursor?: TrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * User.department
   */
  export type User$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.position
   */
  export type User$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
  }

  /**
   * User.groups
   */
  export type User$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    address: string | null
    phone: string | null
    birthDate: Date | null
    document: string | null
    emergencyContact: string | null
    avatar: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    user_id: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    address: string | null
    phone: string | null
    birthDate: Date | null
    document: string | null
    emergencyContact: string | null
    avatar: string | null
    bio: string | null
    createdAt: Date | null
    updatedAt: Date | null
    user_id: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    address: number
    phone: number
    birthDate: number
    document: number
    emergencyContact: number
    avatar: number
    bio: number
    createdAt: number
    updatedAt: number
    user_id: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    address?: true
    phone?: true
    birthDate?: true
    document?: true
    emergencyContact?: true
    avatar?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    user_id?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    address?: true
    phone?: true
    birthDate?: true
    document?: true
    emergencyContact?: true
    avatar?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    user_id?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    address?: true
    phone?: true
    birthDate?: true
    document?: true
    emergencyContact?: true
    avatar?: true
    bio?: true
    createdAt?: true
    updatedAt?: true
    user_id?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    address: string | null
    phone: string | null
    birthDate: Date | null
    document: string | null
    emergencyContact: string | null
    avatar: string | null
    bio: string | null
    createdAt: Date
    updatedAt: Date
    user_id: string
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    phone?: boolean
    birthDate?: boolean
    document?: boolean
    emergencyContact?: boolean
    avatar?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    address?: boolean
    phone?: boolean
    birthDate?: boolean
    document?: boolean
    emergencyContact?: boolean
    avatar?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    address?: boolean
    phone?: boolean
    birthDate?: boolean
    document?: boolean
    emergencyContact?: boolean
    avatar?: boolean
    bio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user_id?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      address: string | null
      phone: string | null
      birthDate: Date | null
      document: string | null
      emergencyContact: string | null
      avatar: string | null
      bio: string | null
      createdAt: Date
      updatedAt: Date
      user_id: string
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly address: FieldRef<"Profile", 'String'>
    readonly phone: FieldRef<"Profile", 'String'>
    readonly birthDate: FieldRef<"Profile", 'DateTime'>
    readonly document: FieldRef<"Profile", 'String'>
    readonly emergencyContact: FieldRef<"Profile", 'String'>
    readonly avatar: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly user_id: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    salary: number | null
  }

  export type PositionSumAggregateOutputType = {
    salary: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    salary: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    salary: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    salary: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    salary?: true
  }

  export type PositionSumAggregateInputType = {
    salary?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    salary?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    salary?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    salary?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithAggregationInput | PositionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    salary: number | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    salary?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Position$usersArgs<ExtArgs>
    admissions?: boolean | Position$admissionsArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    salary?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["position"]>

  export type PositionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    salary?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Position$usersArgs<ExtArgs>
    admissions?: boolean | Position$admissionsArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Position"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      salary: number | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type PositionGetPayload<S extends boolean | null | undefined | PositionDefaultArgs> = $Result.GetResult<Prisma.$PositionPayload, S>

  type PositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PositionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Position'], meta: { name: 'Position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionFindUniqueArgs>(args: SelectSubset<T, PositionFindUniqueArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionFindFirstArgs>(args?: SelectSubset<T, PositionFindFirstArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionFindManyArgs>(args?: SelectSubset<T, PositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends PositionCreateArgs>(args: SelectSubset<T, PositionCreateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Positions.
     * @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionCreateManyArgs>(args?: SelectSubset<T, PositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Positions and returns the data saved in the database.
     * @param {PositionCreateManyAndReturnArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PositionCreateManyAndReturnArgs>(args?: SelectSubset<T, PositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends PositionDeleteArgs>(args: SelectSubset<T, PositionDeleteArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionUpdateArgs>(args: SelectSubset<T, PositionUpdateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionDeleteManyArgs>(args?: SelectSubset<T, PositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionUpdateManyArgs>(args: SelectSubset<T, PositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends PositionUpsertArgs>(args: SelectSubset<T, PositionUpsertArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Position model
   */
  readonly fields: PositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Position$usersArgs<ExtArgs> = {}>(args?: Subset<T, Position$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    admissions<T extends Position$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Position$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Position model
   */ 
  interface PositionFieldRefs {
    readonly id: FieldRef<"Position", 'String'>
    readonly name: FieldRef<"Position", 'String'>
    readonly description: FieldRef<"Position", 'String'>
    readonly salary: FieldRef<"Position", 'Float'>
    readonly status: FieldRef<"Position", 'String'>
    readonly createdAt: FieldRef<"Position", 'DateTime'>
    readonly updatedAt: FieldRef<"Position", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findMany
   */
  export type PositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position create
   */
  export type PositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }

  /**
   * Position createMany
   */
  export type PositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position createManyAndReturn
   */
  export type PositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position update
   */
  export type PositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
  }

  /**
   * Position upsert
   */
  export type PositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }

  /**
   * Position delete
   */
  export type PositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
  }

  /**
   * Position.users
   */
  export type Position$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Position.admissions
   */
  export type Position$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Position without action
   */
  export type PositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    managerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Department$usersArgs<ExtArgs>
    admissions?: boolean | Department$admissionsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Department$usersArgs<ExtArgs>
    admissions?: boolean | Department$admissionsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      managerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Department$usersArgs<ExtArgs> = {}>(args?: Subset<T, Department$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    admissions<T extends Department$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Department$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly managerId: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.users
   */
  export type Department$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department.admissions
   */
  export type Department$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceEvaluation
   */

  export type AggregatePerformanceEvaluation = {
    _count: PerformanceEvaluationCountAggregateOutputType | null
    _avg: PerformanceEvaluationAvgAggregateOutputType | null
    _sum: PerformanceEvaluationSumAggregateOutputType | null
    _min: PerformanceEvaluationMinAggregateOutputType | null
    _max: PerformanceEvaluationMaxAggregateOutputType | null
  }

  export type PerformanceEvaluationAvgAggregateOutputType = {
    score: number | null
  }

  export type PerformanceEvaluationSumAggregateOutputType = {
    score: number | null
  }

  export type PerformanceEvaluationMinAggregateOutputType = {
    id: string | null
    period: string | null
    score: number | null
    goals: string | null
    achievements: string | null
    feedback: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    evaluator_id: string | null
    user_id: string | null
  }

  export type PerformanceEvaluationMaxAggregateOutputType = {
    id: string | null
    period: string | null
    score: number | null
    goals: string | null
    achievements: string | null
    feedback: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    evaluator_id: string | null
    user_id: string | null
  }

  export type PerformanceEvaluationCountAggregateOutputType = {
    id: number
    period: number
    score: number
    goals: number
    achievements: number
    feedback: number
    status: number
    createdAt: number
    updatedAt: number
    evaluator_id: number
    user_id: number
    _all: number
  }


  export type PerformanceEvaluationAvgAggregateInputType = {
    score?: true
  }

  export type PerformanceEvaluationSumAggregateInputType = {
    score?: true
  }

  export type PerformanceEvaluationMinAggregateInputType = {
    id?: true
    period?: true
    score?: true
    goals?: true
    achievements?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    evaluator_id?: true
    user_id?: true
  }

  export type PerformanceEvaluationMaxAggregateInputType = {
    id?: true
    period?: true
    score?: true
    goals?: true
    achievements?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    evaluator_id?: true
    user_id?: true
  }

  export type PerformanceEvaluationCountAggregateInputType = {
    id?: true
    period?: true
    score?: true
    goals?: true
    achievements?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    evaluator_id?: true
    user_id?: true
    _all?: true
  }

  export type PerformanceEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceEvaluation to aggregate.
     */
    where?: PerformanceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceEvaluations to fetch.
     */
    orderBy?: PerformanceEvaluationOrderByWithRelationInput | PerformanceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceEvaluations
    **/
    _count?: true | PerformanceEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceEvaluationMaxAggregateInputType
  }

  export type GetPerformanceEvaluationAggregateType<T extends PerformanceEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceEvaluation[P]>
      : GetScalarType<T[P], AggregatePerformanceEvaluation[P]>
  }




  export type PerformanceEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceEvaluationWhereInput
    orderBy?: PerformanceEvaluationOrderByWithAggregationInput | PerformanceEvaluationOrderByWithAggregationInput[]
    by: PerformanceEvaluationScalarFieldEnum[] | PerformanceEvaluationScalarFieldEnum
    having?: PerformanceEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceEvaluationCountAggregateInputType | true
    _avg?: PerformanceEvaluationAvgAggregateInputType
    _sum?: PerformanceEvaluationSumAggregateInputType
    _min?: PerformanceEvaluationMinAggregateInputType
    _max?: PerformanceEvaluationMaxAggregateInputType
  }

  export type PerformanceEvaluationGroupByOutputType = {
    id: string
    period: string
    score: number
    goals: string | null
    achievements: string | null
    feedback: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    evaluator_id: string
    user_id: string
    _count: PerformanceEvaluationCountAggregateOutputType | null
    _avg: PerformanceEvaluationAvgAggregateOutputType | null
    _sum: PerformanceEvaluationSumAggregateOutputType | null
    _min: PerformanceEvaluationMinAggregateOutputType | null
    _max: PerformanceEvaluationMaxAggregateOutputType | null
  }

  type GetPerformanceEvaluationGroupByPayload<T extends PerformanceEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    score?: boolean
    goals?: boolean
    achievements?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluator_id?: boolean
    user_id?: boolean
    users_performance_evaluations_evaluator_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_performance_evaluations_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceEvaluation"]>

  export type PerformanceEvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    period?: boolean
    score?: boolean
    goals?: boolean
    achievements?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluator_id?: boolean
    user_id?: boolean
    users_performance_evaluations_evaluator_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_performance_evaluations_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceEvaluation"]>

  export type PerformanceEvaluationSelectScalar = {
    id?: boolean
    period?: boolean
    score?: boolean
    goals?: boolean
    achievements?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluator_id?: boolean
    user_id?: boolean
  }

  export type PerformanceEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_performance_evaluations_evaluator_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_performance_evaluations_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PerformanceEvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_performance_evaluations_evaluator_idTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_performance_evaluations_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PerformanceEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceEvaluation"
    objects: {
      users_performance_evaluations_evaluator_idTousers: Prisma.$UserPayload<ExtArgs>
      users_performance_evaluations_user_idTousers: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      period: string
      score: number
      goals: string | null
      achievements: string | null
      feedback: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      evaluator_id: string
      user_id: string
    }, ExtArgs["result"]["performanceEvaluation"]>
    composites: {}
  }

  type PerformanceEvaluationGetPayload<S extends boolean | null | undefined | PerformanceEvaluationDefaultArgs> = $Result.GetResult<Prisma.$PerformanceEvaluationPayload, S>

  type PerformanceEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerformanceEvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PerformanceEvaluationCountAggregateInputType | true
    }

  export interface PerformanceEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceEvaluation'], meta: { name: 'PerformanceEvaluation' } }
    /**
     * Find zero or one PerformanceEvaluation that matches the filter.
     * @param {PerformanceEvaluationFindUniqueArgs} args - Arguments to find a PerformanceEvaluation
     * @example
     * // Get one PerformanceEvaluation
     * const performanceEvaluation = await prisma.performanceEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceEvaluationFindUniqueArgs>(args: SelectSubset<T, PerformanceEvaluationFindUniqueArgs<ExtArgs>>): Prisma__PerformanceEvaluationClient<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PerformanceEvaluation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PerformanceEvaluationFindUniqueOrThrowArgs} args - Arguments to find a PerformanceEvaluation
     * @example
     * // Get one PerformanceEvaluation
     * const performanceEvaluation = await prisma.performanceEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceEvaluationClient<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PerformanceEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceEvaluationFindFirstArgs} args - Arguments to find a PerformanceEvaluation
     * @example
     * // Get one PerformanceEvaluation
     * const performanceEvaluation = await prisma.performanceEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceEvaluationFindFirstArgs>(args?: SelectSubset<T, PerformanceEvaluationFindFirstArgs<ExtArgs>>): Prisma__PerformanceEvaluationClient<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PerformanceEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceEvaluationFindFirstOrThrowArgs} args - Arguments to find a PerformanceEvaluation
     * @example
     * // Get one PerformanceEvaluation
     * const performanceEvaluation = await prisma.performanceEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceEvaluationClient<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PerformanceEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceEvaluations
     * const performanceEvaluations = await prisma.performanceEvaluation.findMany()
     * 
     * // Get first 10 PerformanceEvaluations
     * const performanceEvaluations = await prisma.performanceEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceEvaluationWithIdOnly = await prisma.performanceEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceEvaluationFindManyArgs>(args?: SelectSubset<T, PerformanceEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PerformanceEvaluation.
     * @param {PerformanceEvaluationCreateArgs} args - Arguments to create a PerformanceEvaluation.
     * @example
     * // Create one PerformanceEvaluation
     * const PerformanceEvaluation = await prisma.performanceEvaluation.create({
     *   data: {
     *     // ... data to create a PerformanceEvaluation
     *   }
     * })
     * 
     */
    create<T extends PerformanceEvaluationCreateArgs>(args: SelectSubset<T, PerformanceEvaluationCreateArgs<ExtArgs>>): Prisma__PerformanceEvaluationClient<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PerformanceEvaluations.
     * @param {PerformanceEvaluationCreateManyArgs} args - Arguments to create many PerformanceEvaluations.
     * @example
     * // Create many PerformanceEvaluations
     * const performanceEvaluation = await prisma.performanceEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceEvaluationCreateManyArgs>(args?: SelectSubset<T, PerformanceEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceEvaluations and returns the data saved in the database.
     * @param {PerformanceEvaluationCreateManyAndReturnArgs} args - Arguments to create many PerformanceEvaluations.
     * @example
     * // Create many PerformanceEvaluations
     * const performanceEvaluation = await prisma.performanceEvaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceEvaluations and only return the `id`
     * const performanceEvaluationWithIdOnly = await prisma.performanceEvaluation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceEvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceEvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PerformanceEvaluation.
     * @param {PerformanceEvaluationDeleteArgs} args - Arguments to delete one PerformanceEvaluation.
     * @example
     * // Delete one PerformanceEvaluation
     * const PerformanceEvaluation = await prisma.performanceEvaluation.delete({
     *   where: {
     *     // ... filter to delete one PerformanceEvaluation
     *   }
     * })
     * 
     */
    delete<T extends PerformanceEvaluationDeleteArgs>(args: SelectSubset<T, PerformanceEvaluationDeleteArgs<ExtArgs>>): Prisma__PerformanceEvaluationClient<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PerformanceEvaluation.
     * @param {PerformanceEvaluationUpdateArgs} args - Arguments to update one PerformanceEvaluation.
     * @example
     * // Update one PerformanceEvaluation
     * const performanceEvaluation = await prisma.performanceEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceEvaluationUpdateArgs>(args: SelectSubset<T, PerformanceEvaluationUpdateArgs<ExtArgs>>): Prisma__PerformanceEvaluationClient<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PerformanceEvaluations.
     * @param {PerformanceEvaluationDeleteManyArgs} args - Arguments to filter PerformanceEvaluations to delete.
     * @example
     * // Delete a few PerformanceEvaluations
     * const { count } = await prisma.performanceEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceEvaluationDeleteManyArgs>(args?: SelectSubset<T, PerformanceEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceEvaluations
     * const performanceEvaluation = await prisma.performanceEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceEvaluationUpdateManyArgs>(args: SelectSubset<T, PerformanceEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceEvaluation.
     * @param {PerformanceEvaluationUpsertArgs} args - Arguments to update or create a PerformanceEvaluation.
     * @example
     * // Update or create a PerformanceEvaluation
     * const performanceEvaluation = await prisma.performanceEvaluation.upsert({
     *   create: {
     *     // ... data to create a PerformanceEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceEvaluationUpsertArgs>(args: SelectSubset<T, PerformanceEvaluationUpsertArgs<ExtArgs>>): Prisma__PerformanceEvaluationClient<$Result.GetResult<Prisma.$PerformanceEvaluationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PerformanceEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceEvaluationCountArgs} args - Arguments to filter PerformanceEvaluations to count.
     * @example
     * // Count the number of PerformanceEvaluations
     * const count = await prisma.performanceEvaluation.count({
     *   where: {
     *     // ... the filter for the PerformanceEvaluations we want to count
     *   }
     * })
    **/
    count<T extends PerformanceEvaluationCountArgs>(
      args?: Subset<T, PerformanceEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceEvaluationAggregateArgs>(args: Subset<T, PerformanceEvaluationAggregateArgs>): Prisma.PrismaPromise<GetPerformanceEvaluationAggregateType<T>>

    /**
     * Group by PerformanceEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceEvaluation model
   */
  readonly fields: PerformanceEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_performance_evaluations_evaluator_idTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users_performance_evaluations_user_idTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceEvaluation model
   */ 
  interface PerformanceEvaluationFieldRefs {
    readonly id: FieldRef<"PerformanceEvaluation", 'String'>
    readonly period: FieldRef<"PerformanceEvaluation", 'String'>
    readonly score: FieldRef<"PerformanceEvaluation", 'Float'>
    readonly goals: FieldRef<"PerformanceEvaluation", 'String'>
    readonly achievements: FieldRef<"PerformanceEvaluation", 'String'>
    readonly feedback: FieldRef<"PerformanceEvaluation", 'String'>
    readonly status: FieldRef<"PerformanceEvaluation", 'String'>
    readonly createdAt: FieldRef<"PerformanceEvaluation", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceEvaluation", 'DateTime'>
    readonly evaluator_id: FieldRef<"PerformanceEvaluation", 'String'>
    readonly user_id: FieldRef<"PerformanceEvaluation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceEvaluation findUnique
   */
  export type PerformanceEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceEvaluation to fetch.
     */
    where: PerformanceEvaluationWhereUniqueInput
  }

  /**
   * PerformanceEvaluation findUniqueOrThrow
   */
  export type PerformanceEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceEvaluation to fetch.
     */
    where: PerformanceEvaluationWhereUniqueInput
  }

  /**
   * PerformanceEvaluation findFirst
   */
  export type PerformanceEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceEvaluation to fetch.
     */
    where?: PerformanceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceEvaluations to fetch.
     */
    orderBy?: PerformanceEvaluationOrderByWithRelationInput | PerformanceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceEvaluations.
     */
    cursor?: PerformanceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceEvaluations.
     */
    distinct?: PerformanceEvaluationScalarFieldEnum | PerformanceEvaluationScalarFieldEnum[]
  }

  /**
   * PerformanceEvaluation findFirstOrThrow
   */
  export type PerformanceEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceEvaluation to fetch.
     */
    where?: PerformanceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceEvaluations to fetch.
     */
    orderBy?: PerformanceEvaluationOrderByWithRelationInput | PerformanceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceEvaluations.
     */
    cursor?: PerformanceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceEvaluations.
     */
    distinct?: PerformanceEvaluationScalarFieldEnum | PerformanceEvaluationScalarFieldEnum[]
  }

  /**
   * PerformanceEvaluation findMany
   */
  export type PerformanceEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceEvaluations to fetch.
     */
    where?: PerformanceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceEvaluations to fetch.
     */
    orderBy?: PerformanceEvaluationOrderByWithRelationInput | PerformanceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceEvaluations.
     */
    cursor?: PerformanceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceEvaluations.
     */
    skip?: number
    distinct?: PerformanceEvaluationScalarFieldEnum | PerformanceEvaluationScalarFieldEnum[]
  }

  /**
   * PerformanceEvaluation create
   */
  export type PerformanceEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceEvaluation.
     */
    data: XOR<PerformanceEvaluationCreateInput, PerformanceEvaluationUncheckedCreateInput>
  }

  /**
   * PerformanceEvaluation createMany
   */
  export type PerformanceEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceEvaluations.
     */
    data: PerformanceEvaluationCreateManyInput | PerformanceEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceEvaluation createManyAndReturn
   */
  export type PerformanceEvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PerformanceEvaluations.
     */
    data: PerformanceEvaluationCreateManyInput | PerformanceEvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceEvaluation update
   */
  export type PerformanceEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceEvaluation.
     */
    data: XOR<PerformanceEvaluationUpdateInput, PerformanceEvaluationUncheckedUpdateInput>
    /**
     * Choose, which PerformanceEvaluation to update.
     */
    where: PerformanceEvaluationWhereUniqueInput
  }

  /**
   * PerformanceEvaluation updateMany
   */
  export type PerformanceEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceEvaluations.
     */
    data: XOR<PerformanceEvaluationUpdateManyMutationInput, PerformanceEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceEvaluations to update
     */
    where?: PerformanceEvaluationWhereInput
  }

  /**
   * PerformanceEvaluation upsert
   */
  export type PerformanceEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceEvaluation to update in case it exists.
     */
    where: PerformanceEvaluationWhereUniqueInput
    /**
     * In case the PerformanceEvaluation found by the `where` argument doesn't exist, create a new PerformanceEvaluation with this data.
     */
    create: XOR<PerformanceEvaluationCreateInput, PerformanceEvaluationUncheckedCreateInput>
    /**
     * In case the PerformanceEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceEvaluationUpdateInput, PerformanceEvaluationUncheckedUpdateInput>
  }

  /**
   * PerformanceEvaluation delete
   */
  export type PerformanceEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
    /**
     * Filter which PerformanceEvaluation to delete.
     */
    where: PerformanceEvaluationWhereUniqueInput
  }

  /**
   * PerformanceEvaluation deleteMany
   */
  export type PerformanceEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceEvaluations to delete
     */
    where?: PerformanceEvaluationWhereInput
  }

  /**
   * PerformanceEvaluation without action
   */
  export type PerformanceEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceEvaluation
     */
    select?: PerformanceEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Admission
   */

  export type AggregateAdmission = {
    _count: AdmissionCountAggregateOutputType | null
    _avg: AdmissionAvgAggregateOutputType | null
    _sum: AdmissionSumAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  export type AdmissionAvgAggregateOutputType = {
    salary: number | null
  }

  export type AdmissionSumAggregateOutputType = {
    salary: number | null
  }

  export type AdmissionMinAggregateOutputType = {
    id: string | null
    hireDate: Date | null
    contractType: string | null
    salary: number | null
    benefits: string | null
    terminationDate: Date | null
    terminationReason: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    user_id: string | null
    position_id: string | null
    department_id: string | null
  }

  export type AdmissionMaxAggregateOutputType = {
    id: string | null
    hireDate: Date | null
    contractType: string | null
    salary: number | null
    benefits: string | null
    terminationDate: Date | null
    terminationReason: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    user_id: string | null
    position_id: string | null
    department_id: string | null
  }

  export type AdmissionCountAggregateOutputType = {
    id: number
    hireDate: number
    contractType: number
    salary: number
    benefits: number
    terminationDate: number
    terminationReason: number
    status: number
    createdAt: number
    updatedAt: number
    user_id: number
    position_id: number
    department_id: number
    _all: number
  }


  export type AdmissionAvgAggregateInputType = {
    salary?: true
  }

  export type AdmissionSumAggregateInputType = {
    salary?: true
  }

  export type AdmissionMinAggregateInputType = {
    id?: true
    hireDate?: true
    contractType?: true
    salary?: true
    benefits?: true
    terminationDate?: true
    terminationReason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    user_id?: true
    position_id?: true
    department_id?: true
  }

  export type AdmissionMaxAggregateInputType = {
    id?: true
    hireDate?: true
    contractType?: true
    salary?: true
    benefits?: true
    terminationDate?: true
    terminationReason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    user_id?: true
    position_id?: true
    department_id?: true
  }

  export type AdmissionCountAggregateInputType = {
    id?: true
    hireDate?: true
    contractType?: true
    salary?: true
    benefits?: true
    terminationDate?: true
    terminationReason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    user_id?: true
    position_id?: true
    department_id?: true
    _all?: true
  }

  export type AdmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admission to aggregate.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admissions
    **/
    _count?: true | AdmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionMaxAggregateInputType
  }

  export type GetAdmissionAggregateType<T extends AdmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmission[P]>
      : GetScalarType<T[P], AggregateAdmission[P]>
  }




  export type AdmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithAggregationInput | AdmissionOrderByWithAggregationInput[]
    by: AdmissionScalarFieldEnum[] | AdmissionScalarFieldEnum
    having?: AdmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionCountAggregateInputType | true
    _avg?: AdmissionAvgAggregateInputType
    _sum?: AdmissionSumAggregateInputType
    _min?: AdmissionMinAggregateInputType
    _max?: AdmissionMaxAggregateInputType
  }

  export type AdmissionGroupByOutputType = {
    id: string
    hireDate: Date
    contractType: string
    salary: number | null
    benefits: string | null
    terminationDate: Date | null
    terminationReason: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    user_id: string
    position_id: string | null
    department_id: string | null
    _count: AdmissionCountAggregateOutputType | null
    _avg: AdmissionAvgAggregateOutputType | null
    _sum: AdmissionSumAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  type GetAdmissionGroupByPayload<T extends AdmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hireDate?: boolean
    contractType?: boolean
    salary?: boolean
    benefits?: boolean
    terminationDate?: boolean
    terminationReason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user_id?: boolean
    position_id?: boolean
    department_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Admission$positionArgs<ExtArgs>
    department?: boolean | Admission$departmentArgs<ExtArgs>
    documents?: boolean | Admission$documentsArgs<ExtArgs>
    _count?: boolean | AdmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hireDate?: boolean
    contractType?: boolean
    salary?: boolean
    benefits?: boolean
    terminationDate?: boolean
    terminationReason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user_id?: boolean
    position_id?: boolean
    department_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Admission$positionArgs<ExtArgs>
    department?: boolean | Admission$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectScalar = {
    id?: boolean
    hireDate?: boolean
    contractType?: boolean
    salary?: boolean
    benefits?: boolean
    terminationDate?: boolean
    terminationReason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user_id?: boolean
    position_id?: boolean
    department_id?: boolean
  }

  export type AdmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Admission$positionArgs<ExtArgs>
    department?: boolean | Admission$departmentArgs<ExtArgs>
    documents?: boolean | Admission$documentsArgs<ExtArgs>
    _count?: boolean | AdmissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    position?: boolean | Admission$positionArgs<ExtArgs>
    department?: boolean | Admission$departmentArgs<ExtArgs>
  }

  export type $AdmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      position: Prisma.$PositionPayload<ExtArgs> | null
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      documents: Prisma.$AdmissionDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hireDate: Date
      contractType: string
      salary: number | null
      benefits: string | null
      terminationDate: Date | null
      terminationReason: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      user_id: string
      position_id: string | null
      department_id: string | null
    }, ExtArgs["result"]["admission"]>
    composites: {}
  }

  type AdmissionGetPayload<S extends boolean | null | undefined | AdmissionDefaultArgs> = $Result.GetResult<Prisma.$AdmissionPayload, S>

  type AdmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionCountAggregateInputType | true
    }

  export interface AdmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admission'], meta: { name: 'Admission' } }
    /**
     * Find zero or one Admission that matches the filter.
     * @param {AdmissionFindUniqueArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionFindUniqueArgs>(args: SelectSubset<T, AdmissionFindUniqueArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionFindUniqueOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionFindFirstArgs>(args?: SelectSubset<T, AdmissionFindFirstArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admissions
     * const admissions = await prisma.admission.findMany()
     * 
     * // Get first 10 Admissions
     * const admissions = await prisma.admission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionWithIdOnly = await prisma.admission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionFindManyArgs>(args?: SelectSubset<T, AdmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admission.
     * @param {AdmissionCreateArgs} args - Arguments to create a Admission.
     * @example
     * // Create one Admission
     * const Admission = await prisma.admission.create({
     *   data: {
     *     // ... data to create a Admission
     *   }
     * })
     * 
     */
    create<T extends AdmissionCreateArgs>(args: SelectSubset<T, AdmissionCreateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admissions.
     * @param {AdmissionCreateManyArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionCreateManyArgs>(args?: SelectSubset<T, AdmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admissions and returns the data saved in the database.
     * @param {AdmissionCreateManyAndReturnArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admissions and only return the `id`
     * const admissionWithIdOnly = await prisma.admission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admission.
     * @param {AdmissionDeleteArgs} args - Arguments to delete one Admission.
     * @example
     * // Delete one Admission
     * const Admission = await prisma.admission.delete({
     *   where: {
     *     // ... filter to delete one Admission
     *   }
     * })
     * 
     */
    delete<T extends AdmissionDeleteArgs>(args: SelectSubset<T, AdmissionDeleteArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admission.
     * @param {AdmissionUpdateArgs} args - Arguments to update one Admission.
     * @example
     * // Update one Admission
     * const admission = await prisma.admission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionUpdateArgs>(args: SelectSubset<T, AdmissionUpdateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admissions.
     * @param {AdmissionDeleteManyArgs} args - Arguments to filter Admissions to delete.
     * @example
     * // Delete a few Admissions
     * const { count } = await prisma.admission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionDeleteManyArgs>(args?: SelectSubset<T, AdmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionUpdateManyArgs>(args: SelectSubset<T, AdmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admission.
     * @param {AdmissionUpsertArgs} args - Arguments to update or create a Admission.
     * @example
     * // Update or create a Admission
     * const admission = await prisma.admission.upsert({
     *   create: {
     *     // ... data to create a Admission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admission we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionUpsertArgs>(args: SelectSubset<T, AdmissionUpsertArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionCountArgs} args - Arguments to filter Admissions to count.
     * @example
     * // Count the number of Admissions
     * const count = await prisma.admission.count({
     *   where: {
     *     // ... the filter for the Admissions we want to count
     *   }
     * })
    **/
    count<T extends AdmissionCountArgs>(
      args?: Subset<T, AdmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionAggregateArgs>(args: Subset<T, AdmissionAggregateArgs>): Prisma.PrismaPromise<GetAdmissionAggregateType<T>>

    /**
     * Group by Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admission model
   */
  readonly fields: AdmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    position<T extends Admission$positionArgs<ExtArgs> = {}>(args?: Subset<T, Admission$positionArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    department<T extends Admission$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Admission$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    documents<T extends Admission$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Admission$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admission model
   */ 
  interface AdmissionFieldRefs {
    readonly id: FieldRef<"Admission", 'String'>
    readonly hireDate: FieldRef<"Admission", 'DateTime'>
    readonly contractType: FieldRef<"Admission", 'String'>
    readonly salary: FieldRef<"Admission", 'Float'>
    readonly benefits: FieldRef<"Admission", 'String'>
    readonly terminationDate: FieldRef<"Admission", 'DateTime'>
    readonly terminationReason: FieldRef<"Admission", 'String'>
    readonly status: FieldRef<"Admission", 'String'>
    readonly createdAt: FieldRef<"Admission", 'DateTime'>
    readonly updatedAt: FieldRef<"Admission", 'DateTime'>
    readonly user_id: FieldRef<"Admission", 'String'>
    readonly position_id: FieldRef<"Admission", 'String'>
    readonly department_id: FieldRef<"Admission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admission findUnique
   */
  export type AdmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findUniqueOrThrow
   */
  export type AdmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findFirst
   */
  export type AdmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findFirstOrThrow
   */
  export type AdmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findMany
   */
  export type AdmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admissions to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission create
   */
  export type AdmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Admission.
     */
    data: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
  }

  /**
   * Admission createMany
   */
  export type AdmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admission createManyAndReturn
   */
  export type AdmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admission update
   */
  export type AdmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Admission.
     */
    data: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
    /**
     * Choose, which Admission to update.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission updateMany
   */
  export type AdmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admissions.
     */
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyInput>
    /**
     * Filter which Admissions to update
     */
    where?: AdmissionWhereInput
  }

  /**
   * Admission upsert
   */
  export type AdmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Admission to update in case it exists.
     */
    where: AdmissionWhereUniqueInput
    /**
     * In case the Admission found by the `where` argument doesn't exist, create a new Admission with this data.
     */
    create: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
    /**
     * In case the Admission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
  }

  /**
   * Admission delete
   */
  export type AdmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter which Admission to delete.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission deleteMany
   */
  export type AdmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admissions to delete
     */
    where?: AdmissionWhereInput
  }

  /**
   * Admission.position
   */
  export type Admission$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
  }

  /**
   * Admission.department
   */
  export type Admission$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Admission.documents
   */
  export type Admission$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    where?: AdmissionDocumentWhereInput
    orderBy?: AdmissionDocumentOrderByWithRelationInput | AdmissionDocumentOrderByWithRelationInput[]
    cursor?: AdmissionDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionDocumentScalarFieldEnum | AdmissionDocumentScalarFieldEnum[]
  }

  /**
   * Admission without action
   */
  export type AdmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
  }


  /**
   * Model AdmissionDocument
   */

  export type AggregateAdmissionDocument = {
    _count: AdmissionDocumentCountAggregateOutputType | null
    _avg: AdmissionDocumentAvgAggregateOutputType | null
    _sum: AdmissionDocumentSumAggregateOutputType | null
    _min: AdmissionDocumentMinAggregateOutputType | null
    _max: AdmissionDocumentMaxAggregateOutputType | null
  }

  export type AdmissionDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type AdmissionDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type AdmissionDocumentMinAggregateOutputType = {
    id: string | null
    admissionId: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    filePath: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type AdmissionDocumentMaxAggregateOutputType = {
    id: string | null
    admissionId: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    filePath: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type AdmissionDocumentCountAggregateOutputType = {
    id: number
    admissionId: number
    fileName: number
    fileType: number
    fileSize: number
    filePath: number
    uploadedAt: number
    uploadedBy: number
    _all: number
  }


  export type AdmissionDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type AdmissionDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type AdmissionDocumentMinAggregateInputType = {
    id?: true
    admissionId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type AdmissionDocumentMaxAggregateInputType = {
    id?: true
    admissionId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type AdmissionDocumentCountAggregateInputType = {
    id?: true
    admissionId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadedAt?: true
    uploadedBy?: true
    _all?: true
  }

  export type AdmissionDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionDocument to aggregate.
     */
    where?: AdmissionDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionDocuments to fetch.
     */
    orderBy?: AdmissionDocumentOrderByWithRelationInput | AdmissionDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmissionDocuments
    **/
    _count?: true | AdmissionDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdmissionDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdmissionDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionDocumentMaxAggregateInputType
  }

  export type GetAdmissionDocumentAggregateType<T extends AdmissionDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmissionDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmissionDocument[P]>
      : GetScalarType<T[P], AggregateAdmissionDocument[P]>
  }




  export type AdmissionDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionDocumentWhereInput
    orderBy?: AdmissionDocumentOrderByWithAggregationInput | AdmissionDocumentOrderByWithAggregationInput[]
    by: AdmissionDocumentScalarFieldEnum[] | AdmissionDocumentScalarFieldEnum
    having?: AdmissionDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionDocumentCountAggregateInputType | true
    _avg?: AdmissionDocumentAvgAggregateInputType
    _sum?: AdmissionDocumentSumAggregateInputType
    _min?: AdmissionDocumentMinAggregateInputType
    _max?: AdmissionDocumentMaxAggregateInputType
  }

  export type AdmissionDocumentGroupByOutputType = {
    id: string
    admissionId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt: Date
    uploadedBy: string | null
    _count: AdmissionDocumentCountAggregateOutputType | null
    _avg: AdmissionDocumentAvgAggregateOutputType | null
    _sum: AdmissionDocumentSumAggregateOutputType | null
    _min: AdmissionDocumentMinAggregateOutputType | null
    _max: AdmissionDocumentMaxAggregateOutputType | null
  }

  type GetAdmissionDocumentGroupByPayload<T extends AdmissionDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionDocumentGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionDocument"]>

  export type AdmissionDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionDocument"]>

  export type AdmissionDocumentSelectScalar = {
    id?: boolean
    admissionId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
  }

  export type AdmissionDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }
  export type AdmissionDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }

  export type $AdmissionDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmissionDocument"
    objects: {
      admission: Prisma.$AdmissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      admissionId: string
      fileName: string
      fileType: string
      fileSize: number
      filePath: string
      uploadedAt: Date
      uploadedBy: string | null
    }, ExtArgs["result"]["admissionDocument"]>
    composites: {}
  }

  type AdmissionDocumentGetPayload<S extends boolean | null | undefined | AdmissionDocumentDefaultArgs> = $Result.GetResult<Prisma.$AdmissionDocumentPayload, S>

  type AdmissionDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionDocumentCountAggregateInputType | true
    }

  export interface AdmissionDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmissionDocument'], meta: { name: 'AdmissionDocument' } }
    /**
     * Find zero or one AdmissionDocument that matches the filter.
     * @param {AdmissionDocumentFindUniqueArgs} args - Arguments to find a AdmissionDocument
     * @example
     * // Get one AdmissionDocument
     * const admissionDocument = await prisma.admissionDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionDocumentFindUniqueArgs>(args: SelectSubset<T, AdmissionDocumentFindUniqueArgs<ExtArgs>>): Prisma__AdmissionDocumentClient<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdmissionDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionDocumentFindUniqueOrThrowArgs} args - Arguments to find a AdmissionDocument
     * @example
     * // Get one AdmissionDocument
     * const admissionDocument = await prisma.admissionDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionDocumentClient<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdmissionDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionDocumentFindFirstArgs} args - Arguments to find a AdmissionDocument
     * @example
     * // Get one AdmissionDocument
     * const admissionDocument = await prisma.admissionDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionDocumentFindFirstArgs>(args?: SelectSubset<T, AdmissionDocumentFindFirstArgs<ExtArgs>>): Prisma__AdmissionDocumentClient<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdmissionDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionDocumentFindFirstOrThrowArgs} args - Arguments to find a AdmissionDocument
     * @example
     * // Get one AdmissionDocument
     * const admissionDocument = await prisma.admissionDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionDocumentClient<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdmissionDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmissionDocuments
     * const admissionDocuments = await prisma.admissionDocument.findMany()
     * 
     * // Get first 10 AdmissionDocuments
     * const admissionDocuments = await prisma.admissionDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionDocumentWithIdOnly = await prisma.admissionDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionDocumentFindManyArgs>(args?: SelectSubset<T, AdmissionDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdmissionDocument.
     * @param {AdmissionDocumentCreateArgs} args - Arguments to create a AdmissionDocument.
     * @example
     * // Create one AdmissionDocument
     * const AdmissionDocument = await prisma.admissionDocument.create({
     *   data: {
     *     // ... data to create a AdmissionDocument
     *   }
     * })
     * 
     */
    create<T extends AdmissionDocumentCreateArgs>(args: SelectSubset<T, AdmissionDocumentCreateArgs<ExtArgs>>): Prisma__AdmissionDocumentClient<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdmissionDocuments.
     * @param {AdmissionDocumentCreateManyArgs} args - Arguments to create many AdmissionDocuments.
     * @example
     * // Create many AdmissionDocuments
     * const admissionDocument = await prisma.admissionDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionDocumentCreateManyArgs>(args?: SelectSubset<T, AdmissionDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdmissionDocuments and returns the data saved in the database.
     * @param {AdmissionDocumentCreateManyAndReturnArgs} args - Arguments to create many AdmissionDocuments.
     * @example
     * // Create many AdmissionDocuments
     * const admissionDocument = await prisma.admissionDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdmissionDocuments and only return the `id`
     * const admissionDocumentWithIdOnly = await prisma.admissionDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdmissionDocument.
     * @param {AdmissionDocumentDeleteArgs} args - Arguments to delete one AdmissionDocument.
     * @example
     * // Delete one AdmissionDocument
     * const AdmissionDocument = await prisma.admissionDocument.delete({
     *   where: {
     *     // ... filter to delete one AdmissionDocument
     *   }
     * })
     * 
     */
    delete<T extends AdmissionDocumentDeleteArgs>(args: SelectSubset<T, AdmissionDocumentDeleteArgs<ExtArgs>>): Prisma__AdmissionDocumentClient<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdmissionDocument.
     * @param {AdmissionDocumentUpdateArgs} args - Arguments to update one AdmissionDocument.
     * @example
     * // Update one AdmissionDocument
     * const admissionDocument = await prisma.admissionDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionDocumentUpdateArgs>(args: SelectSubset<T, AdmissionDocumentUpdateArgs<ExtArgs>>): Prisma__AdmissionDocumentClient<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdmissionDocuments.
     * @param {AdmissionDocumentDeleteManyArgs} args - Arguments to filter AdmissionDocuments to delete.
     * @example
     * // Delete a few AdmissionDocuments
     * const { count } = await prisma.admissionDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionDocumentDeleteManyArgs>(args?: SelectSubset<T, AdmissionDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmissionDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmissionDocuments
     * const admissionDocument = await prisma.admissionDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionDocumentUpdateManyArgs>(args: SelectSubset<T, AdmissionDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmissionDocument.
     * @param {AdmissionDocumentUpsertArgs} args - Arguments to update or create a AdmissionDocument.
     * @example
     * // Update or create a AdmissionDocument
     * const admissionDocument = await prisma.admissionDocument.upsert({
     *   create: {
     *     // ... data to create a AdmissionDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmissionDocument we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionDocumentUpsertArgs>(args: SelectSubset<T, AdmissionDocumentUpsertArgs<ExtArgs>>): Prisma__AdmissionDocumentClient<$Result.GetResult<Prisma.$AdmissionDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdmissionDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionDocumentCountArgs} args - Arguments to filter AdmissionDocuments to count.
     * @example
     * // Count the number of AdmissionDocuments
     * const count = await prisma.admissionDocument.count({
     *   where: {
     *     // ... the filter for the AdmissionDocuments we want to count
     *   }
     * })
    **/
    count<T extends AdmissionDocumentCountArgs>(
      args?: Subset<T, AdmissionDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmissionDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionDocumentAggregateArgs>(args: Subset<T, AdmissionDocumentAggregateArgs>): Prisma.PrismaPromise<GetAdmissionDocumentAggregateType<T>>

    /**
     * Group by AdmissionDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionDocumentGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmissionDocument model
   */
  readonly fields: AdmissionDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmissionDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admission<T extends AdmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionDefaultArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmissionDocument model
   */ 
  interface AdmissionDocumentFieldRefs {
    readonly id: FieldRef<"AdmissionDocument", 'String'>
    readonly admissionId: FieldRef<"AdmissionDocument", 'String'>
    readonly fileName: FieldRef<"AdmissionDocument", 'String'>
    readonly fileType: FieldRef<"AdmissionDocument", 'String'>
    readonly fileSize: FieldRef<"AdmissionDocument", 'Int'>
    readonly filePath: FieldRef<"AdmissionDocument", 'String'>
    readonly uploadedAt: FieldRef<"AdmissionDocument", 'DateTime'>
    readonly uploadedBy: FieldRef<"AdmissionDocument", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdmissionDocument findUnique
   */
  export type AdmissionDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionDocument to fetch.
     */
    where: AdmissionDocumentWhereUniqueInput
  }

  /**
   * AdmissionDocument findUniqueOrThrow
   */
  export type AdmissionDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionDocument to fetch.
     */
    where: AdmissionDocumentWhereUniqueInput
  }

  /**
   * AdmissionDocument findFirst
   */
  export type AdmissionDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionDocument to fetch.
     */
    where?: AdmissionDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionDocuments to fetch.
     */
    orderBy?: AdmissionDocumentOrderByWithRelationInput | AdmissionDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionDocuments.
     */
    cursor?: AdmissionDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionDocuments.
     */
    distinct?: AdmissionDocumentScalarFieldEnum | AdmissionDocumentScalarFieldEnum[]
  }

  /**
   * AdmissionDocument findFirstOrThrow
   */
  export type AdmissionDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionDocument to fetch.
     */
    where?: AdmissionDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionDocuments to fetch.
     */
    orderBy?: AdmissionDocumentOrderByWithRelationInput | AdmissionDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionDocuments.
     */
    cursor?: AdmissionDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionDocuments.
     */
    distinct?: AdmissionDocumentScalarFieldEnum | AdmissionDocumentScalarFieldEnum[]
  }

  /**
   * AdmissionDocument findMany
   */
  export type AdmissionDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionDocuments to fetch.
     */
    where?: AdmissionDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionDocuments to fetch.
     */
    orderBy?: AdmissionDocumentOrderByWithRelationInput | AdmissionDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmissionDocuments.
     */
    cursor?: AdmissionDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionDocuments.
     */
    skip?: number
    distinct?: AdmissionDocumentScalarFieldEnum | AdmissionDocumentScalarFieldEnum[]
  }

  /**
   * AdmissionDocument create
   */
  export type AdmissionDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmissionDocument.
     */
    data: XOR<AdmissionDocumentCreateInput, AdmissionDocumentUncheckedCreateInput>
  }

  /**
   * AdmissionDocument createMany
   */
  export type AdmissionDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmissionDocuments.
     */
    data: AdmissionDocumentCreateManyInput | AdmissionDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmissionDocument createManyAndReturn
   */
  export type AdmissionDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdmissionDocuments.
     */
    data: AdmissionDocumentCreateManyInput | AdmissionDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdmissionDocument update
   */
  export type AdmissionDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmissionDocument.
     */
    data: XOR<AdmissionDocumentUpdateInput, AdmissionDocumentUncheckedUpdateInput>
    /**
     * Choose, which AdmissionDocument to update.
     */
    where: AdmissionDocumentWhereUniqueInput
  }

  /**
   * AdmissionDocument updateMany
   */
  export type AdmissionDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmissionDocuments.
     */
    data: XOR<AdmissionDocumentUpdateManyMutationInput, AdmissionDocumentUncheckedUpdateManyInput>
    /**
     * Filter which AdmissionDocuments to update
     */
    where?: AdmissionDocumentWhereInput
  }

  /**
   * AdmissionDocument upsert
   */
  export type AdmissionDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmissionDocument to update in case it exists.
     */
    where: AdmissionDocumentWhereUniqueInput
    /**
     * In case the AdmissionDocument found by the `where` argument doesn't exist, create a new AdmissionDocument with this data.
     */
    create: XOR<AdmissionDocumentCreateInput, AdmissionDocumentUncheckedCreateInput>
    /**
     * In case the AdmissionDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionDocumentUpdateInput, AdmissionDocumentUncheckedUpdateInput>
  }

  /**
   * AdmissionDocument delete
   */
  export type AdmissionDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
    /**
     * Filter which AdmissionDocument to delete.
     */
    where: AdmissionDocumentWhereUniqueInput
  }

  /**
   * AdmissionDocument deleteMany
   */
  export type AdmissionDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionDocuments to delete
     */
    where?: AdmissionDocumentWhereInput
  }

  /**
   * AdmissionDocument without action
   */
  export type AdmissionDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionDocument
     */
    select?: AdmissionDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    userId: string | null
    groupId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    trainingId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    userId: string | null
    groupId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    trainingId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    userId: number
    groupId: number
    isActive: number
    createdAt: number
    updatedAt: number
    trainingId: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    userId?: true
    groupId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    trainingId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    userId?: true
    groupId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    trainingId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    userId?: true
    groupId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    trainingId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startDate: Date
    endDate: Date
    userId: string | null
    groupId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    trainingId: string | null
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    userId?: boolean
    groupId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingId?: boolean
    user?: boolean | Task$userArgs<ExtArgs>
    group?: boolean | Task$groupArgs<ExtArgs>
    training?: boolean | Task$trainingArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    userId?: boolean
    groupId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingId?: boolean
    user?: boolean | Task$userArgs<ExtArgs>
    group?: boolean | Task$groupArgs<ExtArgs>
    training?: boolean | Task$trainingArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    userId?: boolean
    groupId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainingId?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Task$userArgs<ExtArgs>
    group?: boolean | Task$groupArgs<ExtArgs>
    training?: boolean | Task$trainingArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Task$userArgs<ExtArgs>
    group?: boolean | Task$groupArgs<ExtArgs>
    training?: boolean | Task$trainingArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      group: Prisma.$GroupPayload<ExtArgs> | null
      training: Prisma.$TrainingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startDate: Date
      endDate: Date
      userId: string | null
      groupId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      trainingId: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Task$userArgs<ExtArgs> = {}>(args?: Subset<T, Task$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    group<T extends Task$groupArgs<ExtArgs> = {}>(args?: Subset<T, Task$groupArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    training<T extends Task$trainingArgs<ExtArgs> = {}>(args?: Subset<T, Task$trainingArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly startDate: FieldRef<"Task", 'DateTime'>
    readonly endDate: FieldRef<"Task", 'DateTime'>
    readonly userId: FieldRef<"Task", 'String'>
    readonly groupId: FieldRef<"Task", 'String'>
    readonly isActive: FieldRef<"Task", 'Boolean'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly trainingId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.user
   */
  export type Task$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task.group
   */
  export type Task$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
  }

  /**
   * Task.training
   */
  export type Task$trainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    where?: TrainingWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tasks?: boolean | Group$tasksArgs<ExtArgs>
    users?: boolean | Group$usersArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Group$tasksArgs<ExtArgs>
    users?: boolean | Group$usersArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends Group$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Group$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Group$usersArgs<ExtArgs> = {}>(args?: Subset<T, Group$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
    readonly updatedAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }

  /**
   * Group.tasks
   */
  export type Group$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Group.users
   */
  export type Group$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model ReportDocument
   */

  export type AggregateReportDocument = {
    _count: ReportDocumentCountAggregateOutputType | null
    _avg: ReportDocumentAvgAggregateOutputType | null
    _sum: ReportDocumentSumAggregateOutputType | null
    _min: ReportDocumentMinAggregateOutputType | null
    _max: ReportDocumentMaxAggregateOutputType | null
  }

  export type ReportDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ReportDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type ReportDocumentMinAggregateOutputType = {
    id: string | null
    reportId: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    filePath: string | null
    uploaded_at: Date | null
    uploaded_by: string | null
  }

  export type ReportDocumentMaxAggregateOutputType = {
    id: string | null
    reportId: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    filePath: string | null
    uploaded_at: Date | null
    uploaded_by: string | null
  }

  export type ReportDocumentCountAggregateOutputType = {
    id: number
    reportId: number
    fileName: number
    fileType: number
    fileSize: number
    filePath: number
    uploaded_at: number
    uploaded_by: number
    _all: number
  }


  export type ReportDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type ReportDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type ReportDocumentMinAggregateInputType = {
    id?: true
    reportId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploaded_at?: true
    uploaded_by?: true
  }

  export type ReportDocumentMaxAggregateInputType = {
    id?: true
    reportId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploaded_at?: true
    uploaded_by?: true
  }

  export type ReportDocumentCountAggregateInputType = {
    id?: true
    reportId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploaded_at?: true
    uploaded_by?: true
    _all?: true
  }

  export type ReportDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportDocument to aggregate.
     */
    where?: ReportDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDocuments to fetch.
     */
    orderBy?: ReportDocumentOrderByWithRelationInput | ReportDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportDocuments
    **/
    _count?: true | ReportDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportDocumentMaxAggregateInputType
  }

  export type GetReportDocumentAggregateType<T extends ReportDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateReportDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportDocument[P]>
      : GetScalarType<T[P], AggregateReportDocument[P]>
  }




  export type ReportDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportDocumentWhereInput
    orderBy?: ReportDocumentOrderByWithAggregationInput | ReportDocumentOrderByWithAggregationInput[]
    by: ReportDocumentScalarFieldEnum[] | ReportDocumentScalarFieldEnum
    having?: ReportDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportDocumentCountAggregateInputType | true
    _avg?: ReportDocumentAvgAggregateInputType
    _sum?: ReportDocumentSumAggregateInputType
    _min?: ReportDocumentMinAggregateInputType
    _max?: ReportDocumentMaxAggregateInputType
  }

  export type ReportDocumentGroupByOutputType = {
    id: string
    reportId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploaded_at: Date
    uploaded_by: string | null
    _count: ReportDocumentCountAggregateOutputType | null
    _avg: ReportDocumentAvgAggregateOutputType | null
    _sum: ReportDocumentSumAggregateOutputType | null
    _min: ReportDocumentMinAggregateOutputType | null
    _max: ReportDocumentMaxAggregateOutputType | null
  }

  type GetReportDocumentGroupByPayload<T extends ReportDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ReportDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ReportDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploaded_at?: boolean
    uploaded_by?: boolean
    report?: boolean | reportsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportDocument"]>

  export type ReportDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploaded_at?: boolean
    uploaded_by?: boolean
    report?: boolean | reportsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportDocument"]>

  export type ReportDocumentSelectScalar = {
    id?: boolean
    reportId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploaded_at?: boolean
    uploaded_by?: boolean
  }

  export type ReportDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | reportsDefaultArgs<ExtArgs>
  }
  export type ReportDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | reportsDefaultArgs<ExtArgs>
  }

  export type $ReportDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportDocument"
    objects: {
      report: Prisma.$reportsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportId: string
      fileName: string
      fileType: string
      fileSize: number
      filePath: string
      uploaded_at: Date
      uploaded_by: string | null
    }, ExtArgs["result"]["reportDocument"]>
    composites: {}
  }

  type ReportDocumentGetPayload<S extends boolean | null | undefined | ReportDocumentDefaultArgs> = $Result.GetResult<Prisma.$ReportDocumentPayload, S>

  type ReportDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportDocumentCountAggregateInputType | true
    }

  export interface ReportDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportDocument'], meta: { name: 'ReportDocument' } }
    /**
     * Find zero or one ReportDocument that matches the filter.
     * @param {ReportDocumentFindUniqueArgs} args - Arguments to find a ReportDocument
     * @example
     * // Get one ReportDocument
     * const reportDocument = await prisma.reportDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportDocumentFindUniqueArgs>(args: SelectSubset<T, ReportDocumentFindUniqueArgs<ExtArgs>>): Prisma__ReportDocumentClient<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportDocumentFindUniqueOrThrowArgs} args - Arguments to find a ReportDocument
     * @example
     * // Get one ReportDocument
     * const reportDocument = await prisma.reportDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportDocumentClient<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDocumentFindFirstArgs} args - Arguments to find a ReportDocument
     * @example
     * // Get one ReportDocument
     * const reportDocument = await prisma.reportDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportDocumentFindFirstArgs>(args?: SelectSubset<T, ReportDocumentFindFirstArgs<ExtArgs>>): Prisma__ReportDocumentClient<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDocumentFindFirstOrThrowArgs} args - Arguments to find a ReportDocument
     * @example
     * // Get one ReportDocument
     * const reportDocument = await prisma.reportDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportDocumentClient<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportDocuments
     * const reportDocuments = await prisma.reportDocument.findMany()
     * 
     * // Get first 10 ReportDocuments
     * const reportDocuments = await prisma.reportDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportDocumentWithIdOnly = await prisma.reportDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportDocumentFindManyArgs>(args?: SelectSubset<T, ReportDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportDocument.
     * @param {ReportDocumentCreateArgs} args - Arguments to create a ReportDocument.
     * @example
     * // Create one ReportDocument
     * const ReportDocument = await prisma.reportDocument.create({
     *   data: {
     *     // ... data to create a ReportDocument
     *   }
     * })
     * 
     */
    create<T extends ReportDocumentCreateArgs>(args: SelectSubset<T, ReportDocumentCreateArgs<ExtArgs>>): Prisma__ReportDocumentClient<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportDocuments.
     * @param {ReportDocumentCreateManyArgs} args - Arguments to create many ReportDocuments.
     * @example
     * // Create many ReportDocuments
     * const reportDocument = await prisma.reportDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportDocumentCreateManyArgs>(args?: SelectSubset<T, ReportDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportDocuments and returns the data saved in the database.
     * @param {ReportDocumentCreateManyAndReturnArgs} args - Arguments to create many ReportDocuments.
     * @example
     * // Create many ReportDocuments
     * const reportDocument = await prisma.reportDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportDocuments and only return the `id`
     * const reportDocumentWithIdOnly = await prisma.reportDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportDocument.
     * @param {ReportDocumentDeleteArgs} args - Arguments to delete one ReportDocument.
     * @example
     * // Delete one ReportDocument
     * const ReportDocument = await prisma.reportDocument.delete({
     *   where: {
     *     // ... filter to delete one ReportDocument
     *   }
     * })
     * 
     */
    delete<T extends ReportDocumentDeleteArgs>(args: SelectSubset<T, ReportDocumentDeleteArgs<ExtArgs>>): Prisma__ReportDocumentClient<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportDocument.
     * @param {ReportDocumentUpdateArgs} args - Arguments to update one ReportDocument.
     * @example
     * // Update one ReportDocument
     * const reportDocument = await prisma.reportDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportDocumentUpdateArgs>(args: SelectSubset<T, ReportDocumentUpdateArgs<ExtArgs>>): Prisma__ReportDocumentClient<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportDocuments.
     * @param {ReportDocumentDeleteManyArgs} args - Arguments to filter ReportDocuments to delete.
     * @example
     * // Delete a few ReportDocuments
     * const { count } = await prisma.reportDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDocumentDeleteManyArgs>(args?: SelectSubset<T, ReportDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportDocuments
     * const reportDocument = await prisma.reportDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportDocumentUpdateManyArgs>(args: SelectSubset<T, ReportDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportDocument.
     * @param {ReportDocumentUpsertArgs} args - Arguments to update or create a ReportDocument.
     * @example
     * // Update or create a ReportDocument
     * const reportDocument = await prisma.reportDocument.upsert({
     *   create: {
     *     // ... data to create a ReportDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportDocument we want to update
     *   }
     * })
     */
    upsert<T extends ReportDocumentUpsertArgs>(args: SelectSubset<T, ReportDocumentUpsertArgs<ExtArgs>>): Prisma__ReportDocumentClient<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDocumentCountArgs} args - Arguments to filter ReportDocuments to count.
     * @example
     * // Count the number of ReportDocuments
     * const count = await prisma.reportDocument.count({
     *   where: {
     *     // ... the filter for the ReportDocuments we want to count
     *   }
     * })
    **/
    count<T extends ReportDocumentCountArgs>(
      args?: Subset<T, ReportDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportDocumentAggregateArgs>(args: Subset<T, ReportDocumentAggregateArgs>): Prisma.PrismaPromise<GetReportDocumentAggregateType<T>>

    /**
     * Group by ReportDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ReportDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportDocument model
   */
  readonly fields: ReportDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends reportsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, reportsDefaultArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportDocument model
   */ 
  interface ReportDocumentFieldRefs {
    readonly id: FieldRef<"ReportDocument", 'String'>
    readonly reportId: FieldRef<"ReportDocument", 'String'>
    readonly fileName: FieldRef<"ReportDocument", 'String'>
    readonly fileType: FieldRef<"ReportDocument", 'String'>
    readonly fileSize: FieldRef<"ReportDocument", 'Int'>
    readonly filePath: FieldRef<"ReportDocument", 'String'>
    readonly uploaded_at: FieldRef<"ReportDocument", 'DateTime'>
    readonly uploaded_by: FieldRef<"ReportDocument", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReportDocument findUnique
   */
  export type ReportDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ReportDocument to fetch.
     */
    where: ReportDocumentWhereUniqueInput
  }

  /**
   * ReportDocument findUniqueOrThrow
   */
  export type ReportDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ReportDocument to fetch.
     */
    where: ReportDocumentWhereUniqueInput
  }

  /**
   * ReportDocument findFirst
   */
  export type ReportDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ReportDocument to fetch.
     */
    where?: ReportDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDocuments to fetch.
     */
    orderBy?: ReportDocumentOrderByWithRelationInput | ReportDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportDocuments.
     */
    cursor?: ReportDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportDocuments.
     */
    distinct?: ReportDocumentScalarFieldEnum | ReportDocumentScalarFieldEnum[]
  }

  /**
   * ReportDocument findFirstOrThrow
   */
  export type ReportDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ReportDocument to fetch.
     */
    where?: ReportDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDocuments to fetch.
     */
    orderBy?: ReportDocumentOrderByWithRelationInput | ReportDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportDocuments.
     */
    cursor?: ReportDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportDocuments.
     */
    distinct?: ReportDocumentScalarFieldEnum | ReportDocumentScalarFieldEnum[]
  }

  /**
   * ReportDocument findMany
   */
  export type ReportDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ReportDocuments to fetch.
     */
    where?: ReportDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportDocuments to fetch.
     */
    orderBy?: ReportDocumentOrderByWithRelationInput | ReportDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportDocuments.
     */
    cursor?: ReportDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportDocuments.
     */
    skip?: number
    distinct?: ReportDocumentScalarFieldEnum | ReportDocumentScalarFieldEnum[]
  }

  /**
   * ReportDocument create
   */
  export type ReportDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportDocument.
     */
    data: XOR<ReportDocumentCreateInput, ReportDocumentUncheckedCreateInput>
  }

  /**
   * ReportDocument createMany
   */
  export type ReportDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportDocuments.
     */
    data: ReportDocumentCreateManyInput | ReportDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportDocument createManyAndReturn
   */
  export type ReportDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportDocuments.
     */
    data: ReportDocumentCreateManyInput | ReportDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportDocument update
   */
  export type ReportDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportDocument.
     */
    data: XOR<ReportDocumentUpdateInput, ReportDocumentUncheckedUpdateInput>
    /**
     * Choose, which ReportDocument to update.
     */
    where: ReportDocumentWhereUniqueInput
  }

  /**
   * ReportDocument updateMany
   */
  export type ReportDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportDocuments.
     */
    data: XOR<ReportDocumentUpdateManyMutationInput, ReportDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ReportDocuments to update
     */
    where?: ReportDocumentWhereInput
  }

  /**
   * ReportDocument upsert
   */
  export type ReportDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportDocument to update in case it exists.
     */
    where: ReportDocumentWhereUniqueInput
    /**
     * In case the ReportDocument found by the `where` argument doesn't exist, create a new ReportDocument with this data.
     */
    create: XOR<ReportDocumentCreateInput, ReportDocumentUncheckedCreateInput>
    /**
     * In case the ReportDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportDocumentUpdateInput, ReportDocumentUncheckedUpdateInput>
  }

  /**
   * ReportDocument delete
   */
  export type ReportDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    /**
     * Filter which ReportDocument to delete.
     */
    where: ReportDocumentWhereUniqueInput
  }

  /**
   * ReportDocument deleteMany
   */
  export type ReportDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportDocuments to delete
     */
    where?: ReportDocumentWhereInput
  }

  /**
   * ReportDocument without action
   */
  export type ReportDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */ 
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
    readonly description: FieldRef<"Setting", 'String'>
    readonly category: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    receiverId: string | null
    message: string | null
    timestamp: Date | null
    isBot: boolean | null
    isRead: boolean | null
    messageType: string | null
    sender_id: string | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    receiverId: string | null
    message: string | null
    timestamp: Date | null
    isBot: boolean | null
    isRead: boolean | null
    messageType: string | null
    sender_id: string | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    receiverId: number
    message: number
    timestamp: number
    isBot: number
    isRead: number
    messageType: number
    sender_id: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    receiverId?: true
    message?: true
    timestamp?: true
    isBot?: true
    isRead?: true
    messageType?: true
    sender_id?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    receiverId?: true
    message?: true
    timestamp?: true
    isBot?: true
    isRead?: true
    messageType?: true
    sender_id?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    receiverId?: true
    message?: true
    timestamp?: true
    isBot?: true
    isRead?: true
    messageType?: true
    sender_id?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    receiverId: string
    message: string
    timestamp: Date
    isBot: boolean
    isRead: boolean
    messageType: string
    sender_id: string
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiverId?: boolean
    message?: boolean
    timestamp?: boolean
    isBot?: boolean
    isRead?: boolean
    messageType?: boolean
    sender_id?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiverId?: boolean
    message?: boolean
    timestamp?: boolean
    isBot?: boolean
    isRead?: boolean
    messageType?: boolean
    sender_id?: boolean
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    receiverId?: boolean
    message?: boolean
    timestamp?: boolean
    isBot?: boolean
    isRead?: boolean
    messageType?: boolean
    sender_id?: boolean
  }

  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      receiver: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receiverId: string
      message: string
      timestamp: Date
      isBot: boolean
      isRead: boolean
      messageType: string
      sender_id: string
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */ 
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly receiverId: FieldRef<"ChatMessage", 'String'>
    readonly message: FieldRef<"ChatMessage", 'String'>
    readonly timestamp: FieldRef<"ChatMessage", 'DateTime'>
    readonly isBot: FieldRef<"ChatMessage", 'Boolean'>
    readonly isRead: FieldRef<"ChatMessage", 'Boolean'>
    readonly messageType: FieldRef<"ChatMessage", 'String'>
    readonly sender_id: FieldRef<"ChatMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model Training
   */

  export type AggregateTraining = {
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  export type TrainingAvgAggregateOutputType = {
    maxParticipants: number | null
    progress: number | null
  }

  export type TrainingSumAggregateOutputType = {
    maxParticipants: number | null
    progress: number | null
  }

  export type TrainingMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    maxParticipants: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    progress: number | null
    instructorId: string | null
  }

  export type TrainingMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    maxParticipants: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    progress: number | null
    instructorId: string | null
  }

  export type TrainingCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startDate: number
    endDate: number
    maxParticipants: number
    status: number
    createdAt: number
    updatedAt: number
    progress: number
    instructorId: number
    _all: number
  }


  export type TrainingAvgAggregateInputType = {
    maxParticipants?: true
    progress?: true
  }

  export type TrainingSumAggregateInputType = {
    maxParticipants?: true
    progress?: true
  }

  export type TrainingMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    progress?: true
    instructorId?: true
  }

  export type TrainingMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    progress?: true
    instructorId?: true
  }

  export type TrainingCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    maxParticipants?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    progress?: true
    instructorId?: true
    _all?: true
  }

  export type TrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Training to aggregate.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trainings
    **/
    _count?: true | TrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingMaxAggregateInputType
  }

  export type GetTrainingAggregateType<T extends TrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraining[P]>
      : GetScalarType<T[P], AggregateTraining[P]>
  }




  export type TrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWhereInput
    orderBy?: TrainingOrderByWithAggregationInput | TrainingOrderByWithAggregationInput[]
    by: TrainingScalarFieldEnum[] | TrainingScalarFieldEnum
    having?: TrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingCountAggregateInputType | true
    _avg?: TrainingAvgAggregateInputType
    _sum?: TrainingSumAggregateInputType
    _min?: TrainingMinAggregateInputType
    _max?: TrainingMaxAggregateInputType
  }

  export type TrainingGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    maxParticipants: number | null
    status: string
    createdAt: Date
    updatedAt: Date
    progress: number | null
    instructorId: string | null
    _count: TrainingCountAggregateOutputType | null
    _avg: TrainingAvgAggregateOutputType | null
    _sum: TrainingSumAggregateOutputType | null
    _min: TrainingMinAggregateOutputType | null
    _max: TrainingMaxAggregateOutputType | null
  }

  type GetTrainingGroupByPayload<T extends TrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progress?: boolean
    instructorId?: boolean
    instructor?: boolean | Training$instructorArgs<ExtArgs>
    training_participations?: boolean | Training$training_participationsArgs<ExtArgs>
    tasks?: boolean | Training$tasksArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progress?: boolean
    instructorId?: boolean
    instructor?: boolean | Training$instructorArgs<ExtArgs>
  }, ExtArgs["result"]["training"]>

  export type TrainingSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    maxParticipants?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progress?: boolean
    instructorId?: boolean
  }

  export type TrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | Training$instructorArgs<ExtArgs>
    training_participations?: boolean | Training$training_participationsArgs<ExtArgs>
    tasks?: boolean | Training$tasksArgs<ExtArgs>
    _count?: boolean | TrainingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | Training$instructorArgs<ExtArgs>
  }

  export type $TrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Training"
    objects: {
      instructor: Prisma.$UserPayload<ExtArgs> | null
      training_participations: Prisma.$UserTrainingPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      maxParticipants: number | null
      status: string
      createdAt: Date
      updatedAt: Date
      progress: number | null
      instructorId: string | null
    }, ExtArgs["result"]["training"]>
    composites: {}
  }

  type TrainingGetPayload<S extends boolean | null | undefined | TrainingDefaultArgs> = $Result.GetResult<Prisma.$TrainingPayload, S>

  type TrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingCountAggregateInputType | true
    }

  export interface TrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Training'], meta: { name: 'Training' } }
    /**
     * Find zero or one Training that matches the filter.
     * @param {TrainingFindUniqueArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingFindUniqueArgs>(args: SelectSubset<T, TrainingFindUniqueArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Training that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingFindUniqueOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Training that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingFindFirstArgs>(args?: SelectSubset<T, TrainingFindFirstArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Training that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindFirstOrThrowArgs} args - Arguments to find a Training
     * @example
     * // Get one Training
     * const training = await prisma.training.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings
     * const trainings = await prisma.training.findMany()
     * 
     * // Get first 10 Trainings
     * const trainings = await prisma.training.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingWithIdOnly = await prisma.training.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingFindManyArgs>(args?: SelectSubset<T, TrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Training.
     * @param {TrainingCreateArgs} args - Arguments to create a Training.
     * @example
     * // Create one Training
     * const Training = await prisma.training.create({
     *   data: {
     *     // ... data to create a Training
     *   }
     * })
     * 
     */
    create<T extends TrainingCreateArgs>(args: SelectSubset<T, TrainingCreateArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trainings.
     * @param {TrainingCreateManyArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const training = await prisma.training.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingCreateManyArgs>(args?: SelectSubset<T, TrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trainings and returns the data saved in the database.
     * @param {TrainingCreateManyAndReturnArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const training = await prisma.training.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trainings and only return the `id`
     * const trainingWithIdOnly = await prisma.training.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Training.
     * @param {TrainingDeleteArgs} args - Arguments to delete one Training.
     * @example
     * // Delete one Training
     * const Training = await prisma.training.delete({
     *   where: {
     *     // ... filter to delete one Training
     *   }
     * })
     * 
     */
    delete<T extends TrainingDeleteArgs>(args: SelectSubset<T, TrainingDeleteArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Training.
     * @param {TrainingUpdateArgs} args - Arguments to update one Training.
     * @example
     * // Update one Training
     * const training = await prisma.training.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingUpdateArgs>(args: SelectSubset<T, TrainingUpdateArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trainings.
     * @param {TrainingDeleteManyArgs} args - Arguments to filter Trainings to delete.
     * @example
     * // Delete a few Trainings
     * const { count } = await prisma.training.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDeleteManyArgs>(args?: SelectSubset<T, TrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings
     * const training = await prisma.training.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingUpdateManyArgs>(args: SelectSubset<T, TrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Training.
     * @param {TrainingUpsertArgs} args - Arguments to update or create a Training.
     * @example
     * // Update or create a Training
     * const training = await prisma.training.upsert({
     *   create: {
     *     // ... data to create a Training
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Training we want to update
     *   }
     * })
     */
    upsert<T extends TrainingUpsertArgs>(args: SelectSubset<T, TrainingUpsertArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingCountArgs} args - Arguments to filter Trainings to count.
     * @example
     * // Count the number of Trainings
     * const count = await prisma.training.count({
     *   where: {
     *     // ... the filter for the Trainings we want to count
     *   }
     * })
    **/
    count<T extends TrainingCountArgs>(
      args?: Subset<T, TrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingAggregateArgs>(args: Subset<T, TrainingAggregateArgs>): Prisma.PrismaPromise<GetTrainingAggregateType<T>>

    /**
     * Group by Training.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingGroupByArgs['orderBy'] }
        : { orderBy?: TrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Training model
   */
  readonly fields: TrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Training.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instructor<T extends Training$instructorArgs<ExtArgs> = {}>(args?: Subset<T, Training$instructorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    training_participations<T extends Training$training_participationsArgs<ExtArgs> = {}>(args?: Subset<T, Training$training_participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Training$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Training$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Training model
   */ 
  interface TrainingFieldRefs {
    readonly id: FieldRef<"Training", 'String'>
    readonly name: FieldRef<"Training", 'String'>
    readonly description: FieldRef<"Training", 'String'>
    readonly startDate: FieldRef<"Training", 'DateTime'>
    readonly endDate: FieldRef<"Training", 'DateTime'>
    readonly maxParticipants: FieldRef<"Training", 'Int'>
    readonly status: FieldRef<"Training", 'String'>
    readonly createdAt: FieldRef<"Training", 'DateTime'>
    readonly updatedAt: FieldRef<"Training", 'DateTime'>
    readonly progress: FieldRef<"Training", 'Float'>
    readonly instructorId: FieldRef<"Training", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Training findUnique
   */
  export type TrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training findUniqueOrThrow
   */
  export type TrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training findFirst
   */
  export type TrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training findFirstOrThrow
   */
  export type TrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Training to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trainings.
     */
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training findMany
   */
  export type TrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter, which Trainings to fetch.
     */
    where?: TrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trainings to fetch.
     */
    orderBy?: TrainingOrderByWithRelationInput | TrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trainings.
     */
    cursor?: TrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trainings.
     */
    skip?: number
    distinct?: TrainingScalarFieldEnum | TrainingScalarFieldEnum[]
  }

  /**
   * Training create
   */
  export type TrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a Training.
     */
    data: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
  }

  /**
   * Training createMany
   */
  export type TrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Training createManyAndReturn
   */
  export type TrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trainings.
     */
    data: TrainingCreateManyInput | TrainingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Training update
   */
  export type TrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a Training.
     */
    data: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
    /**
     * Choose, which Training to update.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training updateMany
   */
  export type TrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trainings.
     */
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyInput>
    /**
     * Filter which Trainings to update
     */
    where?: TrainingWhereInput
  }

  /**
   * Training upsert
   */
  export type TrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the Training to update in case it exists.
     */
    where: TrainingWhereUniqueInput
    /**
     * In case the Training found by the `where` argument doesn't exist, create a new Training with this data.
     */
    create: XOR<TrainingCreateInput, TrainingUncheckedCreateInput>
    /**
     * In case the Training was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingUpdateInput, TrainingUncheckedUpdateInput>
  }

  /**
   * Training delete
   */
  export type TrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
    /**
     * Filter which Training to delete.
     */
    where: TrainingWhereUniqueInput
  }

  /**
   * Training deleteMany
   */
  export type TrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trainings to delete
     */
    where?: TrainingWhereInput
  }

  /**
   * Training.instructor
   */
  export type Training$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Training.training_participations
   */
  export type Training$training_participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    where?: UserTrainingWhereInput
    orderBy?: UserTrainingOrderByWithRelationInput | UserTrainingOrderByWithRelationInput[]
    cursor?: UserTrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTrainingScalarFieldEnum | UserTrainingScalarFieldEnum[]
  }

  /**
   * Training.tasks
   */
  export type Training$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Training without action
   */
  export type TrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Training
     */
    select?: TrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingInclude<ExtArgs> | null
  }


  /**
   * Model UserTraining
   */

  export type AggregateUserTraining = {
    _count: UserTrainingCountAggregateOutputType | null
    _avg: UserTrainingAvgAggregateOutputType | null
    _sum: UserTrainingSumAggregateOutputType | null
    _min: UserTrainingMinAggregateOutputType | null
    _max: UserTrainingMaxAggregateOutputType | null
  }

  export type UserTrainingAvgAggregateOutputType = {
    score: number | null
    progress: number | null
  }

  export type UserTrainingSumAggregateOutputType = {
    score: number | null
    progress: number | null
  }

  export type UserTrainingMinAggregateOutputType = {
    id: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    status: string | null
    score: number | null
    certificate: string | null
    training_id: string | null
    user_id: string | null
    progress: number | null
  }

  export type UserTrainingMaxAggregateOutputType = {
    id: string | null
    enrolledAt: Date | null
    completedAt: Date | null
    status: string | null
    score: number | null
    certificate: string | null
    training_id: string | null
    user_id: string | null
    progress: number | null
  }

  export type UserTrainingCountAggregateOutputType = {
    id: number
    enrolledAt: number
    completedAt: number
    status: number
    score: number
    certificate: number
    training_id: number
    user_id: number
    progress: number
    _all: number
  }


  export type UserTrainingAvgAggregateInputType = {
    score?: true
    progress?: true
  }

  export type UserTrainingSumAggregateInputType = {
    score?: true
    progress?: true
  }

  export type UserTrainingMinAggregateInputType = {
    id?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
    score?: true
    certificate?: true
    training_id?: true
    user_id?: true
    progress?: true
  }

  export type UserTrainingMaxAggregateInputType = {
    id?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
    score?: true
    certificate?: true
    training_id?: true
    user_id?: true
    progress?: true
  }

  export type UserTrainingCountAggregateInputType = {
    id?: true
    enrolledAt?: true
    completedAt?: true
    status?: true
    score?: true
    certificate?: true
    training_id?: true
    user_id?: true
    progress?: true
    _all?: true
  }

  export type UserTrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTraining to aggregate.
     */
    where?: UserTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrainings to fetch.
     */
    orderBy?: UserTrainingOrderByWithRelationInput | UserTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTrainings
    **/
    _count?: true | UserTrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTrainingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTrainingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTrainingMaxAggregateInputType
  }

  export type GetUserTrainingAggregateType<T extends UserTrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTraining[P]>
      : GetScalarType<T[P], AggregateUserTraining[P]>
  }




  export type UserTrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTrainingWhereInput
    orderBy?: UserTrainingOrderByWithAggregationInput | UserTrainingOrderByWithAggregationInput[]
    by: UserTrainingScalarFieldEnum[] | UserTrainingScalarFieldEnum
    having?: UserTrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTrainingCountAggregateInputType | true
    _avg?: UserTrainingAvgAggregateInputType
    _sum?: UserTrainingSumAggregateInputType
    _min?: UserTrainingMinAggregateInputType
    _max?: UserTrainingMaxAggregateInputType
  }

  export type UserTrainingGroupByOutputType = {
    id: string
    enrolledAt: Date
    completedAt: Date | null
    status: string
    score: number | null
    certificate: string | null
    training_id: string
    user_id: string
    progress: number | null
    _count: UserTrainingCountAggregateOutputType | null
    _avg: UserTrainingAvgAggregateOutputType | null
    _sum: UserTrainingSumAggregateOutputType | null
    _min: UserTrainingMinAggregateOutputType | null
    _max: UserTrainingMaxAggregateOutputType | null
  }

  type GetUserTrainingGroupByPayload<T extends UserTrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTrainingGroupByOutputType[P]>
            : GetScalarType<T[P], UserTrainingGroupByOutputType[P]>
        }
      >
    >


  export type UserTrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    score?: boolean
    certificate?: boolean
    training_id?: boolean
    user_id?: boolean
    progress?: boolean
    trainings?: boolean | TrainingDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | UserTraining$documentsArgs<ExtArgs>
    _count?: boolean | UserTrainingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTraining"]>

  export type UserTrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    score?: boolean
    certificate?: boolean
    training_id?: boolean
    user_id?: boolean
    progress?: boolean
    trainings?: boolean | TrainingDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTraining"]>

  export type UserTrainingSelectScalar = {
    id?: boolean
    enrolledAt?: boolean
    completedAt?: boolean
    status?: boolean
    score?: boolean
    certificate?: boolean
    training_id?: boolean
    user_id?: boolean
    progress?: boolean
  }

  export type UserTrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | TrainingDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | UserTraining$documentsArgs<ExtArgs>
    _count?: boolean | UserTrainingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserTrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | TrainingDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserTrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTraining"
    objects: {
      trainings: Prisma.$TrainingPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
      documents: Prisma.$TrainingDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enrolledAt: Date
      completedAt: Date | null
      status: string
      score: number | null
      certificate: string | null
      training_id: string
      user_id: string
      progress: number | null
    }, ExtArgs["result"]["userTraining"]>
    composites: {}
  }

  type UserTrainingGetPayload<S extends boolean | null | undefined | UserTrainingDefaultArgs> = $Result.GetResult<Prisma.$UserTrainingPayload, S>

  type UserTrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTrainingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTrainingCountAggregateInputType | true
    }

  export interface UserTrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTraining'], meta: { name: 'UserTraining' } }
    /**
     * Find zero or one UserTraining that matches the filter.
     * @param {UserTrainingFindUniqueArgs} args - Arguments to find a UserTraining
     * @example
     * // Get one UserTraining
     * const userTraining = await prisma.userTraining.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTrainingFindUniqueArgs>(args: SelectSubset<T, UserTrainingFindUniqueArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserTraining that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTrainingFindUniqueOrThrowArgs} args - Arguments to find a UserTraining
     * @example
     * // Get one UserTraining
     * const userTraining = await prisma.userTraining.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserTraining that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrainingFindFirstArgs} args - Arguments to find a UserTraining
     * @example
     * // Get one UserTraining
     * const userTraining = await prisma.userTraining.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTrainingFindFirstArgs>(args?: SelectSubset<T, UserTrainingFindFirstArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserTraining that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrainingFindFirstOrThrowArgs} args - Arguments to find a UserTraining
     * @example
     * // Get one UserTraining
     * const userTraining = await prisma.userTraining.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserTrainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTrainings
     * const userTrainings = await prisma.userTraining.findMany()
     * 
     * // Get first 10 UserTrainings
     * const userTrainings = await prisma.userTraining.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTrainingWithIdOnly = await prisma.userTraining.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTrainingFindManyArgs>(args?: SelectSubset<T, UserTrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserTraining.
     * @param {UserTrainingCreateArgs} args - Arguments to create a UserTraining.
     * @example
     * // Create one UserTraining
     * const UserTraining = await prisma.userTraining.create({
     *   data: {
     *     // ... data to create a UserTraining
     *   }
     * })
     * 
     */
    create<T extends UserTrainingCreateArgs>(args: SelectSubset<T, UserTrainingCreateArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserTrainings.
     * @param {UserTrainingCreateManyArgs} args - Arguments to create many UserTrainings.
     * @example
     * // Create many UserTrainings
     * const userTraining = await prisma.userTraining.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTrainingCreateManyArgs>(args?: SelectSubset<T, UserTrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTrainings and returns the data saved in the database.
     * @param {UserTrainingCreateManyAndReturnArgs} args - Arguments to create many UserTrainings.
     * @example
     * // Create many UserTrainings
     * const userTraining = await prisma.userTraining.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTrainings and only return the `id`
     * const userTrainingWithIdOnly = await prisma.userTraining.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserTraining.
     * @param {UserTrainingDeleteArgs} args - Arguments to delete one UserTraining.
     * @example
     * // Delete one UserTraining
     * const UserTraining = await prisma.userTraining.delete({
     *   where: {
     *     // ... filter to delete one UserTraining
     *   }
     * })
     * 
     */
    delete<T extends UserTrainingDeleteArgs>(args: SelectSubset<T, UserTrainingDeleteArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserTraining.
     * @param {UserTrainingUpdateArgs} args - Arguments to update one UserTraining.
     * @example
     * // Update one UserTraining
     * const userTraining = await prisma.userTraining.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTrainingUpdateArgs>(args: SelectSubset<T, UserTrainingUpdateArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserTrainings.
     * @param {UserTrainingDeleteManyArgs} args - Arguments to filter UserTrainings to delete.
     * @example
     * // Delete a few UserTrainings
     * const { count } = await prisma.userTraining.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTrainingDeleteManyArgs>(args?: SelectSubset<T, UserTrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTrainings
     * const userTraining = await prisma.userTraining.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTrainingUpdateManyArgs>(args: SelectSubset<T, UserTrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTraining.
     * @param {UserTrainingUpsertArgs} args - Arguments to update or create a UserTraining.
     * @example
     * // Update or create a UserTraining
     * const userTraining = await prisma.userTraining.upsert({
     *   create: {
     *     // ... data to create a UserTraining
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTraining we want to update
     *   }
     * })
     */
    upsert<T extends UserTrainingUpsertArgs>(args: SelectSubset<T, UserTrainingUpsertArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrainingCountArgs} args - Arguments to filter UserTrainings to count.
     * @example
     * // Count the number of UserTrainings
     * const count = await prisma.userTraining.count({
     *   where: {
     *     // ... the filter for the UserTrainings we want to count
     *   }
     * })
    **/
    count<T extends UserTrainingCountArgs>(
      args?: Subset<T, UserTrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTrainingAggregateArgs>(args: Subset<T, UserTrainingAggregateArgs>): Prisma.PrismaPromise<GetUserTrainingAggregateType<T>>

    /**
     * Group by UserTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTrainingGroupByArgs['orderBy'] }
        : { orderBy?: UserTrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTraining model
   */
  readonly fields: UserTrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTraining.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainings<T extends TrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingDefaultArgs<ExtArgs>>): Prisma__TrainingClient<$Result.GetResult<Prisma.$TrainingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    documents<T extends UserTraining$documentsArgs<ExtArgs> = {}>(args?: Subset<T, UserTraining$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTraining model
   */ 
  interface UserTrainingFieldRefs {
    readonly id: FieldRef<"UserTraining", 'String'>
    readonly enrolledAt: FieldRef<"UserTraining", 'DateTime'>
    readonly completedAt: FieldRef<"UserTraining", 'DateTime'>
    readonly status: FieldRef<"UserTraining", 'String'>
    readonly score: FieldRef<"UserTraining", 'Float'>
    readonly certificate: FieldRef<"UserTraining", 'String'>
    readonly training_id: FieldRef<"UserTraining", 'String'>
    readonly user_id: FieldRef<"UserTraining", 'String'>
    readonly progress: FieldRef<"UserTraining", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * UserTraining findUnique
   */
  export type UserTrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * Filter, which UserTraining to fetch.
     */
    where: UserTrainingWhereUniqueInput
  }

  /**
   * UserTraining findUniqueOrThrow
   */
  export type UserTrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * Filter, which UserTraining to fetch.
     */
    where: UserTrainingWhereUniqueInput
  }

  /**
   * UserTraining findFirst
   */
  export type UserTrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * Filter, which UserTraining to fetch.
     */
    where?: UserTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrainings to fetch.
     */
    orderBy?: UserTrainingOrderByWithRelationInput | UserTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTrainings.
     */
    cursor?: UserTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTrainings.
     */
    distinct?: UserTrainingScalarFieldEnum | UserTrainingScalarFieldEnum[]
  }

  /**
   * UserTraining findFirstOrThrow
   */
  export type UserTrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * Filter, which UserTraining to fetch.
     */
    where?: UserTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrainings to fetch.
     */
    orderBy?: UserTrainingOrderByWithRelationInput | UserTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTrainings.
     */
    cursor?: UserTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTrainings.
     */
    distinct?: UserTrainingScalarFieldEnum | UserTrainingScalarFieldEnum[]
  }

  /**
   * UserTraining findMany
   */
  export type UserTrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * Filter, which UserTrainings to fetch.
     */
    where?: UserTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTrainings to fetch.
     */
    orderBy?: UserTrainingOrderByWithRelationInput | UserTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTrainings.
     */
    cursor?: UserTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTrainings.
     */
    skip?: number
    distinct?: UserTrainingScalarFieldEnum | UserTrainingScalarFieldEnum[]
  }

  /**
   * UserTraining create
   */
  export type UserTrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTraining.
     */
    data: XOR<UserTrainingCreateInput, UserTrainingUncheckedCreateInput>
  }

  /**
   * UserTraining createMany
   */
  export type UserTrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTrainings.
     */
    data: UserTrainingCreateManyInput | UserTrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTraining createManyAndReturn
   */
  export type UserTrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserTrainings.
     */
    data: UserTrainingCreateManyInput | UserTrainingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTraining update
   */
  export type UserTrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTraining.
     */
    data: XOR<UserTrainingUpdateInput, UserTrainingUncheckedUpdateInput>
    /**
     * Choose, which UserTraining to update.
     */
    where: UserTrainingWhereUniqueInput
  }

  /**
   * UserTraining updateMany
   */
  export type UserTrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTrainings.
     */
    data: XOR<UserTrainingUpdateManyMutationInput, UserTrainingUncheckedUpdateManyInput>
    /**
     * Filter which UserTrainings to update
     */
    where?: UserTrainingWhereInput
  }

  /**
   * UserTraining upsert
   */
  export type UserTrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTraining to update in case it exists.
     */
    where: UserTrainingWhereUniqueInput
    /**
     * In case the UserTraining found by the `where` argument doesn't exist, create a new UserTraining with this data.
     */
    create: XOR<UserTrainingCreateInput, UserTrainingUncheckedCreateInput>
    /**
     * In case the UserTraining was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTrainingUpdateInput, UserTrainingUncheckedUpdateInput>
  }

  /**
   * UserTraining delete
   */
  export type UserTrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
    /**
     * Filter which UserTraining to delete.
     */
    where: UserTrainingWhereUniqueInput
  }

  /**
   * UserTraining deleteMany
   */
  export type UserTrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTrainings to delete
     */
    where?: UserTrainingWhereInput
  }

  /**
   * UserTraining.documents
   */
  export type UserTraining$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    where?: TrainingDocumentWhereInput
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    cursor?: TrainingDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * UserTraining without action
   */
  export type UserTrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTraining
     */
    select?: UserTrainingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTrainingInclude<ExtArgs> | null
  }


  /**
   * Model TrainingDocument
   */

  export type AggregateTrainingDocument = {
    _count: TrainingDocumentCountAggregateOutputType | null
    _avg: TrainingDocumentAvgAggregateOutputType | null
    _sum: TrainingDocumentSumAggregateOutputType | null
    _min: TrainingDocumentMinAggregateOutputType | null
    _max: TrainingDocumentMaxAggregateOutputType | null
  }

  export type TrainingDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type TrainingDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type TrainingDocumentMinAggregateOutputType = {
    id: string | null
    userTrainingId: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    filePath: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type TrainingDocumentMaxAggregateOutputType = {
    id: string | null
    userTrainingId: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    filePath: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
  }

  export type TrainingDocumentCountAggregateOutputType = {
    id: number
    userTrainingId: number
    fileName: number
    fileType: number
    fileSize: number
    filePath: number
    uploadedAt: number
    uploadedBy: number
    _all: number
  }


  export type TrainingDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type TrainingDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type TrainingDocumentMinAggregateInputType = {
    id?: true
    userTrainingId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type TrainingDocumentMaxAggregateInputType = {
    id?: true
    userTrainingId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadedAt?: true
    uploadedBy?: true
  }

  export type TrainingDocumentCountAggregateInputType = {
    id?: true
    userTrainingId?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    filePath?: true
    uploadedAt?: true
    uploadedBy?: true
    _all?: true
  }

  export type TrainingDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDocument to aggregate.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingDocuments
    **/
    _count?: true | TrainingDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingDocumentMaxAggregateInputType
  }

  export type GetTrainingDocumentAggregateType<T extends TrainingDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingDocument[P]>
      : GetScalarType<T[P], AggregateTrainingDocument[P]>
  }




  export type TrainingDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDocumentWhereInput
    orderBy?: TrainingDocumentOrderByWithAggregationInput | TrainingDocumentOrderByWithAggregationInput[]
    by: TrainingDocumentScalarFieldEnum[] | TrainingDocumentScalarFieldEnum
    having?: TrainingDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingDocumentCountAggregateInputType | true
    _avg?: TrainingDocumentAvgAggregateInputType
    _sum?: TrainingDocumentSumAggregateInputType
    _min?: TrainingDocumentMinAggregateInputType
    _max?: TrainingDocumentMaxAggregateInputType
  }

  export type TrainingDocumentGroupByOutputType = {
    id: string
    userTrainingId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt: Date
    uploadedBy: string | null
    _count: TrainingDocumentCountAggregateOutputType | null
    _avg: TrainingDocumentAvgAggregateOutputType | null
    _sum: TrainingDocumentSumAggregateOutputType | null
    _min: TrainingDocumentMinAggregateOutputType | null
    _max: TrainingDocumentMaxAggregateOutputType | null
  }

  type GetTrainingDocumentGroupByPayload<T extends TrainingDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingDocumentGroupByOutputType[P]>
        }
      >
    >


  export type TrainingDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userTrainingId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    userTraining?: boolean | UserTrainingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDocument"]>

  export type TrainingDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userTrainingId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    userTraining?: boolean | UserTrainingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingDocument"]>

  export type TrainingDocumentSelectScalar = {
    id?: boolean
    userTrainingId?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    filePath?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
  }

  export type TrainingDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userTraining?: boolean | UserTrainingDefaultArgs<ExtArgs>
  }
  export type TrainingDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userTraining?: boolean | UserTrainingDefaultArgs<ExtArgs>
  }

  export type $TrainingDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingDocument"
    objects: {
      userTraining: Prisma.$UserTrainingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userTrainingId: string
      fileName: string
      fileType: string
      fileSize: number
      filePath: string
      uploadedAt: Date
      uploadedBy: string | null
    }, ExtArgs["result"]["trainingDocument"]>
    composites: {}
  }

  type TrainingDocumentGetPayload<S extends boolean | null | undefined | TrainingDocumentDefaultArgs> = $Result.GetResult<Prisma.$TrainingDocumentPayload, S>

  type TrainingDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingDocumentCountAggregateInputType | true
    }

  export interface TrainingDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingDocument'], meta: { name: 'TrainingDocument' } }
    /**
     * Find zero or one TrainingDocument that matches the filter.
     * @param {TrainingDocumentFindUniqueArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingDocumentFindUniqueArgs>(args: SelectSubset<T, TrainingDocumentFindUniqueArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingDocumentFindUniqueOrThrowArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindFirstArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingDocumentFindFirstArgs>(args?: SelectSubset<T, TrainingDocumentFindFirstArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindFirstOrThrowArgs} args - Arguments to find a TrainingDocument
     * @example
     * // Get one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingDocuments
     * const trainingDocuments = await prisma.trainingDocument.findMany()
     * 
     * // Get first 10 TrainingDocuments
     * const trainingDocuments = await prisma.trainingDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingDocumentWithIdOnly = await prisma.trainingDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingDocumentFindManyArgs>(args?: SelectSubset<T, TrainingDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingDocument.
     * @param {TrainingDocumentCreateArgs} args - Arguments to create a TrainingDocument.
     * @example
     * // Create one TrainingDocument
     * const TrainingDocument = await prisma.trainingDocument.create({
     *   data: {
     *     // ... data to create a TrainingDocument
     *   }
     * })
     * 
     */
    create<T extends TrainingDocumentCreateArgs>(args: SelectSubset<T, TrainingDocumentCreateArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingDocuments.
     * @param {TrainingDocumentCreateManyArgs} args - Arguments to create many TrainingDocuments.
     * @example
     * // Create many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingDocumentCreateManyArgs>(args?: SelectSubset<T, TrainingDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingDocuments and returns the data saved in the database.
     * @param {TrainingDocumentCreateManyAndReturnArgs} args - Arguments to create many TrainingDocuments.
     * @example
     * // Create many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingDocuments and only return the `id`
     * const trainingDocumentWithIdOnly = await prisma.trainingDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainingDocument.
     * @param {TrainingDocumentDeleteArgs} args - Arguments to delete one TrainingDocument.
     * @example
     * // Delete one TrainingDocument
     * const TrainingDocument = await prisma.trainingDocument.delete({
     *   where: {
     *     // ... filter to delete one TrainingDocument
     *   }
     * })
     * 
     */
    delete<T extends TrainingDocumentDeleteArgs>(args: SelectSubset<T, TrainingDocumentDeleteArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingDocument.
     * @param {TrainingDocumentUpdateArgs} args - Arguments to update one TrainingDocument.
     * @example
     * // Update one TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingDocumentUpdateArgs>(args: SelectSubset<T, TrainingDocumentUpdateArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingDocuments.
     * @param {TrainingDocumentDeleteManyArgs} args - Arguments to filter TrainingDocuments to delete.
     * @example
     * // Delete a few TrainingDocuments
     * const { count } = await prisma.trainingDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDocumentDeleteManyArgs>(args?: SelectSubset<T, TrainingDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingDocuments
     * const trainingDocument = await prisma.trainingDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingDocumentUpdateManyArgs>(args: SelectSubset<T, TrainingDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingDocument.
     * @param {TrainingDocumentUpsertArgs} args - Arguments to update or create a TrainingDocument.
     * @example
     * // Update or create a TrainingDocument
     * const trainingDocument = await prisma.trainingDocument.upsert({
     *   create: {
     *     // ... data to create a TrainingDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingDocument we want to update
     *   }
     * })
     */
    upsert<T extends TrainingDocumentUpsertArgs>(args: SelectSubset<T, TrainingDocumentUpsertArgs<ExtArgs>>): Prisma__TrainingDocumentClient<$Result.GetResult<Prisma.$TrainingDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainingDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentCountArgs} args - Arguments to filter TrainingDocuments to count.
     * @example
     * // Count the number of TrainingDocuments
     * const count = await prisma.trainingDocument.count({
     *   where: {
     *     // ... the filter for the TrainingDocuments we want to count
     *   }
     * })
    **/
    count<T extends TrainingDocumentCountArgs>(
      args?: Subset<T, TrainingDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingDocumentAggregateArgs>(args: Subset<T, TrainingDocumentAggregateArgs>): Prisma.PrismaPromise<GetTrainingDocumentAggregateType<T>>

    /**
     * Group by TrainingDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingDocumentGroupByArgs['orderBy'] }
        : { orderBy?: TrainingDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingDocument model
   */
  readonly fields: TrainingDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userTraining<T extends UserTrainingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserTrainingDefaultArgs<ExtArgs>>): Prisma__UserTrainingClient<$Result.GetResult<Prisma.$UserTrainingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingDocument model
   */ 
  interface TrainingDocumentFieldRefs {
    readonly id: FieldRef<"TrainingDocument", 'String'>
    readonly userTrainingId: FieldRef<"TrainingDocument", 'String'>
    readonly fileName: FieldRef<"TrainingDocument", 'String'>
    readonly fileType: FieldRef<"TrainingDocument", 'String'>
    readonly fileSize: FieldRef<"TrainingDocument", 'Int'>
    readonly filePath: FieldRef<"TrainingDocument", 'String'>
    readonly uploadedAt: FieldRef<"TrainingDocument", 'DateTime'>
    readonly uploadedBy: FieldRef<"TrainingDocument", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TrainingDocument findUnique
   */
  export type TrainingDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument findUniqueOrThrow
   */
  export type TrainingDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument findFirst
   */
  export type TrainingDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDocuments.
     */
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument findFirstOrThrow
   */
  export type TrainingDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocument to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingDocuments.
     */
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument findMany
   */
  export type TrainingDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TrainingDocuments to fetch.
     */
    where?: TrainingDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingDocuments to fetch.
     */
    orderBy?: TrainingDocumentOrderByWithRelationInput | TrainingDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingDocuments.
     */
    cursor?: TrainingDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingDocuments.
     */
    skip?: number
    distinct?: TrainingDocumentScalarFieldEnum | TrainingDocumentScalarFieldEnum[]
  }

  /**
   * TrainingDocument create
   */
  export type TrainingDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingDocument.
     */
    data: XOR<TrainingDocumentCreateInput, TrainingDocumentUncheckedCreateInput>
  }

  /**
   * TrainingDocument createMany
   */
  export type TrainingDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingDocuments.
     */
    data: TrainingDocumentCreateManyInput | TrainingDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingDocument createManyAndReturn
   */
  export type TrainingDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainingDocuments.
     */
    data: TrainingDocumentCreateManyInput | TrainingDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingDocument update
   */
  export type TrainingDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingDocument.
     */
    data: XOR<TrainingDocumentUpdateInput, TrainingDocumentUncheckedUpdateInput>
    /**
     * Choose, which TrainingDocument to update.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument updateMany
   */
  export type TrainingDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingDocuments.
     */
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TrainingDocuments to update
     */
    where?: TrainingDocumentWhereInput
  }

  /**
   * TrainingDocument upsert
   */
  export type TrainingDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingDocument to update in case it exists.
     */
    where: TrainingDocumentWhereUniqueInput
    /**
     * In case the TrainingDocument found by the `where` argument doesn't exist, create a new TrainingDocument with this data.
     */
    create: XOR<TrainingDocumentCreateInput, TrainingDocumentUncheckedCreateInput>
    /**
     * In case the TrainingDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingDocumentUpdateInput, TrainingDocumentUncheckedUpdateInput>
  }

  /**
   * TrainingDocument delete
   */
  export type TrainingDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
    /**
     * Filter which TrainingDocument to delete.
     */
    where: TrainingDocumentWhereUniqueInput
  }

  /**
   * TrainingDocument deleteMany
   */
  export type TrainingDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingDocuments to delete
     */
    where?: TrainingDocumentWhereInput
  }

  /**
   * TrainingDocument without action
   */
  export type TrainingDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingDocument
     */
    select?: TrainingDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Supporter
   */

  export type AggregateSupporter = {
    _count: SupporterCountAggregateOutputType | null
    _avg: SupporterAvgAggregateOutputType | null
    _sum: SupporterSumAggregateOutputType | null
    _min: SupporterMinAggregateOutputType | null
    _max: SupporterMaxAggregateOutputType | null
  }

  export type SupporterAvgAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type SupporterSumAggregateOutputType = {
    lat: number | null
    lng: number | null
  }

  export type SupporterMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    address: string | null
    cep: string | null
    mapping: string | null
    supportType: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lat: number | null
    lng: number | null
  }

  export type SupporterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    address: string | null
    cep: string | null
    mapping: string | null
    supportType: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lat: number | null
    lng: number | null
  }

  export type SupporterCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    address: number
    cep: number
    mapping: number
    supportType: number
    status: number
    createdAt: number
    updatedAt: number
    lat: number
    lng: number
    _all: number
  }


  export type SupporterAvgAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type SupporterSumAggregateInputType = {
    lat?: true
    lng?: true
  }

  export type SupporterMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    cep?: true
    mapping?: true
    supportType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lat?: true
    lng?: true
  }

  export type SupporterMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    cep?: true
    mapping?: true
    supportType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lat?: true
    lng?: true
  }

  export type SupporterCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    cep?: true
    mapping?: true
    supportType?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lat?: true
    lng?: true
    _all?: true
  }

  export type SupporterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supporter to aggregate.
     */
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supporters to fetch.
     */
    orderBy?: SupporterOrderByWithRelationInput | SupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Supporters
    **/
    _count?: true | SupporterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupporterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupporterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupporterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupporterMaxAggregateInputType
  }

  export type GetSupporterAggregateType<T extends SupporterAggregateArgs> = {
        [P in keyof T & keyof AggregateSupporter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupporter[P]>
      : GetScalarType<T[P], AggregateSupporter[P]>
  }




  export type SupporterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupporterWhereInput
    orderBy?: SupporterOrderByWithAggregationInput | SupporterOrderByWithAggregationInput[]
    by: SupporterScalarFieldEnum[] | SupporterScalarFieldEnum
    having?: SupporterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupporterCountAggregateInputType | true
    _avg?: SupporterAvgAggregateInputType
    _sum?: SupporterSumAggregateInputType
    _min?: SupporterMinAggregateInputType
    _max?: SupporterMaxAggregateInputType
  }

  export type SupporterGroupByOutputType = {
    id: string
    name: string
    phone: string
    address: string
    cep: string
    mapping: string
    supportType: string
    status: string
    createdAt: Date
    updatedAt: Date
    lat: number | null
    lng: number | null
    _count: SupporterCountAggregateOutputType | null
    _avg: SupporterAvgAggregateOutputType | null
    _sum: SupporterSumAggregateOutputType | null
    _min: SupporterMinAggregateOutputType | null
    _max: SupporterMaxAggregateOutputType | null
  }

  type GetSupporterGroupByPayload<T extends SupporterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupporterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupporterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupporterGroupByOutputType[P]>
            : GetScalarType<T[P], SupporterGroupByOutputType[P]>
        }
      >
    >


  export type SupporterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    cep?: boolean
    mapping?: boolean
    supportType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lat?: boolean
    lng?: boolean
  }, ExtArgs["result"]["supporter"]>

  export type SupporterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    cep?: boolean
    mapping?: boolean
    supportType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lat?: boolean
    lng?: boolean
  }, ExtArgs["result"]["supporter"]>

  export type SupporterSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    cep?: boolean
    mapping?: boolean
    supportType?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lat?: boolean
    lng?: boolean
  }


  export type $SupporterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supporter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string
      address: string
      cep: string
      mapping: string
      supportType: string
      status: string
      createdAt: Date
      updatedAt: Date
      lat: number | null
      lng: number | null
    }, ExtArgs["result"]["supporter"]>
    composites: {}
  }

  type SupporterGetPayload<S extends boolean | null | undefined | SupporterDefaultArgs> = $Result.GetResult<Prisma.$SupporterPayload, S>

  type SupporterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupporterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupporterCountAggregateInputType | true
    }

  export interface SupporterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supporter'], meta: { name: 'Supporter' } }
    /**
     * Find zero or one Supporter that matches the filter.
     * @param {SupporterFindUniqueArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupporterFindUniqueArgs>(args: SelectSubset<T, SupporterFindUniqueArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supporter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupporterFindUniqueOrThrowArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupporterFindUniqueOrThrowArgs>(args: SelectSubset<T, SupporterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supporter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterFindFirstArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupporterFindFirstArgs>(args?: SelectSubset<T, SupporterFindFirstArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supporter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterFindFirstOrThrowArgs} args - Arguments to find a Supporter
     * @example
     * // Get one Supporter
     * const supporter = await prisma.supporter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupporterFindFirstOrThrowArgs>(args?: SelectSubset<T, SupporterFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Supporters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supporters
     * const supporters = await prisma.supporter.findMany()
     * 
     * // Get first 10 Supporters
     * const supporters = await prisma.supporter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supporterWithIdOnly = await prisma.supporter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupporterFindManyArgs>(args?: SelectSubset<T, SupporterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supporter.
     * @param {SupporterCreateArgs} args - Arguments to create a Supporter.
     * @example
     * // Create one Supporter
     * const Supporter = await prisma.supporter.create({
     *   data: {
     *     // ... data to create a Supporter
     *   }
     * })
     * 
     */
    create<T extends SupporterCreateArgs>(args: SelectSubset<T, SupporterCreateArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Supporters.
     * @param {SupporterCreateManyArgs} args - Arguments to create many Supporters.
     * @example
     * // Create many Supporters
     * const supporter = await prisma.supporter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupporterCreateManyArgs>(args?: SelectSubset<T, SupporterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Supporters and returns the data saved in the database.
     * @param {SupporterCreateManyAndReturnArgs} args - Arguments to create many Supporters.
     * @example
     * // Create many Supporters
     * const supporter = await prisma.supporter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Supporters and only return the `id`
     * const supporterWithIdOnly = await prisma.supporter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupporterCreateManyAndReturnArgs>(args?: SelectSubset<T, SupporterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Supporter.
     * @param {SupporterDeleteArgs} args - Arguments to delete one Supporter.
     * @example
     * // Delete one Supporter
     * const Supporter = await prisma.supporter.delete({
     *   where: {
     *     // ... filter to delete one Supporter
     *   }
     * })
     * 
     */
    delete<T extends SupporterDeleteArgs>(args: SelectSubset<T, SupporterDeleteArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supporter.
     * @param {SupporterUpdateArgs} args - Arguments to update one Supporter.
     * @example
     * // Update one Supporter
     * const supporter = await prisma.supporter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupporterUpdateArgs>(args: SelectSubset<T, SupporterUpdateArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Supporters.
     * @param {SupporterDeleteManyArgs} args - Arguments to filter Supporters to delete.
     * @example
     * // Delete a few Supporters
     * const { count } = await prisma.supporter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupporterDeleteManyArgs>(args?: SelectSubset<T, SupporterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supporters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supporters
     * const supporter = await prisma.supporter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupporterUpdateManyArgs>(args: SelectSubset<T, SupporterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supporter.
     * @param {SupporterUpsertArgs} args - Arguments to update or create a Supporter.
     * @example
     * // Update or create a Supporter
     * const supporter = await prisma.supporter.upsert({
     *   create: {
     *     // ... data to create a Supporter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supporter we want to update
     *   }
     * })
     */
    upsert<T extends SupporterUpsertArgs>(args: SelectSubset<T, SupporterUpsertArgs<ExtArgs>>): Prisma__SupporterClient<$Result.GetResult<Prisma.$SupporterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Supporters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterCountArgs} args - Arguments to filter Supporters to count.
     * @example
     * // Count the number of Supporters
     * const count = await prisma.supporter.count({
     *   where: {
     *     // ... the filter for the Supporters we want to count
     *   }
     * })
    **/
    count<T extends SupporterCountArgs>(
      args?: Subset<T, SupporterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupporterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supporter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupporterAggregateArgs>(args: Subset<T, SupporterAggregateArgs>): Prisma.PrismaPromise<GetSupporterAggregateType<T>>

    /**
     * Group by Supporter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupporterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupporterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupporterGroupByArgs['orderBy'] }
        : { orderBy?: SupporterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupporterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupporterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supporter model
   */
  readonly fields: SupporterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supporter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupporterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supporter model
   */ 
  interface SupporterFieldRefs {
    readonly id: FieldRef<"Supporter", 'String'>
    readonly name: FieldRef<"Supporter", 'String'>
    readonly phone: FieldRef<"Supporter", 'String'>
    readonly address: FieldRef<"Supporter", 'String'>
    readonly cep: FieldRef<"Supporter", 'String'>
    readonly mapping: FieldRef<"Supporter", 'String'>
    readonly supportType: FieldRef<"Supporter", 'String'>
    readonly status: FieldRef<"Supporter", 'String'>
    readonly createdAt: FieldRef<"Supporter", 'DateTime'>
    readonly updatedAt: FieldRef<"Supporter", 'DateTime'>
    readonly lat: FieldRef<"Supporter", 'Float'>
    readonly lng: FieldRef<"Supporter", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Supporter findUnique
   */
  export type SupporterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Filter, which Supporter to fetch.
     */
    where: SupporterWhereUniqueInput
  }

  /**
   * Supporter findUniqueOrThrow
   */
  export type SupporterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Filter, which Supporter to fetch.
     */
    where: SupporterWhereUniqueInput
  }

  /**
   * Supporter findFirst
   */
  export type SupporterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Filter, which Supporter to fetch.
     */
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supporters to fetch.
     */
    orderBy?: SupporterOrderByWithRelationInput | SupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Supporters.
     */
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Supporters.
     */
    distinct?: SupporterScalarFieldEnum | SupporterScalarFieldEnum[]
  }

  /**
   * Supporter findFirstOrThrow
   */
  export type SupporterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Filter, which Supporter to fetch.
     */
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supporters to fetch.
     */
    orderBy?: SupporterOrderByWithRelationInput | SupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Supporters.
     */
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supporters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Supporters.
     */
    distinct?: SupporterScalarFieldEnum | SupporterScalarFieldEnum[]
  }

  /**
   * Supporter findMany
   */
  export type SupporterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Filter, which Supporters to fetch.
     */
    where?: SupporterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Supporters to fetch.
     */
    orderBy?: SupporterOrderByWithRelationInput | SupporterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Supporters.
     */
    cursor?: SupporterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Supporters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Supporters.
     */
    skip?: number
    distinct?: SupporterScalarFieldEnum | SupporterScalarFieldEnum[]
  }

  /**
   * Supporter create
   */
  export type SupporterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * The data needed to create a Supporter.
     */
    data: XOR<SupporterCreateInput, SupporterUncheckedCreateInput>
  }

  /**
   * Supporter createMany
   */
  export type SupporterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Supporters.
     */
    data: SupporterCreateManyInput | SupporterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supporter createManyAndReturn
   */
  export type SupporterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Supporters.
     */
    data: SupporterCreateManyInput | SupporterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supporter update
   */
  export type SupporterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * The data needed to update a Supporter.
     */
    data: XOR<SupporterUpdateInput, SupporterUncheckedUpdateInput>
    /**
     * Choose, which Supporter to update.
     */
    where: SupporterWhereUniqueInput
  }

  /**
   * Supporter updateMany
   */
  export type SupporterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Supporters.
     */
    data: XOR<SupporterUpdateManyMutationInput, SupporterUncheckedUpdateManyInput>
    /**
     * Filter which Supporters to update
     */
    where?: SupporterWhereInput
  }

  /**
   * Supporter upsert
   */
  export type SupporterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * The filter to search for the Supporter to update in case it exists.
     */
    where: SupporterWhereUniqueInput
    /**
     * In case the Supporter found by the `where` argument doesn't exist, create a new Supporter with this data.
     */
    create: XOR<SupporterCreateInput, SupporterUncheckedCreateInput>
    /**
     * In case the Supporter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupporterUpdateInput, SupporterUncheckedUpdateInput>
  }

  /**
   * Supporter delete
   */
  export type SupporterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
    /**
     * Filter which Supporter to delete.
     */
    where: SupporterWhereUniqueInput
  }

  /**
   * Supporter deleteMany
   */
  export type SupporterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supporters to delete
     */
    where?: SupporterWhereInput
  }

  /**
   * Supporter without action
   */
  export type SupporterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supporter
     */
    select?: SupporterSelect<ExtArgs> | null
  }


  /**
   * Model reports
   */

  export type AggregateReports = {
    _count: ReportsCountAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  export type ReportsMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    generated_by: string | null
    frequency: string | null
    scheduledDate: Date | null
    created_at: Date | null
  }

  export type ReportsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    generated_by: string | null
    frequency: string | null
    scheduledDate: Date | null
    created_at: Date | null
  }

  export type ReportsCountAggregateOutputType = {
    id: number
    name: number
    type: number
    generated_by: number
    frequency: number
    scheduledDate: number
    created_at: number
    _all: number
  }


  export type ReportsMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    generated_by?: true
    frequency?: true
    scheduledDate?: true
    created_at?: true
  }

  export type ReportsMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    generated_by?: true
    frequency?: true
    scheduledDate?: true
    created_at?: true
  }

  export type ReportsCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    generated_by?: true
    frequency?: true
    scheduledDate?: true
    created_at?: true
    _all?: true
  }

  export type ReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reports to aggregate.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reports
    **/
    _count?: true | ReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportsMaxAggregateInputType
  }

  export type GetReportsAggregateType<T extends ReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateReports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReports[P]>
      : GetScalarType<T[P], AggregateReports[P]>
  }




  export type reportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportsWhereInput
    orderBy?: reportsOrderByWithAggregationInput | reportsOrderByWithAggregationInput[]
    by: ReportsScalarFieldEnum[] | ReportsScalarFieldEnum
    having?: reportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportsCountAggregateInputType | true
    _min?: ReportsMinAggregateInputType
    _max?: ReportsMaxAggregateInputType
  }

  export type ReportsGroupByOutputType = {
    id: string
    name: string
    type: string
    generated_by: string
    frequency: string | null
    scheduledDate: Date | null
    created_at: Date
    _count: ReportsCountAggregateOutputType | null
    _min: ReportsMinAggregateOutputType | null
    _max: ReportsMaxAggregateOutputType | null
  }

  type GetReportsGroupByPayload<T extends reportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportsGroupByOutputType[P]>
            : GetScalarType<T[P], ReportsGroupByOutputType[P]>
        }
      >
    >


  export type reportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    generated_by?: boolean
    frequency?: boolean
    scheduledDate?: boolean
    created_at?: boolean
    documents?: boolean | reports$documentsArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ReportsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reports"]>

  export type reportsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    generated_by?: boolean
    frequency?: boolean
    scheduledDate?: boolean
    created_at?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reports"]>

  export type reportsSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    generated_by?: boolean
    frequency?: boolean
    scheduledDate?: boolean
    created_at?: boolean
  }

  export type reportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | reports$documentsArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ReportsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type reportsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $reportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reports"
    objects: {
      documents: Prisma.$ReportDocumentPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      generated_by: string
      frequency: string | null
      scheduledDate: Date | null
      created_at: Date
    }, ExtArgs["result"]["reports"]>
    composites: {}
  }

  type reportsGetPayload<S extends boolean | null | undefined | reportsDefaultArgs> = $Result.GetResult<Prisma.$reportsPayload, S>

  type reportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportsCountAggregateInputType | true
    }

  export interface reportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reports'], meta: { name: 'reports' } }
    /**
     * Find zero or one Reports that matches the filter.
     * @param {reportsFindUniqueArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reportsFindUniqueArgs>(args: SelectSubset<T, reportsFindUniqueArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reports that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {reportsFindUniqueOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reportsFindUniqueOrThrowArgs>(args: SelectSubset<T, reportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindFirstArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reportsFindFirstArgs>(args?: SelectSubset<T, reportsFindFirstArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindFirstOrThrowArgs} args - Arguments to find a Reports
     * @example
     * // Get one Reports
     * const reports = await prisma.reports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reportsFindFirstOrThrowArgs>(args?: SelectSubset<T, reportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.reports.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.reports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportsWithIdOnly = await prisma.reports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reportsFindManyArgs>(args?: SelectSubset<T, reportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reports.
     * @param {reportsCreateArgs} args - Arguments to create a Reports.
     * @example
     * // Create one Reports
     * const Reports = await prisma.reports.create({
     *   data: {
     *     // ... data to create a Reports
     *   }
     * })
     * 
     */
    create<T extends reportsCreateArgs>(args: SelectSubset<T, reportsCreateArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {reportsCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const reports = await prisma.reports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reportsCreateManyArgs>(args?: SelectSubset<T, reportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {reportsCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const reports = await prisma.reports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportsWithIdOnly = await prisma.reports.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reportsCreateManyAndReturnArgs>(args?: SelectSubset<T, reportsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reports.
     * @param {reportsDeleteArgs} args - Arguments to delete one Reports.
     * @example
     * // Delete one Reports
     * const Reports = await prisma.reports.delete({
     *   where: {
     *     // ... filter to delete one Reports
     *   }
     * })
     * 
     */
    delete<T extends reportsDeleteArgs>(args: SelectSubset<T, reportsDeleteArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reports.
     * @param {reportsUpdateArgs} args - Arguments to update one Reports.
     * @example
     * // Update one Reports
     * const reports = await prisma.reports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reportsUpdateArgs>(args: SelectSubset<T, reportsUpdateArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {reportsDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.reports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reportsDeleteManyArgs>(args?: SelectSubset<T, reportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const reports = await prisma.reports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reportsUpdateManyArgs>(args: SelectSubset<T, reportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reports.
     * @param {reportsUpsertArgs} args - Arguments to update or create a Reports.
     * @example
     * // Update or create a Reports
     * const reports = await prisma.reports.upsert({
     *   create: {
     *     // ... data to create a Reports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reports we want to update
     *   }
     * })
     */
    upsert<T extends reportsUpsertArgs>(args: SelectSubset<T, reportsUpsertArgs<ExtArgs>>): Prisma__reportsClient<$Result.GetResult<Prisma.$reportsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.reports.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends reportsCountArgs>(
      args?: Subset<T, reportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportsAggregateArgs>(args: Subset<T, ReportsAggregateArgs>): Prisma.PrismaPromise<GetReportsAggregateType<T>>

    /**
     * Group by Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportsGroupByArgs['orderBy'] }
        : { orderBy?: reportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reports model
   */
  readonly fields: reportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends reports$documentsArgs<ExtArgs> = {}>(args?: Subset<T, reports$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reports model
   */ 
  interface reportsFieldRefs {
    readonly id: FieldRef<"reports", 'String'>
    readonly name: FieldRef<"reports", 'String'>
    readonly type: FieldRef<"reports", 'String'>
    readonly generated_by: FieldRef<"reports", 'String'>
    readonly frequency: FieldRef<"reports", 'String'>
    readonly scheduledDate: FieldRef<"reports", 'DateTime'>
    readonly created_at: FieldRef<"reports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reports findUnique
   */
  export type reportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports findUniqueOrThrow
   */
  export type reportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports findFirst
   */
  export type reportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports findFirstOrThrow
   */
  export type reportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports findMany
   */
  export type reportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: reportsOrderByWithRelationInput | reportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reports.
     */
    cursor?: reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    distinct?: ReportsScalarFieldEnum | ReportsScalarFieldEnum[]
  }

  /**
   * reports create
   */
  export type reportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * The data needed to create a reports.
     */
    data: XOR<reportsCreateInput, reportsUncheckedCreateInput>
  }

  /**
   * reports createMany
   */
  export type reportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reports.
     */
    data: reportsCreateManyInput | reportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reports createManyAndReturn
   */
  export type reportsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many reports.
     */
    data: reportsCreateManyInput | reportsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reports update
   */
  export type reportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * The data needed to update a reports.
     */
    data: XOR<reportsUpdateInput, reportsUncheckedUpdateInput>
    /**
     * Choose, which reports to update.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports updateMany
   */
  export type reportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reports.
     */
    data: XOR<reportsUpdateManyMutationInput, reportsUncheckedUpdateManyInput>
    /**
     * Filter which reports to update
     */
    where?: reportsWhereInput
  }

  /**
   * reports upsert
   */
  export type reportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * The filter to search for the reports to update in case it exists.
     */
    where: reportsWhereUniqueInput
    /**
     * In case the reports found by the `where` argument doesn't exist, create a new reports with this data.
     */
    create: XOR<reportsCreateInput, reportsUncheckedCreateInput>
    /**
     * In case the reports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportsUpdateInput, reportsUncheckedUpdateInput>
  }

  /**
   * reports delete
   */
  export type reportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
    /**
     * Filter which reports to delete.
     */
    where: reportsWhereUniqueInput
  }

  /**
   * reports deleteMany
   */
  export type reportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reports to delete
     */
    where?: reportsWhereInput
  }

  /**
   * reports.documents
   */
  export type reports$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportDocument
     */
    select?: ReportDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportDocumentInclude<ExtArgs> | null
    where?: ReportDocumentWhereInput
    orderBy?: ReportDocumentOrderByWithRelationInput | ReportDocumentOrderByWithRelationInput[]
    cursor?: ReportDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportDocumentScalarFieldEnum | ReportDocumentScalarFieldEnum[]
  }

  /**
   * reports without action
   */
  export type reportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reports
     */
    select?: reportsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reportsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    name: 'name',
    role: 'role',
    isActive: 'isActive',
    last_login: 'last_login',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    departmentId: 'departmentId',
    positionId: 'positionId',
    surname: 'surname'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    address: 'address',
    phone: 'phone',
    birthDate: 'birthDate',
    document: 'document',
    emergencyContact: 'emergencyContact',
    avatar: 'avatar',
    bio: 'bio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    user_id: 'user_id'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    salary: 'salary',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const PerformanceEvaluationScalarFieldEnum: {
    id: 'id',
    period: 'period',
    score: 'score',
    goals: 'goals',
    achievements: 'achievements',
    feedback: 'feedback',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    evaluator_id: 'evaluator_id',
    user_id: 'user_id'
  };

  export type PerformanceEvaluationScalarFieldEnum = (typeof PerformanceEvaluationScalarFieldEnum)[keyof typeof PerformanceEvaluationScalarFieldEnum]


  export const AdmissionScalarFieldEnum: {
    id: 'id',
    hireDate: 'hireDate',
    contractType: 'contractType',
    salary: 'salary',
    benefits: 'benefits',
    terminationDate: 'terminationDate',
    terminationReason: 'terminationReason',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    user_id: 'user_id',
    position_id: 'position_id',
    department_id: 'department_id'
  };

  export type AdmissionScalarFieldEnum = (typeof AdmissionScalarFieldEnum)[keyof typeof AdmissionScalarFieldEnum]


  export const AdmissionDocumentScalarFieldEnum: {
    id: 'id',
    admissionId: 'admissionId',
    fileName: 'fileName',
    fileType: 'fileType',
    fileSize: 'fileSize',
    filePath: 'filePath',
    uploadedAt: 'uploadedAt',
    uploadedBy: 'uploadedBy'
  };

  export type AdmissionDocumentScalarFieldEnum = (typeof AdmissionDocumentScalarFieldEnum)[keyof typeof AdmissionDocumentScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    userId: 'userId',
    groupId: 'groupId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    trainingId: 'trainingId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const ReportDocumentScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    fileName: 'fileName',
    fileType: 'fileType',
    fileSize: 'fileSize',
    filePath: 'filePath',
    uploaded_at: 'uploaded_at',
    uploaded_by: 'uploaded_by'
  };

  export type ReportDocumentScalarFieldEnum = (typeof ReportDocumentScalarFieldEnum)[keyof typeof ReportDocumentScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    receiverId: 'receiverId',
    message: 'message',
    timestamp: 'timestamp',
    isBot: 'isBot',
    isRead: 'isRead',
    messageType: 'messageType',
    sender_id: 'sender_id'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const TrainingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    maxParticipants: 'maxParticipants',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    progress: 'progress',
    instructorId: 'instructorId'
  };

  export type TrainingScalarFieldEnum = (typeof TrainingScalarFieldEnum)[keyof typeof TrainingScalarFieldEnum]


  export const UserTrainingScalarFieldEnum: {
    id: 'id',
    enrolledAt: 'enrolledAt',
    completedAt: 'completedAt',
    status: 'status',
    score: 'score',
    certificate: 'certificate',
    training_id: 'training_id',
    user_id: 'user_id',
    progress: 'progress'
  };

  export type UserTrainingScalarFieldEnum = (typeof UserTrainingScalarFieldEnum)[keyof typeof UserTrainingScalarFieldEnum]


  export const TrainingDocumentScalarFieldEnum: {
    id: 'id',
    userTrainingId: 'userTrainingId',
    fileName: 'fileName',
    fileType: 'fileType',
    fileSize: 'fileSize',
    filePath: 'filePath',
    uploadedAt: 'uploadedAt',
    uploadedBy: 'uploadedBy'
  };

  export type TrainingDocumentScalarFieldEnum = (typeof TrainingDocumentScalarFieldEnum)[keyof typeof TrainingDocumentScalarFieldEnum]


  export const SupporterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    address: 'address',
    cep: 'cep',
    mapping: 'mapping',
    supportType: 'supportType',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lat: 'lat',
    lng: 'lng'
  };

  export type SupporterScalarFieldEnum = (typeof SupporterScalarFieldEnum)[keyof typeof SupporterScalarFieldEnum]


  export const ReportsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    generated_by: 'generated_by',
    frequency: 'frequency',
    scheduledDate: 'scheduledDate',
    created_at: 'created_at'
  };

  export type ReportsScalarFieldEnum = (typeof ReportsScalarFieldEnum)[keyof typeof ReportsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    departmentId?: StringNullableFilter<"User"> | string | null
    positionId?: StringNullableFilter<"User"> | string | null
    surname?: StringNullableFilter<"User"> | string | null
    admissions?: XOR<AdmissionNullableRelationFilter, AdmissionWhereInput> | null
    receivedMessages?: ChatMessageListRelationFilter
    sentMessages?: ChatMessageListRelationFilter
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationListRelationFilter
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    reports?: ReportsListRelationFilter
    tasks?: TaskListRelationFilter
    training_participations?: UserTrainingListRelationFilter
    trainings?: TrainingListRelationFilter
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    position?: XOR<PositionNullableRelationFilter, PositionWhereInput> | null
    groups?: GroupListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    last_login?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    surname?: SortOrderInput | SortOrder
    admissions?: AdmissionOrderByWithRelationInput
    receivedMessages?: ChatMessageOrderByRelationAggregateInput
    sentMessages?: ChatMessageOrderByRelationAggregateInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationOrderByRelationAggregateInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
    reports?: reportsOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    training_participations?: UserTrainingOrderByRelationAggregateInput
    trainings?: TrainingOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    groups?: GroupOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password_hash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    departmentId?: StringNullableFilter<"User"> | string | null
    positionId?: StringNullableFilter<"User"> | string | null
    surname?: StringNullableFilter<"User"> | string | null
    admissions?: XOR<AdmissionNullableRelationFilter, AdmissionWhereInput> | null
    receivedMessages?: ChatMessageListRelationFilter
    sentMessages?: ChatMessageListRelationFilter
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationListRelationFilter
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationListRelationFilter
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    reports?: ReportsListRelationFilter
    tasks?: TaskListRelationFilter
    training_participations?: UserTrainingListRelationFilter
    trainings?: TrainingListRelationFilter
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    position?: XOR<PositionNullableRelationFilter, PositionWhereInput> | null
    groups?: GroupListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    last_login?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    surname?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password_hash?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    last_login?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    departmentId?: StringNullableWithAggregatesFilter<"User"> | string | null
    positionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    surname?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    address?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    birthDate?: DateTimeNullableFilter<"Profile"> | Date | string | null
    document?: StringNullableFilter<"Profile"> | string | null
    emergencyContact?: StringNullableFilter<"Profile"> | string | null
    avatar?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user_id?: StringFilter<"Profile"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    address?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    birthDate?: DateTimeNullableFilter<"Profile"> | Date | string | null
    document?: StringNullableFilter<"Profile"> | string | null
    emergencyContact?: StringNullableFilter<"Profile"> | string | null
    avatar?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "user_id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    document?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    address?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    document?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    user_id?: StringWithAggregatesFilter<"Profile"> | string
  }

  export type PositionWhereInput = {
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    id?: StringFilter<"Position"> | string
    name?: StringFilter<"Position"> | string
    description?: StringNullableFilter<"Position"> | string | null
    salary?: FloatNullableFilter<"Position"> | number | null
    status?: StringFilter<"Position"> | string
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    users?: UserListRelationFilter
    admissions?: AdmissionListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    admissions?: AdmissionOrderByRelationAggregateInput
  }

  export type PositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    name?: StringFilter<"Position"> | string
    description?: StringNullableFilter<"Position"> | string | null
    salary?: FloatNullableFilter<"Position"> | number | null
    status?: StringFilter<"Position"> | string
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    users?: UserListRelationFilter
    admissions?: AdmissionListRelationFilter
  }, "id">

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _avg?: PositionAvgOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
    _sum?: PositionSumOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    OR?: PositionScalarWhereWithAggregatesInput[]
    NOT?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Position"> | string
    name?: StringWithAggregatesFilter<"Position"> | string
    description?: StringNullableWithAggregatesFilter<"Position"> | string | null
    salary?: FloatNullableWithAggregatesFilter<"Position"> | number | null
    status?: StringWithAggregatesFilter<"Position"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    users?: UserListRelationFilter
    admissions?: AdmissionListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    admissions?: AdmissionOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    users?: UserListRelationFilter
    admissions?: AdmissionListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type PerformanceEvaluationWhereInput = {
    AND?: PerformanceEvaluationWhereInput | PerformanceEvaluationWhereInput[]
    OR?: PerformanceEvaluationWhereInput[]
    NOT?: PerformanceEvaluationWhereInput | PerformanceEvaluationWhereInput[]
    id?: StringFilter<"PerformanceEvaluation"> | string
    period?: StringFilter<"PerformanceEvaluation"> | string
    score?: FloatFilter<"PerformanceEvaluation"> | number
    goals?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    achievements?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    feedback?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    status?: StringFilter<"PerformanceEvaluation"> | string
    createdAt?: DateTimeFilter<"PerformanceEvaluation"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceEvaluation"> | Date | string
    evaluator_id?: StringFilter<"PerformanceEvaluation"> | string
    user_id?: StringFilter<"PerformanceEvaluation"> | string
    users_performance_evaluations_evaluator_idTousers?: XOR<UserRelationFilter, UserWhereInput>
    users_performance_evaluations_user_idTousers?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PerformanceEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    period?: SortOrder
    score?: SortOrder
    goals?: SortOrderInput | SortOrder
    achievements?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluator_id?: SortOrder
    user_id?: SortOrder
    users_performance_evaluations_evaluator_idTousers?: UserOrderByWithRelationInput
    users_performance_evaluations_user_idTousers?: UserOrderByWithRelationInput
  }

  export type PerformanceEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceEvaluationWhereInput | PerformanceEvaluationWhereInput[]
    OR?: PerformanceEvaluationWhereInput[]
    NOT?: PerformanceEvaluationWhereInput | PerformanceEvaluationWhereInput[]
    period?: StringFilter<"PerformanceEvaluation"> | string
    score?: FloatFilter<"PerformanceEvaluation"> | number
    goals?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    achievements?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    feedback?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    status?: StringFilter<"PerformanceEvaluation"> | string
    createdAt?: DateTimeFilter<"PerformanceEvaluation"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceEvaluation"> | Date | string
    evaluator_id?: StringFilter<"PerformanceEvaluation"> | string
    user_id?: StringFilter<"PerformanceEvaluation"> | string
    users_performance_evaluations_evaluator_idTousers?: XOR<UserRelationFilter, UserWhereInput>
    users_performance_evaluations_user_idTousers?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PerformanceEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    period?: SortOrder
    score?: SortOrder
    goals?: SortOrderInput | SortOrder
    achievements?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluator_id?: SortOrder
    user_id?: SortOrder
    _count?: PerformanceEvaluationCountOrderByAggregateInput
    _avg?: PerformanceEvaluationAvgOrderByAggregateInput
    _max?: PerformanceEvaluationMaxOrderByAggregateInput
    _min?: PerformanceEvaluationMinOrderByAggregateInput
    _sum?: PerformanceEvaluationSumOrderByAggregateInput
  }

  export type PerformanceEvaluationScalarWhereWithAggregatesInput = {
    AND?: PerformanceEvaluationScalarWhereWithAggregatesInput | PerformanceEvaluationScalarWhereWithAggregatesInput[]
    OR?: PerformanceEvaluationScalarWhereWithAggregatesInput[]
    NOT?: PerformanceEvaluationScalarWhereWithAggregatesInput | PerformanceEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceEvaluation"> | string
    period?: StringWithAggregatesFilter<"PerformanceEvaluation"> | string
    score?: FloatWithAggregatesFilter<"PerformanceEvaluation"> | number
    goals?: StringNullableWithAggregatesFilter<"PerformanceEvaluation"> | string | null
    achievements?: StringNullableWithAggregatesFilter<"PerformanceEvaluation"> | string | null
    feedback?: StringNullableWithAggregatesFilter<"PerformanceEvaluation"> | string | null
    status?: StringWithAggregatesFilter<"PerformanceEvaluation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceEvaluation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceEvaluation"> | Date | string
    evaluator_id?: StringWithAggregatesFilter<"PerformanceEvaluation"> | string
    user_id?: StringWithAggregatesFilter<"PerformanceEvaluation"> | string
  }

  export type AdmissionWhereInput = {
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    id?: StringFilter<"Admission"> | string
    hireDate?: DateTimeFilter<"Admission"> | Date | string
    contractType?: StringFilter<"Admission"> | string
    salary?: FloatNullableFilter<"Admission"> | number | null
    benefits?: StringNullableFilter<"Admission"> | string | null
    terminationDate?: DateTimeNullableFilter<"Admission"> | Date | string | null
    terminationReason?: StringNullableFilter<"Admission"> | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    user_id?: StringFilter<"Admission"> | string
    position_id?: StringNullableFilter<"Admission"> | string | null
    department_id?: StringNullableFilter<"Admission"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    position?: XOR<PositionNullableRelationFilter, PositionWhereInput> | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    documents?: AdmissionDocumentListRelationFilter
  }

  export type AdmissionOrderByWithRelationInput = {
    id?: SortOrder
    hireDate?: SortOrder
    contractType?: SortOrder
    salary?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    terminationDate?: SortOrderInput | SortOrder
    terminationReason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
    position_id?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    documents?: AdmissionDocumentOrderByRelationAggregateInput
  }

  export type AdmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    hireDate?: DateTimeFilter<"Admission"> | Date | string
    contractType?: StringFilter<"Admission"> | string
    salary?: FloatNullableFilter<"Admission"> | number | null
    benefits?: StringNullableFilter<"Admission"> | string | null
    terminationDate?: DateTimeNullableFilter<"Admission"> | Date | string | null
    terminationReason?: StringNullableFilter<"Admission"> | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    position_id?: StringNullableFilter<"Admission"> | string | null
    department_id?: StringNullableFilter<"Admission"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    position?: XOR<PositionNullableRelationFilter, PositionWhereInput> | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    documents?: AdmissionDocumentListRelationFilter
  }, "id" | "user_id">

  export type AdmissionOrderByWithAggregationInput = {
    id?: SortOrder
    hireDate?: SortOrder
    contractType?: SortOrder
    salary?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    terminationDate?: SortOrderInput | SortOrder
    terminationReason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
    position_id?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    _count?: AdmissionCountOrderByAggregateInput
    _avg?: AdmissionAvgOrderByAggregateInput
    _max?: AdmissionMaxOrderByAggregateInput
    _min?: AdmissionMinOrderByAggregateInput
    _sum?: AdmissionSumOrderByAggregateInput
  }

  export type AdmissionScalarWhereWithAggregatesInput = {
    AND?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    OR?: AdmissionScalarWhereWithAggregatesInput[]
    NOT?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admission"> | string
    hireDate?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    contractType?: StringWithAggregatesFilter<"Admission"> | string
    salary?: FloatNullableWithAggregatesFilter<"Admission"> | number | null
    benefits?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    terminationDate?: DateTimeNullableWithAggregatesFilter<"Admission"> | Date | string | null
    terminationReason?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    status?: StringWithAggregatesFilter<"Admission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    user_id?: StringWithAggregatesFilter<"Admission"> | string
    position_id?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    department_id?: StringNullableWithAggregatesFilter<"Admission"> | string | null
  }

  export type AdmissionDocumentWhereInput = {
    AND?: AdmissionDocumentWhereInput | AdmissionDocumentWhereInput[]
    OR?: AdmissionDocumentWhereInput[]
    NOT?: AdmissionDocumentWhereInput | AdmissionDocumentWhereInput[]
    id?: StringFilter<"AdmissionDocument"> | string
    admissionId?: StringFilter<"AdmissionDocument"> | string
    fileName?: StringFilter<"AdmissionDocument"> | string
    fileType?: StringFilter<"AdmissionDocument"> | string
    fileSize?: IntFilter<"AdmissionDocument"> | number
    filePath?: StringFilter<"AdmissionDocument"> | string
    uploadedAt?: DateTimeFilter<"AdmissionDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"AdmissionDocument"> | string | null
    admission?: XOR<AdmissionRelationFilter, AdmissionWhereInput>
  }

  export type AdmissionDocumentOrderByWithRelationInput = {
    id?: SortOrder
    admissionId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    admission?: AdmissionOrderByWithRelationInput
  }

  export type AdmissionDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdmissionDocumentWhereInput | AdmissionDocumentWhereInput[]
    OR?: AdmissionDocumentWhereInput[]
    NOT?: AdmissionDocumentWhereInput | AdmissionDocumentWhereInput[]
    admissionId?: StringFilter<"AdmissionDocument"> | string
    fileName?: StringFilter<"AdmissionDocument"> | string
    fileType?: StringFilter<"AdmissionDocument"> | string
    fileSize?: IntFilter<"AdmissionDocument"> | number
    filePath?: StringFilter<"AdmissionDocument"> | string
    uploadedAt?: DateTimeFilter<"AdmissionDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"AdmissionDocument"> | string | null
    admission?: XOR<AdmissionRelationFilter, AdmissionWhereInput>
  }, "id">

  export type AdmissionDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    admissionId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    _count?: AdmissionDocumentCountOrderByAggregateInput
    _avg?: AdmissionDocumentAvgOrderByAggregateInput
    _max?: AdmissionDocumentMaxOrderByAggregateInput
    _min?: AdmissionDocumentMinOrderByAggregateInput
    _sum?: AdmissionDocumentSumOrderByAggregateInput
  }

  export type AdmissionDocumentScalarWhereWithAggregatesInput = {
    AND?: AdmissionDocumentScalarWhereWithAggregatesInput | AdmissionDocumentScalarWhereWithAggregatesInput[]
    OR?: AdmissionDocumentScalarWhereWithAggregatesInput[]
    NOT?: AdmissionDocumentScalarWhereWithAggregatesInput | AdmissionDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmissionDocument"> | string
    admissionId?: StringWithAggregatesFilter<"AdmissionDocument"> | string
    fileName?: StringWithAggregatesFilter<"AdmissionDocument"> | string
    fileType?: StringWithAggregatesFilter<"AdmissionDocument"> | string
    fileSize?: IntWithAggregatesFilter<"AdmissionDocument"> | number
    filePath?: StringWithAggregatesFilter<"AdmissionDocument"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"AdmissionDocument"> | Date | string
    uploadedBy?: StringNullableWithAggregatesFilter<"AdmissionDocument"> | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    startDate?: DateTimeFilter<"Task"> | Date | string
    endDate?: DateTimeFilter<"Task"> | Date | string
    userId?: StringNullableFilter<"Task"> | string | null
    groupId?: StringNullableFilter<"Task"> | string | null
    isActive?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    trainingId?: StringNullableFilter<"Task"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    group?: XOR<GroupNullableRelationFilter, GroupWhereInput> | null
    training?: XOR<TrainingNullableRelationFilter, TrainingWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    userId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
    training?: TrainingOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    startDate?: DateTimeFilter<"Task"> | Date | string
    endDate?: DateTimeFilter<"Task"> | Date | string
    userId?: StringNullableFilter<"Task"> | string | null
    groupId?: StringNullableFilter<"Task"> | string | null
    isActive?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    trainingId?: StringNullableFilter<"Task"> | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    group?: XOR<GroupNullableRelationFilter, GroupWhereInput> | null
    training?: XOR<TrainingNullableRelationFilter, TrainingWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    userId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    groupId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    isActive?: BoolWithAggregatesFilter<"Task"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    trainingId?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    tasks?: TaskListRelationFilter
    users?: UserListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    description?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
    tasks?: TaskListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "name">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type ReportDocumentWhereInput = {
    AND?: ReportDocumentWhereInput | ReportDocumentWhereInput[]
    OR?: ReportDocumentWhereInput[]
    NOT?: ReportDocumentWhereInput | ReportDocumentWhereInput[]
    id?: StringFilter<"ReportDocument"> | string
    reportId?: StringFilter<"ReportDocument"> | string
    fileName?: StringFilter<"ReportDocument"> | string
    fileType?: StringFilter<"ReportDocument"> | string
    fileSize?: IntFilter<"ReportDocument"> | number
    filePath?: StringFilter<"ReportDocument"> | string
    uploaded_at?: DateTimeFilter<"ReportDocument"> | Date | string
    uploaded_by?: StringNullableFilter<"ReportDocument"> | string | null
    report?: XOR<ReportsRelationFilter, reportsWhereInput>
  }

  export type ReportDocumentOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
    uploaded_by?: SortOrderInput | SortOrder
    report?: reportsOrderByWithRelationInput
  }

  export type ReportDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportDocumentWhereInput | ReportDocumentWhereInput[]
    OR?: ReportDocumentWhereInput[]
    NOT?: ReportDocumentWhereInput | ReportDocumentWhereInput[]
    reportId?: StringFilter<"ReportDocument"> | string
    fileName?: StringFilter<"ReportDocument"> | string
    fileType?: StringFilter<"ReportDocument"> | string
    fileSize?: IntFilter<"ReportDocument"> | number
    filePath?: StringFilter<"ReportDocument"> | string
    uploaded_at?: DateTimeFilter<"ReportDocument"> | Date | string
    uploaded_by?: StringNullableFilter<"ReportDocument"> | string | null
    report?: XOR<ReportsRelationFilter, reportsWhereInput>
  }, "id">

  export type ReportDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
    uploaded_by?: SortOrderInput | SortOrder
    _count?: ReportDocumentCountOrderByAggregateInput
    _avg?: ReportDocumentAvgOrderByAggregateInput
    _max?: ReportDocumentMaxOrderByAggregateInput
    _min?: ReportDocumentMinOrderByAggregateInput
    _sum?: ReportDocumentSumOrderByAggregateInput
  }

  export type ReportDocumentScalarWhereWithAggregatesInput = {
    AND?: ReportDocumentScalarWhereWithAggregatesInput | ReportDocumentScalarWhereWithAggregatesInput[]
    OR?: ReportDocumentScalarWhereWithAggregatesInput[]
    NOT?: ReportDocumentScalarWhereWithAggregatesInput | ReportDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportDocument"> | string
    reportId?: StringWithAggregatesFilter<"ReportDocument"> | string
    fileName?: StringWithAggregatesFilter<"ReportDocument"> | string
    fileType?: StringWithAggregatesFilter<"ReportDocument"> | string
    fileSize?: IntWithAggregatesFilter<"ReportDocument"> | number
    filePath?: StringWithAggregatesFilter<"ReportDocument"> | string
    uploaded_at?: DateTimeWithAggregatesFilter<"ReportDocument"> | Date | string
    uploaded_by?: StringNullableWithAggregatesFilter<"ReportDocument"> | string | null
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    category?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    category?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id" | "key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    category?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    receiverId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    isBot?: BoolFilter<"ChatMessage"> | boolean
    isRead?: BoolFilter<"ChatMessage"> | boolean
    messageType?: StringFilter<"ChatMessage"> | string
    sender_id?: StringFilter<"ChatMessage"> | string
    receiver?: XOR<UserRelationFilter, UserWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    isBot?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    sender_id?: SortOrder
    receiver?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    receiverId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    isBot?: BoolFilter<"ChatMessage"> | boolean
    isRead?: BoolFilter<"ChatMessage"> | boolean
    messageType?: StringFilter<"ChatMessage"> | string
    sender_id?: StringFilter<"ChatMessage"> | string
    receiver?: XOR<UserRelationFilter, UserWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    isBot?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    sender_id?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    receiverId?: StringWithAggregatesFilter<"ChatMessage"> | string
    message?: StringWithAggregatesFilter<"ChatMessage"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    isBot?: BoolWithAggregatesFilter<"ChatMessage"> | boolean
    isRead?: BoolWithAggregatesFilter<"ChatMessage"> | boolean
    messageType?: StringWithAggregatesFilter<"ChatMessage"> | string
    sender_id?: StringWithAggregatesFilter<"ChatMessage"> | string
  }

  export type TrainingWhereInput = {
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    id?: StringFilter<"Training"> | string
    name?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    status?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    progress?: FloatNullableFilter<"Training"> | number | null
    instructorId?: StringNullableFilter<"Training"> | string | null
    instructor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    training_participations?: UserTrainingListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type TrainingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progress?: SortOrderInput | SortOrder
    instructorId?: SortOrderInput | SortOrder
    instructor?: UserOrderByWithRelationInput
    training_participations?: UserTrainingOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type TrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingWhereInput | TrainingWhereInput[]
    OR?: TrainingWhereInput[]
    NOT?: TrainingWhereInput | TrainingWhereInput[]
    name?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    status?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    progress?: FloatNullableFilter<"Training"> | number | null
    instructorId?: StringNullableFilter<"Training"> | string | null
    instructor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    training_participations?: UserTrainingListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id">

  export type TrainingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progress?: SortOrderInput | SortOrder
    instructorId?: SortOrderInput | SortOrder
    _count?: TrainingCountOrderByAggregateInput
    _avg?: TrainingAvgOrderByAggregateInput
    _max?: TrainingMaxOrderByAggregateInput
    _min?: TrainingMinOrderByAggregateInput
    _sum?: TrainingSumOrderByAggregateInput
  }

  export type TrainingScalarWhereWithAggregatesInput = {
    AND?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    OR?: TrainingScalarWhereWithAggregatesInput[]
    NOT?: TrainingScalarWhereWithAggregatesInput | TrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Training"> | string
    name?: StringWithAggregatesFilter<"Training"> | string
    description?: StringNullableWithAggregatesFilter<"Training"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    maxParticipants?: IntNullableWithAggregatesFilter<"Training"> | number | null
    status?: StringWithAggregatesFilter<"Training"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Training"> | Date | string
    progress?: FloatNullableWithAggregatesFilter<"Training"> | number | null
    instructorId?: StringNullableWithAggregatesFilter<"Training"> | string | null
  }

  export type UserTrainingWhereInput = {
    AND?: UserTrainingWhereInput | UserTrainingWhereInput[]
    OR?: UserTrainingWhereInput[]
    NOT?: UserTrainingWhereInput | UserTrainingWhereInput[]
    id?: StringFilter<"UserTraining"> | string
    enrolledAt?: DateTimeFilter<"UserTraining"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserTraining"> | Date | string | null
    status?: StringFilter<"UserTraining"> | string
    score?: FloatNullableFilter<"UserTraining"> | number | null
    certificate?: StringNullableFilter<"UserTraining"> | string | null
    training_id?: StringFilter<"UserTraining"> | string
    user_id?: StringFilter<"UserTraining"> | string
    progress?: FloatNullableFilter<"UserTraining"> | number | null
    trainings?: XOR<TrainingRelationFilter, TrainingWhereInput>
    users?: XOR<UserRelationFilter, UserWhereInput>
    documents?: TrainingDocumentListRelationFilter
  }

  export type UserTrainingOrderByWithRelationInput = {
    id?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    certificate?: SortOrderInput | SortOrder
    training_id?: SortOrder
    user_id?: SortOrder
    progress?: SortOrderInput | SortOrder
    trainings?: TrainingOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
    documents?: TrainingDocumentOrderByRelationAggregateInput
  }

  export type UserTrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_training_id?: UserTrainingUser_idTraining_idCompoundUniqueInput
    AND?: UserTrainingWhereInput | UserTrainingWhereInput[]
    OR?: UserTrainingWhereInput[]
    NOT?: UserTrainingWhereInput | UserTrainingWhereInput[]
    enrolledAt?: DateTimeFilter<"UserTraining"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserTraining"> | Date | string | null
    status?: StringFilter<"UserTraining"> | string
    score?: FloatNullableFilter<"UserTraining"> | number | null
    certificate?: StringNullableFilter<"UserTraining"> | string | null
    training_id?: StringFilter<"UserTraining"> | string
    user_id?: StringFilter<"UserTraining"> | string
    progress?: FloatNullableFilter<"UserTraining"> | number | null
    trainings?: XOR<TrainingRelationFilter, TrainingWhereInput>
    users?: XOR<UserRelationFilter, UserWhereInput>
    documents?: TrainingDocumentListRelationFilter
  }, "id" | "user_id_training_id">

  export type UserTrainingOrderByWithAggregationInput = {
    id?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    certificate?: SortOrderInput | SortOrder
    training_id?: SortOrder
    user_id?: SortOrder
    progress?: SortOrderInput | SortOrder
    _count?: UserTrainingCountOrderByAggregateInput
    _avg?: UserTrainingAvgOrderByAggregateInput
    _max?: UserTrainingMaxOrderByAggregateInput
    _min?: UserTrainingMinOrderByAggregateInput
    _sum?: UserTrainingSumOrderByAggregateInput
  }

  export type UserTrainingScalarWhereWithAggregatesInput = {
    AND?: UserTrainingScalarWhereWithAggregatesInput | UserTrainingScalarWhereWithAggregatesInput[]
    OR?: UserTrainingScalarWhereWithAggregatesInput[]
    NOT?: UserTrainingScalarWhereWithAggregatesInput | UserTrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTraining"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"UserTraining"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserTraining"> | Date | string | null
    status?: StringWithAggregatesFilter<"UserTraining"> | string
    score?: FloatNullableWithAggregatesFilter<"UserTraining"> | number | null
    certificate?: StringNullableWithAggregatesFilter<"UserTraining"> | string | null
    training_id?: StringWithAggregatesFilter<"UserTraining"> | string
    user_id?: StringWithAggregatesFilter<"UserTraining"> | string
    progress?: FloatNullableWithAggregatesFilter<"UserTraining"> | number | null
  }

  export type TrainingDocumentWhereInput = {
    AND?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    OR?: TrainingDocumentWhereInput[]
    NOT?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    id?: StringFilter<"TrainingDocument"> | string
    userTrainingId?: StringFilter<"TrainingDocument"> | string
    fileName?: StringFilter<"TrainingDocument"> | string
    fileType?: StringFilter<"TrainingDocument"> | string
    fileSize?: IntFilter<"TrainingDocument"> | number
    filePath?: StringFilter<"TrainingDocument"> | string
    uploadedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"TrainingDocument"> | string | null
    userTraining?: XOR<UserTrainingRelationFilter, UserTrainingWhereInput>
  }

  export type TrainingDocumentOrderByWithRelationInput = {
    id?: SortOrder
    userTrainingId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    userTraining?: UserTrainingOrderByWithRelationInput
  }

  export type TrainingDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    OR?: TrainingDocumentWhereInput[]
    NOT?: TrainingDocumentWhereInput | TrainingDocumentWhereInput[]
    userTrainingId?: StringFilter<"TrainingDocument"> | string
    fileName?: StringFilter<"TrainingDocument"> | string
    fileType?: StringFilter<"TrainingDocument"> | string
    fileSize?: IntFilter<"TrainingDocument"> | number
    filePath?: StringFilter<"TrainingDocument"> | string
    uploadedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"TrainingDocument"> | string | null
    userTraining?: XOR<UserTrainingRelationFilter, UserTrainingWhereInput>
  }, "id">

  export type TrainingDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userTrainingId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    _count?: TrainingDocumentCountOrderByAggregateInput
    _avg?: TrainingDocumentAvgOrderByAggregateInput
    _max?: TrainingDocumentMaxOrderByAggregateInput
    _min?: TrainingDocumentMinOrderByAggregateInput
    _sum?: TrainingDocumentSumOrderByAggregateInput
  }

  export type TrainingDocumentScalarWhereWithAggregatesInput = {
    AND?: TrainingDocumentScalarWhereWithAggregatesInput | TrainingDocumentScalarWhereWithAggregatesInput[]
    OR?: TrainingDocumentScalarWhereWithAggregatesInput[]
    NOT?: TrainingDocumentScalarWhereWithAggregatesInput | TrainingDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingDocument"> | string
    userTrainingId?: StringWithAggregatesFilter<"TrainingDocument"> | string
    fileName?: StringWithAggregatesFilter<"TrainingDocument"> | string
    fileType?: StringWithAggregatesFilter<"TrainingDocument"> | string
    fileSize?: IntWithAggregatesFilter<"TrainingDocument"> | number
    filePath?: StringWithAggregatesFilter<"TrainingDocument"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"TrainingDocument"> | Date | string
    uploadedBy?: StringNullableWithAggregatesFilter<"TrainingDocument"> | string | null
  }

  export type SupporterWhereInput = {
    AND?: SupporterWhereInput | SupporterWhereInput[]
    OR?: SupporterWhereInput[]
    NOT?: SupporterWhereInput | SupporterWhereInput[]
    id?: StringFilter<"Supporter"> | string
    name?: StringFilter<"Supporter"> | string
    phone?: StringFilter<"Supporter"> | string
    address?: StringFilter<"Supporter"> | string
    cep?: StringFilter<"Supporter"> | string
    mapping?: StringFilter<"Supporter"> | string
    supportType?: StringFilter<"Supporter"> | string
    status?: StringFilter<"Supporter"> | string
    createdAt?: DateTimeFilter<"Supporter"> | Date | string
    updatedAt?: DateTimeFilter<"Supporter"> | Date | string
    lat?: FloatNullableFilter<"Supporter"> | number | null
    lng?: FloatNullableFilter<"Supporter"> | number | null
  }

  export type SupporterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    cep?: SortOrder
    mapping?: SortOrder
    supportType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
  }

  export type SupporterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupporterWhereInput | SupporterWhereInput[]
    OR?: SupporterWhereInput[]
    NOT?: SupporterWhereInput | SupporterWhereInput[]
    name?: StringFilter<"Supporter"> | string
    phone?: StringFilter<"Supporter"> | string
    address?: StringFilter<"Supporter"> | string
    cep?: StringFilter<"Supporter"> | string
    mapping?: StringFilter<"Supporter"> | string
    supportType?: StringFilter<"Supporter"> | string
    status?: StringFilter<"Supporter"> | string
    createdAt?: DateTimeFilter<"Supporter"> | Date | string
    updatedAt?: DateTimeFilter<"Supporter"> | Date | string
    lat?: FloatNullableFilter<"Supporter"> | number | null
    lng?: FloatNullableFilter<"Supporter"> | number | null
  }, "id">

  export type SupporterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    cep?: SortOrder
    mapping?: SortOrder
    supportType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    _count?: SupporterCountOrderByAggregateInput
    _avg?: SupporterAvgOrderByAggregateInput
    _max?: SupporterMaxOrderByAggregateInput
    _min?: SupporterMinOrderByAggregateInput
    _sum?: SupporterSumOrderByAggregateInput
  }

  export type SupporterScalarWhereWithAggregatesInput = {
    AND?: SupporterScalarWhereWithAggregatesInput | SupporterScalarWhereWithAggregatesInput[]
    OR?: SupporterScalarWhereWithAggregatesInput[]
    NOT?: SupporterScalarWhereWithAggregatesInput | SupporterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supporter"> | string
    name?: StringWithAggregatesFilter<"Supporter"> | string
    phone?: StringWithAggregatesFilter<"Supporter"> | string
    address?: StringWithAggregatesFilter<"Supporter"> | string
    cep?: StringWithAggregatesFilter<"Supporter"> | string
    mapping?: StringWithAggregatesFilter<"Supporter"> | string
    supportType?: StringWithAggregatesFilter<"Supporter"> | string
    status?: StringWithAggregatesFilter<"Supporter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Supporter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Supporter"> | Date | string
    lat?: FloatNullableWithAggregatesFilter<"Supporter"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"Supporter"> | number | null
  }

  export type reportsWhereInput = {
    AND?: reportsWhereInput | reportsWhereInput[]
    OR?: reportsWhereInput[]
    NOT?: reportsWhereInput | reportsWhereInput[]
    id?: StringFilter<"reports"> | string
    name?: StringFilter<"reports"> | string
    type?: StringFilter<"reports"> | string
    generated_by?: StringFilter<"reports"> | string
    frequency?: StringNullableFilter<"reports"> | string | null
    scheduledDate?: DateTimeNullableFilter<"reports"> | Date | string | null
    created_at?: DateTimeFilter<"reports"> | Date | string
    documents?: ReportDocumentListRelationFilter
    users?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type reportsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    generated_by?: SortOrder
    frequency?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    created_at?: SortOrder
    documents?: ReportDocumentOrderByRelationAggregateInput
    users?: UserOrderByWithRelationInput
  }

  export type reportsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reportsWhereInput | reportsWhereInput[]
    OR?: reportsWhereInput[]
    NOT?: reportsWhereInput | reportsWhereInput[]
    name?: StringFilter<"reports"> | string
    type?: StringFilter<"reports"> | string
    generated_by?: StringFilter<"reports"> | string
    frequency?: StringNullableFilter<"reports"> | string | null
    scheduledDate?: DateTimeNullableFilter<"reports"> | Date | string | null
    created_at?: DateTimeFilter<"reports"> | Date | string
    documents?: ReportDocumentListRelationFilter
    users?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type reportsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    generated_by?: SortOrder
    frequency?: SortOrderInput | SortOrder
    scheduledDate?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: reportsCountOrderByAggregateInput
    _max?: reportsMaxOrderByAggregateInput
    _min?: reportsMinOrderByAggregateInput
  }

  export type reportsScalarWhereWithAggregatesInput = {
    AND?: reportsScalarWhereWithAggregatesInput | reportsScalarWhereWithAggregatesInput[]
    OR?: reportsScalarWhereWithAggregatesInput[]
    NOT?: reportsScalarWhereWithAggregatesInput | reportsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"reports"> | string
    name?: StringWithAggregatesFilter<"reports"> | string
    type?: StringWithAggregatesFilter<"reports"> | string
    generated_by?: StringWithAggregatesFilter<"reports"> | string
    frequency?: StringNullableWithAggregatesFilter<"reports"> | string | null
    scheduledDate?: DateTimeNullableWithAggregatesFilter<"reports"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"reports"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProfileCreateInput = {
    id?: string
    address?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    document?: string | null
    emergencyContact?: string | null
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    address?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    document?: string | null
    emergencyContact?: string | null
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    address?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    document?: string | null
    emergencyContact?: string | null
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type PositionCreateInput = {
    id?: string
    name: string
    description?: string | null
    salary?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPositionInput
    admissions?: AdmissionCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    salary?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPositionInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPositionNestedInput
    admissions?: AdmissionUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPositionNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    salary?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceEvaluationCreateInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users_performance_evaluations_evaluator_idTousers: UserCreateNestedOneWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput
    users_performance_evaluations_user_idTousers: UserCreateNestedOneWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput
  }

  export type PerformanceEvaluationUncheckedCreateInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluator_id: string
    user_id: string
  }

  export type PerformanceEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_performance_evaluations_evaluator_idTousers?: UserUpdateOneRequiredWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersNestedInput
    users_performance_evaluations_user_idTousers?: UserUpdateOneRequiredWithoutPerformance_evaluations_performance_evaluations_user_idTousersNestedInput
  }

  export type PerformanceEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceEvaluationCreateManyInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluator_id: string
    user_id: string
  }

  export type PerformanceEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdmissionCreateInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdmissionsInput
    position?: PositionCreateNestedOneWithoutAdmissionsInput
    department?: DepartmentCreateNestedOneWithoutAdmissionsInput
    documents?: AdmissionDocumentCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
    position_id?: string | null
    department_id?: string | null
    documents?: AdmissionDocumentUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdmissionsNestedInput
    position?: PositionUpdateOneWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneWithoutAdmissionsNestedInput
    documents?: AdmissionDocumentUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    position_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: AdmissionDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionCreateManyInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
    position_id?: string | null
    department_id?: string | null
  }

  export type AdmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    position_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionDocumentCreateInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
    admission: AdmissionCreateNestedOneWithoutDocumentsInput
  }

  export type AdmissionDocumentUncheckedCreateInput = {
    id?: string
    admissionId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type AdmissionDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: AdmissionUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type AdmissionDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionDocumentCreateManyInput = {
    id?: string
    admissionId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type AdmissionDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTasksInput
    group?: GroupCreateNestedOneWithoutTasksInput
    training?: TrainingCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    userId?: string | null
    groupId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId?: string | null
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTasksNestedInput
    group?: GroupUpdateOneWithoutTasksNestedInput
    training?: TrainingUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    userId?: string | null
    groupId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutGroupInput
    users?: UserCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutGroupInput
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutGroupNestedInput
    users?: UserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutGroupNestedInput
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportDocumentCreateInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploaded_at?: Date | string
    uploaded_by?: string | null
    report: reportsCreateNestedOneWithoutDocumentsInput
  }

  export type ReportDocumentUncheckedCreateInput = {
    id?: string
    reportId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploaded_at?: Date | string
    uploaded_by?: string | null
  }

  export type ReportDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
    report?: reportsUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type ReportDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportDocumentCreateManyInput = {
    id?: string
    reportId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploaded_at?: Date | string
    uploaded_by?: string | null
  }

  export type ReportDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    receiverId: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
    sender_id: string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    receiverId: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
    sender_id: string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
  }

  export type TrainingCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    instructor?: UserCreateNestedOneWithoutTrainingsInput
    training_participations?: UserTrainingCreateNestedManyWithoutTrainingsInput
    tasks?: TaskCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    instructorId?: string | null
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutTrainingsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    instructor?: UserUpdateOneWithoutTrainingsNestedInput
    training_participations?: UserTrainingUpdateManyWithoutTrainingsNestedInput
    tasks?: TaskUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    training_participations?: UserTrainingUncheckedUpdateManyWithoutTrainingsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    instructorId?: string | null
  }

  export type TrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTrainingCreateInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    progress?: number | null
    trainings: TrainingCreateNestedOneWithoutTraining_participationsInput
    users: UserCreateNestedOneWithoutTraining_participationsInput
    documents?: TrainingDocumentCreateNestedManyWithoutUserTrainingInput
  }

  export type UserTrainingUncheckedCreateInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    training_id: string
    user_id: string
    progress?: number | null
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutUserTrainingInput
  }

  export type UserTrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    trainings?: TrainingUpdateOneRequiredWithoutTraining_participationsNestedInput
    users?: UserUpdateOneRequiredWithoutTraining_participationsNestedInput
    documents?: TrainingDocumentUpdateManyWithoutUserTrainingNestedInput
  }

  export type UserTrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    documents?: TrainingDocumentUncheckedUpdateManyWithoutUserTrainingNestedInput
  }

  export type UserTrainingCreateManyInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    training_id: string
    user_id: string
    progress?: number | null
  }

  export type UserTrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserTrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TrainingDocumentCreateInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
    userTraining: UserTrainingCreateNestedOneWithoutDocumentsInput
  }

  export type TrainingDocumentUncheckedCreateInput = {
    id?: string
    userTrainingId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type TrainingDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userTraining?: UserTrainingUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type TrainingDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userTrainingId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingDocumentCreateManyInput = {
    id?: string
    userTrainingId: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type TrainingDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userTrainingId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupporterCreateInput = {
    id?: string
    name: string
    phone: string
    address: string
    cep: string
    mapping: string
    supportType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lat?: number | null
    lng?: number | null
  }

  export type SupporterUncheckedCreateInput = {
    id?: string
    name: string
    phone: string
    address: string
    cep: string
    mapping: string
    supportType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lat?: number | null
    lng?: number | null
  }

  export type SupporterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    mapping?: StringFieldUpdateOperationsInput | string
    supportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SupporterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    mapping?: StringFieldUpdateOperationsInput | string
    supportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SupporterCreateManyInput = {
    id?: string
    name: string
    phone: string
    address: string
    cep: string
    mapping: string
    supportType: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lat?: number | null
    lng?: number | null
  }

  export type SupporterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    mapping?: StringFieldUpdateOperationsInput | string
    supportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SupporterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    cep?: StringFieldUpdateOperationsInput | string
    mapping?: StringFieldUpdateOperationsInput | string
    supportType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type reportsCreateInput = {
    id: string
    name: string
    type: string
    frequency?: string | null
    scheduledDate?: Date | string | null
    created_at?: Date | string
    documents?: ReportDocumentCreateNestedManyWithoutReportInput
    users: UserCreateNestedOneWithoutReportsInput
  }

  export type reportsUncheckedCreateInput = {
    id: string
    name: string
    type: string
    generated_by: string
    frequency?: string | null
    scheduledDate?: Date | string | null
    created_at?: Date | string
    documents?: ReportDocumentUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ReportDocumentUpdateManyWithoutReportNestedInput
    users?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    generated_by?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ReportDocumentUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportsCreateManyInput = {
    id: string
    name: string
    type: string
    generated_by: string
    frequency?: string | null
    scheduledDate?: Date | string | null
    created_at?: Date | string
  }

  export type reportsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    generated_by?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AdmissionNullableRelationFilter = {
    is?: AdmissionWhereInput | null
    isNot?: AdmissionWhereInput | null
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type PerformanceEvaluationListRelationFilter = {
    every?: PerformanceEvaluationWhereInput
    some?: PerformanceEvaluationWhereInput
    none?: PerformanceEvaluationWhereInput
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type ReportsListRelationFilter = {
    every?: reportsWhereInput
    some?: reportsWhereInput
    none?: reportsWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type UserTrainingListRelationFilter = {
    every?: UserTrainingWhereInput
    some?: UserTrainingWhereInput
    none?: UserTrainingWhereInput
  }

  export type TrainingListRelationFilter = {
    every?: TrainingWhereInput
    some?: TrainingWhereInput
    none?: TrainingWhereInput
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type PositionNullableRelationFilter = {
    is?: PositionWhereInput | null
    isNot?: PositionWhereInput | null
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTrainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    last_login?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    surname?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    last_login?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    surname?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    last_login?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    surname?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    document?: SortOrder
    emergencyContact?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    document?: SortOrder
    emergencyContact?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    document?: SortOrder
    emergencyContact?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type AdmissionListRelationFilter = {
    every?: AdmissionWhereInput
    some?: AdmissionWhereInput
    none?: AdmissionWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    salary?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    salary?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    salary?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PerformanceEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    score?: SortOrder
    goals?: SortOrder
    achievements?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluator_id?: SortOrder
    user_id?: SortOrder
  }

  export type PerformanceEvaluationAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type PerformanceEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    score?: SortOrder
    goals?: SortOrder
    achievements?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluator_id?: SortOrder
    user_id?: SortOrder
  }

  export type PerformanceEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    score?: SortOrder
    goals?: SortOrder
    achievements?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluator_id?: SortOrder
    user_id?: SortOrder
  }

  export type PerformanceEvaluationSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AdmissionDocumentListRelationFilter = {
    every?: AdmissionDocumentWhereInput
    some?: AdmissionDocumentWhereInput
    none?: AdmissionDocumentWhereInput
  }

  export type AdmissionDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionCountOrderByAggregateInput = {
    id?: SortOrder
    hireDate?: SortOrder
    contractType?: SortOrder
    salary?: SortOrder
    benefits?: SortOrder
    terminationDate?: SortOrder
    terminationReason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
    position_id?: SortOrder
    department_id?: SortOrder
  }

  export type AdmissionAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type AdmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    hireDate?: SortOrder
    contractType?: SortOrder
    salary?: SortOrder
    benefits?: SortOrder
    terminationDate?: SortOrder
    terminationReason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
    position_id?: SortOrder
    department_id?: SortOrder
  }

  export type AdmissionMinOrderByAggregateInput = {
    id?: SortOrder
    hireDate?: SortOrder
    contractType?: SortOrder
    salary?: SortOrder
    benefits?: SortOrder
    terminationDate?: SortOrder
    terminationReason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user_id?: SortOrder
    position_id?: SortOrder
    department_id?: SortOrder
  }

  export type AdmissionSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AdmissionRelationFilter = {
    is?: AdmissionWhereInput
    isNot?: AdmissionWhereInput
  }

  export type AdmissionDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type AdmissionDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type AdmissionDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type AdmissionDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type AdmissionDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type GroupNullableRelationFilter = {
    is?: GroupWhereInput | null
    isNot?: GroupWhereInput | null
  }

  export type TrainingNullableRelationFilter = {
    is?: TrainingWhereInput | null
    isNot?: TrainingWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    userId?: SortOrder
    groupId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trainingId?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportsRelationFilter = {
    is?: reportsWhereInput
    isNot?: reportsWhereInput
  }

  export type ReportDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
    uploaded_by?: SortOrder
  }

  export type ReportDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ReportDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
    uploaded_by?: SortOrder
  }

  export type ReportDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
    uploaded_by?: SortOrder
  }

  export type ReportDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    isBot?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    sender_id?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    isBot?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    sender_id?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    receiverId?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    isBot?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    sender_id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TrainingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progress?: SortOrder
    instructorId?: SortOrder
  }

  export type TrainingAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
    progress?: SortOrder
  }

  export type TrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progress?: SortOrder
    instructorId?: SortOrder
  }

  export type TrainingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progress?: SortOrder
    instructorId?: SortOrder
  }

  export type TrainingSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
    progress?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TrainingRelationFilter = {
    is?: TrainingWhereInput
    isNot?: TrainingWhereInput
  }

  export type TrainingDocumentListRelationFilter = {
    every?: TrainingDocumentWhereInput
    some?: TrainingDocumentWhereInput
    none?: TrainingDocumentWhereInput
  }

  export type TrainingDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTrainingUser_idTraining_idCompoundUniqueInput = {
    user_id: string
    training_id: string
  }

  export type UserTrainingCountOrderByAggregateInput = {
    id?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    score?: SortOrder
    certificate?: SortOrder
    training_id?: SortOrder
    user_id?: SortOrder
    progress?: SortOrder
  }

  export type UserTrainingAvgOrderByAggregateInput = {
    score?: SortOrder
    progress?: SortOrder
  }

  export type UserTrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    score?: SortOrder
    certificate?: SortOrder
    training_id?: SortOrder
    user_id?: SortOrder
    progress?: SortOrder
  }

  export type UserTrainingMinOrderByAggregateInput = {
    id?: SortOrder
    enrolledAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    score?: SortOrder
    certificate?: SortOrder
    training_id?: SortOrder
    user_id?: SortOrder
    progress?: SortOrder
  }

  export type UserTrainingSumOrderByAggregateInput = {
    score?: SortOrder
    progress?: SortOrder
  }

  export type UserTrainingRelationFilter = {
    is?: UserTrainingWhereInput
    isNot?: UserTrainingWhereInput
  }

  export type TrainingDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userTrainingId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type TrainingDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type TrainingDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userTrainingId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type TrainingDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userTrainingId?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    filePath?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
  }

  export type TrainingDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type SupporterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    cep?: SortOrder
    mapping?: SortOrder
    supportType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type SupporterAvgOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type SupporterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    cep?: SortOrder
    mapping?: SortOrder
    supportType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type SupporterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    cep?: SortOrder
    mapping?: SortOrder
    supportType?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
  }

  export type SupporterSumOrderByAggregateInput = {
    lat?: SortOrder
    lng?: SortOrder
  }

  export type ReportDocumentListRelationFilter = {
    every?: ReportDocumentWhereInput
    some?: ReportDocumentWhereInput
    none?: ReportDocumentWhereInput
  }

  export type ReportDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    generated_by?: SortOrder
    frequency?: SortOrder
    scheduledDate?: SortOrder
    created_at?: SortOrder
  }

  export type reportsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    generated_by?: SortOrder
    frequency?: SortOrder
    scheduledDate?: SortOrder
    created_at?: SortOrder
  }

  export type reportsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    generated_by?: SortOrder
    frequency?: SortOrder
    scheduledDate?: SortOrder
    created_at?: SortOrder
  }

  export type AdmissionCreateNestedOneWithoutUserInput = {
    create?: XOR<AdmissionCreateWithoutUserInput, AdmissionUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutUserInput
    connect?: AdmissionWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    create?: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput> | PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput[] | PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    connectOrCreate?: PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    createMany?: PerformanceEvaluationCreateManyUsers_performance_evaluations_evaluator_idTousersInputEnvelope
    connect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
  }

  export type PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput = {
    create?: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput> | PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput[] | PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput[]
    connectOrCreate?: PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput[]
    createMany?: PerformanceEvaluationCreateManyUsers_performance_evaluations_user_idTousersInputEnvelope
    connect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type reportsCreateNestedManyWithoutUsersInput = {
    create?: XOR<reportsCreateWithoutUsersInput, reportsUncheckedCreateWithoutUsersInput> | reportsCreateWithoutUsersInput[] | reportsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportsCreateOrConnectWithoutUsersInput | reportsCreateOrConnectWithoutUsersInput[]
    createMany?: reportsCreateManyUsersInputEnvelope
    connect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserTrainingCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserTrainingCreateWithoutUsersInput, UserTrainingUncheckedCreateWithoutUsersInput> | UserTrainingCreateWithoutUsersInput[] | UserTrainingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserTrainingCreateOrConnectWithoutUsersInput | UserTrainingCreateOrConnectWithoutUsersInput[]
    createMany?: UserTrainingCreateManyUsersInputEnvelope
    connect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
  }

  export type TrainingCreateNestedManyWithoutInstructorInput = {
    create?: XOR<TrainingCreateWithoutInstructorInput, TrainingUncheckedCreateWithoutInstructorInput> | TrainingCreateWithoutInstructorInput[] | TrainingUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutInstructorInput | TrainingCreateOrConnectWithoutInstructorInput[]
    createMany?: TrainingCreateManyInstructorInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutUsersInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutUsersInput = {
    create?: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PositionCreateOrConnectWithoutUsersInput
    connect?: PositionWhereUniqueInput
  }

  export type GroupCreateNestedManyWithoutUsersInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput> | GroupCreateWithoutUsersInput[] | GroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput | GroupCreateOrConnectWithoutUsersInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdmissionCreateWithoutUserInput, AdmissionUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutUserInput
    connect?: AdmissionWhereUniqueInput
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    create?: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput> | PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput[] | PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    connectOrCreate?: PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    createMany?: PerformanceEvaluationCreateManyUsers_performance_evaluations_evaluator_idTousersInputEnvelope
    connect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
  }

  export type PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput = {
    create?: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput> | PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput[] | PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput[]
    connectOrCreate?: PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput[]
    createMany?: PerformanceEvaluationCreateManyUsers_performance_evaluations_user_idTousersInputEnvelope
    connect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type reportsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<reportsCreateWithoutUsersInput, reportsUncheckedCreateWithoutUsersInput> | reportsCreateWithoutUsersInput[] | reportsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportsCreateOrConnectWithoutUsersInput | reportsCreateOrConnectWithoutUsersInput[]
    createMany?: reportsCreateManyUsersInputEnvelope
    connect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserTrainingUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserTrainingCreateWithoutUsersInput, UserTrainingUncheckedCreateWithoutUsersInput> | UserTrainingCreateWithoutUsersInput[] | UserTrainingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserTrainingCreateOrConnectWithoutUsersInput | UserTrainingCreateOrConnectWithoutUsersInput[]
    createMany?: UserTrainingCreateManyUsersInputEnvelope
    connect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
  }

  export type TrainingUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<TrainingCreateWithoutInstructorInput, TrainingUncheckedCreateWithoutInstructorInput> | TrainingCreateWithoutInstructorInput[] | TrainingUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutInstructorInput | TrainingCreateOrConnectWithoutInstructorInput[]
    createMany?: TrainingCreateManyInstructorInputEnvelope
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput> | GroupCreateWithoutUsersInput[] | GroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput | GroupCreateOrConnectWithoutUsersInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AdmissionUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdmissionCreateWithoutUserInput, AdmissionUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutUserInput
    upsert?: AdmissionUpsertWithoutUserInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutUserInput, AdmissionUpdateWithoutUserInput>, AdmissionUncheckedUpdateWithoutUserInput>
  }

  export type ChatMessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput = {
    create?: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput> | PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput[] | PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    connectOrCreate?: PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    upsert?: PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    createMany?: PerformanceEvaluationCreateManyUsers_performance_evaluations_evaluator_idTousersInputEnvelope
    set?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    disconnect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    delete?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    connect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    update?: PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    updateMany?: PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    deleteMany?: PerformanceEvaluationScalarWhereInput | PerformanceEvaluationScalarWhereInput[]
  }

  export type PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput = {
    create?: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput> | PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput[] | PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput[]
    connectOrCreate?: PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput[]
    upsert?: PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput[]
    createMany?: PerformanceEvaluationCreateManyUsers_performance_evaluations_user_idTousersInputEnvelope
    set?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    disconnect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    delete?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    connect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    update?: PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput[]
    updateMany?: PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_user_idTousersInput[]
    deleteMany?: PerformanceEvaluationScalarWhereInput | PerformanceEvaluationScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type reportsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reportsCreateWithoutUsersInput, reportsUncheckedCreateWithoutUsersInput> | reportsCreateWithoutUsersInput[] | reportsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportsCreateOrConnectWithoutUsersInput | reportsCreateOrConnectWithoutUsersInput[]
    upsert?: reportsUpsertWithWhereUniqueWithoutUsersInput | reportsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reportsCreateManyUsersInputEnvelope
    set?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    disconnect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    delete?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    connect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    update?: reportsUpdateWithWhereUniqueWithoutUsersInput | reportsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reportsUpdateManyWithWhereWithoutUsersInput | reportsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reportsScalarWhereInput | reportsScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserTrainingUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserTrainingCreateWithoutUsersInput, UserTrainingUncheckedCreateWithoutUsersInput> | UserTrainingCreateWithoutUsersInput[] | UserTrainingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserTrainingCreateOrConnectWithoutUsersInput | UserTrainingCreateOrConnectWithoutUsersInput[]
    upsert?: UserTrainingUpsertWithWhereUniqueWithoutUsersInput | UserTrainingUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserTrainingCreateManyUsersInputEnvelope
    set?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    disconnect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    delete?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    connect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    update?: UserTrainingUpdateWithWhereUniqueWithoutUsersInput | UserTrainingUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserTrainingUpdateManyWithWhereWithoutUsersInput | UserTrainingUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserTrainingScalarWhereInput | UserTrainingScalarWhereInput[]
  }

  export type TrainingUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<TrainingCreateWithoutInstructorInput, TrainingUncheckedCreateWithoutInstructorInput> | TrainingCreateWithoutInstructorInput[] | TrainingUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutInstructorInput | TrainingCreateOrConnectWithoutInstructorInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutInstructorInput | TrainingUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: TrainingCreateManyInstructorInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutInstructorInput | TrainingUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutInstructorInput | TrainingUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    upsert?: DepartmentUpsertWithoutUsersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUsersInput, DepartmentUpdateWithoutUsersInput>, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type PositionUpdateOneWithoutUsersNestedInput = {
    create?: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PositionCreateOrConnectWithoutUsersInput
    upsert?: PositionUpsertWithoutUsersInput
    disconnect?: PositionWhereInput | boolean
    delete?: PositionWhereInput | boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutUsersInput, PositionUpdateWithoutUsersInput>, PositionUncheckedUpdateWithoutUsersInput>
  }

  export type GroupUpdateManyWithoutUsersNestedInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput> | GroupCreateWithoutUsersInput[] | GroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput | GroupCreateOrConnectWithoutUsersInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutUsersInput | GroupUpsertWithWhereUniqueWithoutUsersInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutUsersInput | GroupUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutUsersInput | GroupUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdmissionCreateWithoutUserInput, AdmissionUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutUserInput
    upsert?: AdmissionUpsertWithoutUserInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutUserInput, AdmissionUpdateWithoutUserInput>, AdmissionUncheckedUpdateWithoutUserInput>
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput> | ChatMessageCreateWithoutReceiverInput[] | ChatMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutReceiverInput | ChatMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutReceiverInput | ChatMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: ChatMessageCreateManyReceiverInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutReceiverInput | ChatMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutReceiverInput | ChatMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput> | ChatMessageCreateWithoutSenderInput[] | ChatMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSenderInput | ChatMessageCreateOrConnectWithoutSenderInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSenderInput | ChatMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: ChatMessageCreateManySenderInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSenderInput | ChatMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSenderInput | ChatMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput = {
    create?: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput> | PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput[] | PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    connectOrCreate?: PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    upsert?: PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    createMany?: PerformanceEvaluationCreateManyUsers_performance_evaluations_evaluator_idTousersInputEnvelope
    set?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    disconnect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    delete?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    connect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    update?: PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    updateMany?: PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_evaluator_idTousersInput[]
    deleteMany?: PerformanceEvaluationScalarWhereInput | PerformanceEvaluationScalarWhereInput[]
  }

  export type PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput = {
    create?: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput> | PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput[] | PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput[]
    connectOrCreate?: PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput[]
    upsert?: PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput[]
    createMany?: PerformanceEvaluationCreateManyUsers_performance_evaluations_user_idTousersInputEnvelope
    set?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    disconnect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    delete?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    connect?: PerformanceEvaluationWhereUniqueInput | PerformanceEvaluationWhereUniqueInput[]
    update?: PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput[]
    updateMany?: PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_user_idTousersInput[]
    deleteMany?: PerformanceEvaluationScalarWhereInput | PerformanceEvaluationScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type reportsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reportsCreateWithoutUsersInput, reportsUncheckedCreateWithoutUsersInput> | reportsCreateWithoutUsersInput[] | reportsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportsCreateOrConnectWithoutUsersInput | reportsCreateOrConnectWithoutUsersInput[]
    upsert?: reportsUpsertWithWhereUniqueWithoutUsersInput | reportsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reportsCreateManyUsersInputEnvelope
    set?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    disconnect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    delete?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    connect?: reportsWhereUniqueInput | reportsWhereUniqueInput[]
    update?: reportsUpdateWithWhereUniqueWithoutUsersInput | reportsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reportsUpdateManyWithWhereWithoutUsersInput | reportsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reportsScalarWhereInput | reportsScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserTrainingUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserTrainingCreateWithoutUsersInput, UserTrainingUncheckedCreateWithoutUsersInput> | UserTrainingCreateWithoutUsersInput[] | UserTrainingUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserTrainingCreateOrConnectWithoutUsersInput | UserTrainingCreateOrConnectWithoutUsersInput[]
    upsert?: UserTrainingUpsertWithWhereUniqueWithoutUsersInput | UserTrainingUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UserTrainingCreateManyUsersInputEnvelope
    set?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    disconnect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    delete?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    connect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    update?: UserTrainingUpdateWithWhereUniqueWithoutUsersInput | UserTrainingUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserTrainingUpdateManyWithWhereWithoutUsersInput | UserTrainingUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserTrainingScalarWhereInput | UserTrainingScalarWhereInput[]
  }

  export type TrainingUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<TrainingCreateWithoutInstructorInput, TrainingUncheckedCreateWithoutInstructorInput> | TrainingCreateWithoutInstructorInput[] | TrainingUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: TrainingCreateOrConnectWithoutInstructorInput | TrainingCreateOrConnectWithoutInstructorInput[]
    upsert?: TrainingUpsertWithWhereUniqueWithoutInstructorInput | TrainingUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: TrainingCreateManyInstructorInputEnvelope
    set?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    disconnect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    delete?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    connect?: TrainingWhereUniqueInput | TrainingWhereUniqueInput[]
    update?: TrainingUpdateWithWhereUniqueWithoutInstructorInput | TrainingUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: TrainingUpdateManyWithWhereWithoutInstructorInput | TrainingUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput> | GroupCreateWithoutUsersInput[] | GroupUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput | GroupCreateOrConnectWithoutUsersInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutUsersInput | GroupUpsertWithWhereUniqueWithoutUsersInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutUsersInput | GroupUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutUsersInput | GroupUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedManyWithoutPositionInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutPositionInput = {
    create?: XOR<AdmissionCreateWithoutPositionInput, AdmissionUncheckedCreateWithoutPositionInput> | AdmissionCreateWithoutPositionInput[] | AdmissionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPositionInput | AdmissionCreateOrConnectWithoutPositionInput[]
    createMany?: AdmissionCreateManyPositionInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<AdmissionCreateWithoutPositionInput, AdmissionUncheckedCreateWithoutPositionInput> | AdmissionCreateWithoutPositionInput[] | AdmissionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPositionInput | AdmissionCreateOrConnectWithoutPositionInput[]
    createMany?: AdmissionCreateManyPositionInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutPositionNestedInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPositionInput | UserUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPositionInput | UserUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPositionInput | UserUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutPositionNestedInput = {
    create?: XOR<AdmissionCreateWithoutPositionInput, AdmissionUncheckedCreateWithoutPositionInput> | AdmissionCreateWithoutPositionInput[] | AdmissionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPositionInput | AdmissionCreateOrConnectWithoutPositionInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPositionInput | AdmissionUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: AdmissionCreateManyPositionInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPositionInput | AdmissionUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPositionInput | AdmissionUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPositionInput | UserUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPositionInput | UserUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPositionInput | UserUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<AdmissionCreateWithoutPositionInput, AdmissionUncheckedCreateWithoutPositionInput> | AdmissionCreateWithoutPositionInput[] | AdmissionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPositionInput | AdmissionCreateOrConnectWithoutPositionInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPositionInput | AdmissionUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: AdmissionCreateManyPositionInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPositionInput | AdmissionUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPositionInput | AdmissionUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput> | AdmissionCreateWithoutDepartmentInput[] | AdmissionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutDepartmentInput | AdmissionCreateOrConnectWithoutDepartmentInput[]
    createMany?: AdmissionCreateManyDepartmentInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput> | AdmissionCreateWithoutDepartmentInput[] | AdmissionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutDepartmentInput | AdmissionCreateOrConnectWithoutDepartmentInput[]
    createMany?: AdmissionCreateManyDepartmentInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput> | AdmissionCreateWithoutDepartmentInput[] | AdmissionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutDepartmentInput | AdmissionCreateOrConnectWithoutDepartmentInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutDepartmentInput | AdmissionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AdmissionCreateManyDepartmentInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutDepartmentInput | AdmissionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutDepartmentInput | AdmissionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput> | AdmissionCreateWithoutDepartmentInput[] | AdmissionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutDepartmentInput | AdmissionCreateOrConnectWithoutDepartmentInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutDepartmentInput | AdmissionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AdmissionCreateManyDepartmentInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutDepartmentInput | AdmissionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutDepartmentInput | AdmissionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput = {
    create?: XOR<UserCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput, UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput = {
    create?: XOR<UserCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput, UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersNestedInput = {
    create?: XOR<UserCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput, UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput
    upsert?: UserUpsertWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput, UserUpdateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput>, UserUncheckedUpdateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput>
  }

  export type UserUpdateOneRequiredWithoutPerformance_evaluations_performance_evaluations_user_idTousersNestedInput = {
    create?: XOR<UserCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput, UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput
    upsert?: UserUpsertWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput, UserUpdateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput>, UserUncheckedUpdateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput>
  }

  export type UserCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<UserCreateWithoutAdmissionsInput, UserUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<PositionCreateWithoutAdmissionsInput, PositionUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: PositionCreateOrConnectWithoutAdmissionsInput
    connect?: PositionWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<DepartmentCreateWithoutAdmissionsInput, DepartmentUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAdmissionsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type AdmissionDocumentCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<AdmissionDocumentCreateWithoutAdmissionInput, AdmissionDocumentUncheckedCreateWithoutAdmissionInput> | AdmissionDocumentCreateWithoutAdmissionInput[] | AdmissionDocumentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: AdmissionDocumentCreateOrConnectWithoutAdmissionInput | AdmissionDocumentCreateOrConnectWithoutAdmissionInput[]
    createMany?: AdmissionDocumentCreateManyAdmissionInputEnvelope
    connect?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
  }

  export type AdmissionDocumentUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<AdmissionDocumentCreateWithoutAdmissionInput, AdmissionDocumentUncheckedCreateWithoutAdmissionInput> | AdmissionDocumentCreateWithoutAdmissionInput[] | AdmissionDocumentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: AdmissionDocumentCreateOrConnectWithoutAdmissionInput | AdmissionDocumentCreateOrConnectWithoutAdmissionInput[]
    createMany?: AdmissionDocumentCreateManyAdmissionInputEnvelope
    connect?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAdmissionsNestedInput = {
    create?: XOR<UserCreateWithoutAdmissionsInput, UserUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmissionsInput
    upsert?: UserUpsertWithoutAdmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdmissionsInput, UserUpdateWithoutAdmissionsInput>, UserUncheckedUpdateWithoutAdmissionsInput>
  }

  export type PositionUpdateOneWithoutAdmissionsNestedInput = {
    create?: XOR<PositionCreateWithoutAdmissionsInput, PositionUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: PositionCreateOrConnectWithoutAdmissionsInput
    upsert?: PositionUpsertWithoutAdmissionsInput
    disconnect?: PositionWhereInput | boolean
    delete?: PositionWhereInput | boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutAdmissionsInput, PositionUpdateWithoutAdmissionsInput>, PositionUncheckedUpdateWithoutAdmissionsInput>
  }

  export type DepartmentUpdateOneWithoutAdmissionsNestedInput = {
    create?: XOR<DepartmentCreateWithoutAdmissionsInput, DepartmentUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAdmissionsInput
    upsert?: DepartmentUpsertWithoutAdmissionsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutAdmissionsInput, DepartmentUpdateWithoutAdmissionsInput>, DepartmentUncheckedUpdateWithoutAdmissionsInput>
  }

  export type AdmissionDocumentUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<AdmissionDocumentCreateWithoutAdmissionInput, AdmissionDocumentUncheckedCreateWithoutAdmissionInput> | AdmissionDocumentCreateWithoutAdmissionInput[] | AdmissionDocumentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: AdmissionDocumentCreateOrConnectWithoutAdmissionInput | AdmissionDocumentCreateOrConnectWithoutAdmissionInput[]
    upsert?: AdmissionDocumentUpsertWithWhereUniqueWithoutAdmissionInput | AdmissionDocumentUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: AdmissionDocumentCreateManyAdmissionInputEnvelope
    set?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
    disconnect?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
    delete?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
    connect?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
    update?: AdmissionDocumentUpdateWithWhereUniqueWithoutAdmissionInput | AdmissionDocumentUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: AdmissionDocumentUpdateManyWithWhereWithoutAdmissionInput | AdmissionDocumentUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: AdmissionDocumentScalarWhereInput | AdmissionDocumentScalarWhereInput[]
  }

  export type AdmissionDocumentUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<AdmissionDocumentCreateWithoutAdmissionInput, AdmissionDocumentUncheckedCreateWithoutAdmissionInput> | AdmissionDocumentCreateWithoutAdmissionInput[] | AdmissionDocumentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: AdmissionDocumentCreateOrConnectWithoutAdmissionInput | AdmissionDocumentCreateOrConnectWithoutAdmissionInput[]
    upsert?: AdmissionDocumentUpsertWithWhereUniqueWithoutAdmissionInput | AdmissionDocumentUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: AdmissionDocumentCreateManyAdmissionInputEnvelope
    set?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
    disconnect?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
    delete?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
    connect?: AdmissionDocumentWhereUniqueInput | AdmissionDocumentWhereUniqueInput[]
    update?: AdmissionDocumentUpdateWithWhereUniqueWithoutAdmissionInput | AdmissionDocumentUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: AdmissionDocumentUpdateManyWithWhereWithoutAdmissionInput | AdmissionDocumentUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: AdmissionDocumentScalarWhereInput | AdmissionDocumentScalarWhereInput[]
  }

  export type AdmissionCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AdmissionCreateWithoutDocumentsInput, AdmissionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutDocumentsInput
    connect?: AdmissionWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdmissionUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<AdmissionCreateWithoutDocumentsInput, AdmissionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutDocumentsInput
    upsert?: AdmissionUpsertWithoutDocumentsInput
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutDocumentsInput, AdmissionUpdateWithoutDocumentsInput>, AdmissionUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutTasksInput = {
    create?: XOR<GroupCreateWithoutTasksInput, GroupUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GroupCreateOrConnectWithoutTasksInput
    connect?: GroupWhereUniqueInput
  }

  export type TrainingCreateNestedOneWithoutTasksInput = {
    create?: XOR<TrainingCreateWithoutTasksInput, TrainingUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutTasksInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserUpdateOneWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type GroupUpdateOneWithoutTasksNestedInput = {
    create?: XOR<GroupCreateWithoutTasksInput, GroupUncheckedCreateWithoutTasksInput>
    connectOrCreate?: GroupCreateOrConnectWithoutTasksInput
    upsert?: GroupUpsertWithoutTasksInput
    disconnect?: GroupWhereInput | boolean
    delete?: GroupWhereInput | boolean
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutTasksInput, GroupUpdateWithoutTasksInput>, GroupUncheckedUpdateWithoutTasksInput>
  }

  export type TrainingUpdateOneWithoutTasksNestedInput = {
    create?: XOR<TrainingCreateWithoutTasksInput, TrainingUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutTasksInput
    upsert?: TrainingUpsertWithoutTasksInput
    disconnect?: TrainingWhereInput | boolean
    delete?: TrainingWhereInput | boolean
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutTasksInput, TrainingUpdateWithoutTasksInput>, TrainingUncheckedUpdateWithoutTasksInput>
  }

  export type TaskCreateNestedManyWithoutGroupInput = {
    create?: XOR<TaskCreateWithoutGroupInput, TaskUncheckedCreateWithoutGroupInput> | TaskCreateWithoutGroupInput[] | TaskUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGroupInput | TaskCreateOrConnectWithoutGroupInput[]
    createMany?: TaskCreateManyGroupInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<TaskCreateWithoutGroupInput, TaskUncheckedCreateWithoutGroupInput> | TaskCreateWithoutGroupInput[] | TaskUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGroupInput | TaskCreateOrConnectWithoutGroupInput[]
    createMany?: TaskCreateManyGroupInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutGroupNestedInput = {
    create?: XOR<TaskCreateWithoutGroupInput, TaskUncheckedCreateWithoutGroupInput> | TaskCreateWithoutGroupInput[] | TaskUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGroupInput | TaskCreateOrConnectWithoutGroupInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGroupInput | TaskUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: TaskCreateManyGroupInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGroupInput | TaskUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGroupInput | TaskUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<TaskCreateWithoutGroupInput, TaskUncheckedCreateWithoutGroupInput> | TaskCreateWithoutGroupInput[] | TaskUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutGroupInput | TaskCreateOrConnectWithoutGroupInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutGroupInput | TaskUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: TaskCreateManyGroupInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutGroupInput | TaskUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutGroupInput | TaskUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type reportsCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<reportsCreateWithoutDocumentsInput, reportsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: reportsCreateOrConnectWithoutDocumentsInput
    connect?: reportsWhereUniqueInput
  }

  export type reportsUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<reportsCreateWithoutDocumentsInput, reportsUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: reportsCreateOrConnectWithoutDocumentsInput
    upsert?: reportsUpsertWithoutDocumentsInput
    connect?: reportsWhereUniqueInput
    update?: XOR<XOR<reportsUpdateToOneWithWhereWithoutDocumentsInput, reportsUpdateWithoutDocumentsInput>, reportsUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserCreateNestedOneWithoutTrainingsInput = {
    create?: XOR<UserCreateWithoutTrainingsInput, UserUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserTrainingCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<UserTrainingCreateWithoutTrainingsInput, UserTrainingUncheckedCreateWithoutTrainingsInput> | UserTrainingCreateWithoutTrainingsInput[] | UserTrainingUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: UserTrainingCreateOrConnectWithoutTrainingsInput | UserTrainingCreateOrConnectWithoutTrainingsInput[]
    createMany?: UserTrainingCreateManyTrainingsInputEnvelope
    connect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TaskCreateWithoutTrainingInput, TaskUncheckedCreateWithoutTrainingInput> | TaskCreateWithoutTrainingInput[] | TaskUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTrainingInput | TaskCreateOrConnectWithoutTrainingInput[]
    createMany?: TaskCreateManyTrainingInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type UserTrainingUncheckedCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<UserTrainingCreateWithoutTrainingsInput, UserTrainingUncheckedCreateWithoutTrainingsInput> | UserTrainingCreateWithoutTrainingsInput[] | UserTrainingUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: UserTrainingCreateOrConnectWithoutTrainingsInput | UserTrainingCreateOrConnectWithoutTrainingsInput[]
    createMany?: UserTrainingCreateManyTrainingsInputEnvelope
    connect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutTrainingInput = {
    create?: XOR<TaskCreateWithoutTrainingInput, TaskUncheckedCreateWithoutTrainingInput> | TaskCreateWithoutTrainingInput[] | TaskUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTrainingInput | TaskCreateOrConnectWithoutTrainingInput[]
    createMany?: TaskCreateManyTrainingInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutTrainingsNestedInput = {
    create?: XOR<UserCreateWithoutTrainingsInput, UserUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrainingsInput
    upsert?: UserUpsertWithoutTrainingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrainingsInput, UserUpdateWithoutTrainingsInput>, UserUncheckedUpdateWithoutTrainingsInput>
  }

  export type UserTrainingUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<UserTrainingCreateWithoutTrainingsInput, UserTrainingUncheckedCreateWithoutTrainingsInput> | UserTrainingCreateWithoutTrainingsInput[] | UserTrainingUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: UserTrainingCreateOrConnectWithoutTrainingsInput | UserTrainingCreateOrConnectWithoutTrainingsInput[]
    upsert?: UserTrainingUpsertWithWhereUniqueWithoutTrainingsInput | UserTrainingUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: UserTrainingCreateManyTrainingsInputEnvelope
    set?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    disconnect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    delete?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    connect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    update?: UserTrainingUpdateWithWhereUniqueWithoutTrainingsInput | UserTrainingUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: UserTrainingUpdateManyWithWhereWithoutTrainingsInput | UserTrainingUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: UserTrainingScalarWhereInput | UserTrainingScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TaskCreateWithoutTrainingInput, TaskUncheckedCreateWithoutTrainingInput> | TaskCreateWithoutTrainingInput[] | TaskUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTrainingInput | TaskCreateOrConnectWithoutTrainingInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTrainingInput | TaskUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TaskCreateManyTrainingInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTrainingInput | TaskUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTrainingInput | TaskUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UserTrainingUncheckedUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<UserTrainingCreateWithoutTrainingsInput, UserTrainingUncheckedCreateWithoutTrainingsInput> | UserTrainingCreateWithoutTrainingsInput[] | UserTrainingUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: UserTrainingCreateOrConnectWithoutTrainingsInput | UserTrainingCreateOrConnectWithoutTrainingsInput[]
    upsert?: UserTrainingUpsertWithWhereUniqueWithoutTrainingsInput | UserTrainingUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: UserTrainingCreateManyTrainingsInputEnvelope
    set?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    disconnect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    delete?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    connect?: UserTrainingWhereUniqueInput | UserTrainingWhereUniqueInput[]
    update?: UserTrainingUpdateWithWhereUniqueWithoutTrainingsInput | UserTrainingUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: UserTrainingUpdateManyWithWhereWithoutTrainingsInput | UserTrainingUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: UserTrainingScalarWhereInput | UserTrainingScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutTrainingNestedInput = {
    create?: XOR<TaskCreateWithoutTrainingInput, TaskUncheckedCreateWithoutTrainingInput> | TaskCreateWithoutTrainingInput[] | TaskUncheckedCreateWithoutTrainingInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTrainingInput | TaskCreateOrConnectWithoutTrainingInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTrainingInput | TaskUpsertWithWhereUniqueWithoutTrainingInput[]
    createMany?: TaskCreateManyTrainingInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTrainingInput | TaskUpdateWithWhereUniqueWithoutTrainingInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTrainingInput | TaskUpdateManyWithWhereWithoutTrainingInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TrainingCreateNestedOneWithoutTraining_participationsInput = {
    create?: XOR<TrainingCreateWithoutTraining_participationsInput, TrainingUncheckedCreateWithoutTraining_participationsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutTraining_participationsInput
    connect?: TrainingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTraining_participationsInput = {
    create?: XOR<UserCreateWithoutTraining_participationsInput, UserUncheckedCreateWithoutTraining_participationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTraining_participationsInput
    connect?: UserWhereUniqueInput
  }

  export type TrainingDocumentCreateNestedManyWithoutUserTrainingInput = {
    create?: XOR<TrainingDocumentCreateWithoutUserTrainingInput, TrainingDocumentUncheckedCreateWithoutUserTrainingInput> | TrainingDocumentCreateWithoutUserTrainingInput[] | TrainingDocumentUncheckedCreateWithoutUserTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUserTrainingInput | TrainingDocumentCreateOrConnectWithoutUserTrainingInput[]
    createMany?: TrainingDocumentCreateManyUserTrainingInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type TrainingDocumentUncheckedCreateNestedManyWithoutUserTrainingInput = {
    create?: XOR<TrainingDocumentCreateWithoutUserTrainingInput, TrainingDocumentUncheckedCreateWithoutUserTrainingInput> | TrainingDocumentCreateWithoutUserTrainingInput[] | TrainingDocumentUncheckedCreateWithoutUserTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUserTrainingInput | TrainingDocumentCreateOrConnectWithoutUserTrainingInput[]
    createMany?: TrainingDocumentCreateManyUserTrainingInputEnvelope
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
  }

  export type TrainingUpdateOneRequiredWithoutTraining_participationsNestedInput = {
    create?: XOR<TrainingCreateWithoutTraining_participationsInput, TrainingUncheckedCreateWithoutTraining_participationsInput>
    connectOrCreate?: TrainingCreateOrConnectWithoutTraining_participationsInput
    upsert?: TrainingUpsertWithoutTraining_participationsInput
    connect?: TrainingWhereUniqueInput
    update?: XOR<XOR<TrainingUpdateToOneWithWhereWithoutTraining_participationsInput, TrainingUpdateWithoutTraining_participationsInput>, TrainingUncheckedUpdateWithoutTraining_participationsInput>
  }

  export type UserUpdateOneRequiredWithoutTraining_participationsNestedInput = {
    create?: XOR<UserCreateWithoutTraining_participationsInput, UserUncheckedCreateWithoutTraining_participationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTraining_participationsInput
    upsert?: UserUpsertWithoutTraining_participationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTraining_participationsInput, UserUpdateWithoutTraining_participationsInput>, UserUncheckedUpdateWithoutTraining_participationsInput>
  }

  export type TrainingDocumentUpdateManyWithoutUserTrainingNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutUserTrainingInput, TrainingDocumentUncheckedCreateWithoutUserTrainingInput> | TrainingDocumentCreateWithoutUserTrainingInput[] | TrainingDocumentUncheckedCreateWithoutUserTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUserTrainingInput | TrainingDocumentCreateOrConnectWithoutUserTrainingInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutUserTrainingInput | TrainingDocumentUpsertWithWhereUniqueWithoutUserTrainingInput[]
    createMany?: TrainingDocumentCreateManyUserTrainingInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutUserTrainingInput | TrainingDocumentUpdateWithWhereUniqueWithoutUserTrainingInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutUserTrainingInput | TrainingDocumentUpdateManyWithWhereWithoutUserTrainingInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutUserTrainingNestedInput = {
    create?: XOR<TrainingDocumentCreateWithoutUserTrainingInput, TrainingDocumentUncheckedCreateWithoutUserTrainingInput> | TrainingDocumentCreateWithoutUserTrainingInput[] | TrainingDocumentUncheckedCreateWithoutUserTrainingInput[]
    connectOrCreate?: TrainingDocumentCreateOrConnectWithoutUserTrainingInput | TrainingDocumentCreateOrConnectWithoutUserTrainingInput[]
    upsert?: TrainingDocumentUpsertWithWhereUniqueWithoutUserTrainingInput | TrainingDocumentUpsertWithWhereUniqueWithoutUserTrainingInput[]
    createMany?: TrainingDocumentCreateManyUserTrainingInputEnvelope
    set?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    disconnect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    delete?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    connect?: TrainingDocumentWhereUniqueInput | TrainingDocumentWhereUniqueInput[]
    update?: TrainingDocumentUpdateWithWhereUniqueWithoutUserTrainingInput | TrainingDocumentUpdateWithWhereUniqueWithoutUserTrainingInput[]
    updateMany?: TrainingDocumentUpdateManyWithWhereWithoutUserTrainingInput | TrainingDocumentUpdateManyWithWhereWithoutUserTrainingInput[]
    deleteMany?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
  }

  export type UserTrainingCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserTrainingCreateWithoutDocumentsInput, UserTrainingUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserTrainingCreateOrConnectWithoutDocumentsInput
    connect?: UserTrainingWhereUniqueInput
  }

  export type UserTrainingUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserTrainingCreateWithoutDocumentsInput, UserTrainingUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserTrainingCreateOrConnectWithoutDocumentsInput
    upsert?: UserTrainingUpsertWithoutDocumentsInput
    connect?: UserTrainingWhereUniqueInput
    update?: XOR<XOR<UserTrainingUpdateToOneWithWhereWithoutDocumentsInput, UserTrainingUpdateWithoutDocumentsInput>, UserTrainingUncheckedUpdateWithoutDocumentsInput>
  }

  export type ReportDocumentCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportDocumentCreateWithoutReportInput, ReportDocumentUncheckedCreateWithoutReportInput> | ReportDocumentCreateWithoutReportInput[] | ReportDocumentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportDocumentCreateOrConnectWithoutReportInput | ReportDocumentCreateOrConnectWithoutReportInput[]
    createMany?: ReportDocumentCreateManyReportInputEnvelope
    connect?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type ReportDocumentUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportDocumentCreateWithoutReportInput, ReportDocumentUncheckedCreateWithoutReportInput> | ReportDocumentCreateWithoutReportInput[] | ReportDocumentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportDocumentCreateOrConnectWithoutReportInput | ReportDocumentCreateOrConnectWithoutReportInput[]
    createMany?: ReportDocumentCreateManyReportInputEnvelope
    connect?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
  }

  export type ReportDocumentUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportDocumentCreateWithoutReportInput, ReportDocumentUncheckedCreateWithoutReportInput> | ReportDocumentCreateWithoutReportInput[] | ReportDocumentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportDocumentCreateOrConnectWithoutReportInput | ReportDocumentCreateOrConnectWithoutReportInput[]
    upsert?: ReportDocumentUpsertWithWhereUniqueWithoutReportInput | ReportDocumentUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportDocumentCreateManyReportInputEnvelope
    set?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
    disconnect?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
    delete?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
    connect?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
    update?: ReportDocumentUpdateWithWhereUniqueWithoutReportInput | ReportDocumentUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportDocumentUpdateManyWithWhereWithoutReportInput | ReportDocumentUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportDocumentScalarWhereInput | ReportDocumentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type ReportDocumentUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportDocumentCreateWithoutReportInput, ReportDocumentUncheckedCreateWithoutReportInput> | ReportDocumentCreateWithoutReportInput[] | ReportDocumentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportDocumentCreateOrConnectWithoutReportInput | ReportDocumentCreateOrConnectWithoutReportInput[]
    upsert?: ReportDocumentUpsertWithWhereUniqueWithoutReportInput | ReportDocumentUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportDocumentCreateManyReportInputEnvelope
    set?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
    disconnect?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
    delete?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
    connect?: ReportDocumentWhereUniqueInput | ReportDocumentWhereUniqueInput[]
    update?: ReportDocumentUpdateWithWhereUniqueWithoutReportInput | ReportDocumentUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportDocumentUpdateManyWithWhereWithoutReportInput | ReportDocumentUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportDocumentScalarWhereInput | ReportDocumentScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AdmissionCreateWithoutUserInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    position?: PositionCreateNestedOneWithoutAdmissionsInput
    department?: DepartmentCreateNestedOneWithoutAdmissionsInput
    documents?: AdmissionDocumentCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutUserInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    position_id?: string | null
    department_id?: string | null
    documents?: AdmissionDocumentUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutUserInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutUserInput, AdmissionUncheckedCreateWithoutUserInput>
  }

  export type ChatMessageCreateWithoutReceiverInput = {
    id?: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
    sender_id: string
  }

  export type ChatMessageCreateOrConnectWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageCreateManyReceiverInputEnvelope = {
    data: ChatMessageCreateManyReceiverInput | ChatMessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutSenderInput = {
    id?: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    receiverId: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
  }

  export type ChatMessageCreateOrConnectWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageCreateManySenderInputEnvelope = {
    data: ChatMessageCreateManySenderInput | ChatMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users_performance_evaluations_user_idTousers: UserCreateNestedOneWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput
  }

  export type PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
  }

  export type PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    where: PerformanceEvaluationWhereUniqueInput
    create: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput>
  }

  export type PerformanceEvaluationCreateManyUsers_performance_evaluations_evaluator_idTousersInputEnvelope = {
    data: PerformanceEvaluationCreateManyUsers_performance_evaluations_evaluator_idTousersInput | PerformanceEvaluationCreateManyUsers_performance_evaluations_evaluator_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users_performance_evaluations_evaluator_idTousers: UserCreateNestedOneWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput
  }

  export type PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluator_id: string
  }

  export type PerformanceEvaluationCreateOrConnectWithoutUsers_performance_evaluations_user_idTousersInput = {
    where: PerformanceEvaluationWhereUniqueInput
    create: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput>
  }

  export type PerformanceEvaluationCreateManyUsers_performance_evaluations_user_idTousersInputEnvelope = {
    data: PerformanceEvaluationCreateManyUsers_performance_evaluations_user_idTousersInput | PerformanceEvaluationCreateManyUsers_performance_evaluations_user_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    address?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    document?: string | null
    emergencyContact?: string | null
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    address?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    document?: string | null
    emergencyContact?: string | null
    avatar?: string | null
    bio?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type reportsCreateWithoutUsersInput = {
    id: string
    name: string
    type: string
    frequency?: string | null
    scheduledDate?: Date | string | null
    created_at?: Date | string
    documents?: ReportDocumentCreateNestedManyWithoutReportInput
  }

  export type reportsUncheckedCreateWithoutUsersInput = {
    id: string
    name: string
    type: string
    frequency?: string | null
    scheduledDate?: Date | string | null
    created_at?: Date | string
    documents?: ReportDocumentUncheckedCreateNestedManyWithoutReportInput
  }

  export type reportsCreateOrConnectWithoutUsersInput = {
    where: reportsWhereUniqueInput
    create: XOR<reportsCreateWithoutUsersInput, reportsUncheckedCreateWithoutUsersInput>
  }

  export type reportsCreateManyUsersInputEnvelope = {
    data: reportsCreateManyUsersInput | reportsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: GroupCreateNestedOneWithoutTasksInput
    training?: TrainingCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    groupId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId?: string | null
  }

  export type TaskCreateOrConnectWithoutUserInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskCreateManyUserInputEnvelope = {
    data: TaskCreateManyUserInput | TaskCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTrainingCreateWithoutUsersInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    progress?: number | null
    trainings: TrainingCreateNestedOneWithoutTraining_participationsInput
    documents?: TrainingDocumentCreateNestedManyWithoutUserTrainingInput
  }

  export type UserTrainingUncheckedCreateWithoutUsersInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    training_id: string
    progress?: number | null
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutUserTrainingInput
  }

  export type UserTrainingCreateOrConnectWithoutUsersInput = {
    where: UserTrainingWhereUniqueInput
    create: XOR<UserTrainingCreateWithoutUsersInput, UserTrainingUncheckedCreateWithoutUsersInput>
  }

  export type UserTrainingCreateManyUsersInputEnvelope = {
    data: UserTrainingCreateManyUsersInput | UserTrainingCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type TrainingCreateWithoutInstructorInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    training_participations?: UserTrainingCreateNestedManyWithoutTrainingsInput
    tasks?: TaskCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutInstructorInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutTrainingsInput
    tasks?: TaskUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutInstructorInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutInstructorInput, TrainingUncheckedCreateWithoutInstructorInput>
  }

  export type TrainingCreateManyInstructorInputEnvelope = {
    data: TrainingCreateManyInstructorInput | TrainingCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutUsersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
  }

  export type PositionCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    salary?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    salary?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutUsersInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
  }

  export type GroupCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutUsersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
  }

  export type AdmissionUpsertWithoutUserInput = {
    update: XOR<AdmissionUpdateWithoutUserInput, AdmissionUncheckedUpdateWithoutUserInput>
    create: XOR<AdmissionCreateWithoutUserInput, AdmissionUncheckedCreateWithoutUserInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutUserInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutUserInput, AdmissionUncheckedUpdateWithoutUserInput>
  }

  export type AdmissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneWithoutAdmissionsNestedInput
    documents?: AdmissionDocumentUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: AdmissionDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<ChatMessageCreateWithoutReceiverInput, ChatMessageUncheckedCreateWithoutReceiverInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutReceiverInput, ChatMessageUncheckedUpdateWithoutReceiverInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutReceiverInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    receiverId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    timestamp?: DateTimeFilter<"ChatMessage"> | Date | string
    isBot?: BoolFilter<"ChatMessage"> | boolean
    isRead?: BoolFilter<"ChatMessage"> | boolean
    messageType?: StringFilter<"ChatMessage"> | string
    sender_id?: StringFilter<"ChatMessage"> | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<ChatMessageCreateWithoutSenderInput, ChatMessageUncheckedCreateWithoutSenderInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSenderInput, ChatMessageUncheckedUpdateWithoutSenderInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSenderInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    where: PerformanceEvaluationWhereUniqueInput
    update: XOR<PerformanceEvaluationUpdateWithoutUsers_performance_evaluations_evaluator_idTousersInput, PerformanceEvaluationUncheckedUpdateWithoutUsers_performance_evaluations_evaluator_idTousersInput>
    create: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_evaluator_idTousersInput>
  }

  export type PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    where: PerformanceEvaluationWhereUniqueInput
    data: XOR<PerformanceEvaluationUpdateWithoutUsers_performance_evaluations_evaluator_idTousersInput, PerformanceEvaluationUncheckedUpdateWithoutUsers_performance_evaluations_evaluator_idTousersInput>
  }

  export type PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    where: PerformanceEvaluationScalarWhereInput
    data: XOR<PerformanceEvaluationUpdateManyMutationInput, PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersInput>
  }

  export type PerformanceEvaluationScalarWhereInput = {
    AND?: PerformanceEvaluationScalarWhereInput | PerformanceEvaluationScalarWhereInput[]
    OR?: PerformanceEvaluationScalarWhereInput[]
    NOT?: PerformanceEvaluationScalarWhereInput | PerformanceEvaluationScalarWhereInput[]
    id?: StringFilter<"PerformanceEvaluation"> | string
    period?: StringFilter<"PerformanceEvaluation"> | string
    score?: FloatFilter<"PerformanceEvaluation"> | number
    goals?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    achievements?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    feedback?: StringNullableFilter<"PerformanceEvaluation"> | string | null
    status?: StringFilter<"PerformanceEvaluation"> | string
    createdAt?: DateTimeFilter<"PerformanceEvaluation"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceEvaluation"> | Date | string
    evaluator_id?: StringFilter<"PerformanceEvaluation"> | string
    user_id?: StringFilter<"PerformanceEvaluation"> | string
  }

  export type PerformanceEvaluationUpsertWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput = {
    where: PerformanceEvaluationWhereUniqueInput
    update: XOR<PerformanceEvaluationUpdateWithoutUsers_performance_evaluations_user_idTousersInput, PerformanceEvaluationUncheckedUpdateWithoutUsers_performance_evaluations_user_idTousersInput>
    create: XOR<PerformanceEvaluationCreateWithoutUsers_performance_evaluations_user_idTousersInput, PerformanceEvaluationUncheckedCreateWithoutUsers_performance_evaluations_user_idTousersInput>
  }

  export type PerformanceEvaluationUpdateWithWhereUniqueWithoutUsers_performance_evaluations_user_idTousersInput = {
    where: PerformanceEvaluationWhereUniqueInput
    data: XOR<PerformanceEvaluationUpdateWithoutUsers_performance_evaluations_user_idTousersInput, PerformanceEvaluationUncheckedUpdateWithoutUsers_performance_evaluations_user_idTousersInput>
  }

  export type PerformanceEvaluationUpdateManyWithWhereWithoutUsers_performance_evaluations_user_idTousersInput = {
    where: PerformanceEvaluationScalarWhereInput
    data: XOR<PerformanceEvaluationUpdateManyMutationInput, PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersInput>
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportsUpsertWithWhereUniqueWithoutUsersInput = {
    where: reportsWhereUniqueInput
    update: XOR<reportsUpdateWithoutUsersInput, reportsUncheckedUpdateWithoutUsersInput>
    create: XOR<reportsCreateWithoutUsersInput, reportsUncheckedCreateWithoutUsersInput>
  }

  export type reportsUpdateWithWhereUniqueWithoutUsersInput = {
    where: reportsWhereUniqueInput
    data: XOR<reportsUpdateWithoutUsersInput, reportsUncheckedUpdateWithoutUsersInput>
  }

  export type reportsUpdateManyWithWhereWithoutUsersInput = {
    where: reportsScalarWhereInput
    data: XOR<reportsUpdateManyMutationInput, reportsUncheckedUpdateManyWithoutUsersInput>
  }

  export type reportsScalarWhereInput = {
    AND?: reportsScalarWhereInput | reportsScalarWhereInput[]
    OR?: reportsScalarWhereInput[]
    NOT?: reportsScalarWhereInput | reportsScalarWhereInput[]
    id?: StringFilter<"reports"> | string
    name?: StringFilter<"reports"> | string
    type?: StringFilter<"reports"> | string
    generated_by?: StringFilter<"reports"> | string
    frequency?: StringNullableFilter<"reports"> | string | null
    scheduledDate?: DateTimeNullableFilter<"reports"> | Date | string | null
    created_at?: DateTimeFilter<"reports"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
  }

  export type TaskUpdateManyWithWhereWithoutUserInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    startDate?: DateTimeFilter<"Task"> | Date | string
    endDate?: DateTimeFilter<"Task"> | Date | string
    userId?: StringNullableFilter<"Task"> | string | null
    groupId?: StringNullableFilter<"Task"> | string | null
    isActive?: BoolFilter<"Task"> | boolean
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    trainingId?: StringNullableFilter<"Task"> | string | null
  }

  export type UserTrainingUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserTrainingWhereUniqueInput
    update: XOR<UserTrainingUpdateWithoutUsersInput, UserTrainingUncheckedUpdateWithoutUsersInput>
    create: XOR<UserTrainingCreateWithoutUsersInput, UserTrainingUncheckedCreateWithoutUsersInput>
  }

  export type UserTrainingUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserTrainingWhereUniqueInput
    data: XOR<UserTrainingUpdateWithoutUsersInput, UserTrainingUncheckedUpdateWithoutUsersInput>
  }

  export type UserTrainingUpdateManyWithWhereWithoutUsersInput = {
    where: UserTrainingScalarWhereInput
    data: XOR<UserTrainingUpdateManyMutationInput, UserTrainingUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserTrainingScalarWhereInput = {
    AND?: UserTrainingScalarWhereInput | UserTrainingScalarWhereInput[]
    OR?: UserTrainingScalarWhereInput[]
    NOT?: UserTrainingScalarWhereInput | UserTrainingScalarWhereInput[]
    id?: StringFilter<"UserTraining"> | string
    enrolledAt?: DateTimeFilter<"UserTraining"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserTraining"> | Date | string | null
    status?: StringFilter<"UserTraining"> | string
    score?: FloatNullableFilter<"UserTraining"> | number | null
    certificate?: StringNullableFilter<"UserTraining"> | string | null
    training_id?: StringFilter<"UserTraining"> | string
    user_id?: StringFilter<"UserTraining"> | string
    progress?: FloatNullableFilter<"UserTraining"> | number | null
  }

  export type TrainingUpsertWithWhereUniqueWithoutInstructorInput = {
    where: TrainingWhereUniqueInput
    update: XOR<TrainingUpdateWithoutInstructorInput, TrainingUncheckedUpdateWithoutInstructorInput>
    create: XOR<TrainingCreateWithoutInstructorInput, TrainingUncheckedCreateWithoutInstructorInput>
  }

  export type TrainingUpdateWithWhereUniqueWithoutInstructorInput = {
    where: TrainingWhereUniqueInput
    data: XOR<TrainingUpdateWithoutInstructorInput, TrainingUncheckedUpdateWithoutInstructorInput>
  }

  export type TrainingUpdateManyWithWhereWithoutInstructorInput = {
    where: TrainingScalarWhereInput
    data: XOR<TrainingUpdateManyMutationInput, TrainingUncheckedUpdateManyWithoutInstructorInput>
  }

  export type TrainingScalarWhereInput = {
    AND?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
    OR?: TrainingScalarWhereInput[]
    NOT?: TrainingScalarWhereInput | TrainingScalarWhereInput[]
    id?: StringFilter<"Training"> | string
    name?: StringFilter<"Training"> | string
    description?: StringNullableFilter<"Training"> | string | null
    startDate?: DateTimeFilter<"Training"> | Date | string
    endDate?: DateTimeFilter<"Training"> | Date | string
    maxParticipants?: IntNullableFilter<"Training"> | number | null
    status?: StringFilter<"Training"> | string
    createdAt?: DateTimeFilter<"Training"> | Date | string
    updatedAt?: DateTimeFilter<"Training"> | Date | string
    progress?: FloatNullableFilter<"Training"> | number | null
    instructorId?: StringNullableFilter<"Training"> | string | null
  }

  export type DepartmentUpsertWithoutUsersInput = {
    update: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUsersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type PositionUpsertWithoutUsersInput = {
    update: XOR<PositionUpdateWithoutUsersInput, PositionUncheckedUpdateWithoutUsersInput>
    create: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutUsersInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutUsersInput, PositionUncheckedUpdateWithoutUsersInput>
  }

  export type PositionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissions?: AdmissionUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type GroupUpsertWithWhereUniqueWithoutUsersInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutUsersInput, GroupUncheckedUpdateWithoutUsersInput>
    create: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutUsersInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutUsersInput, GroupUncheckedUpdateWithoutUsersInput>
  }

  export type GroupUpdateManyWithWhereWithoutUsersInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutUsersInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    createdAt?: DateTimeFilter<"Group"> | Date | string
    updatedAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutPositionInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPositionInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutPositionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput>
  }

  export type UserCreateManyPositionInputEnvelope = {
    data: UserCreateManyPositionInput | UserCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutPositionInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdmissionsInput
    department?: DepartmentCreateNestedOneWithoutAdmissionsInput
    documents?: AdmissionDocumentCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutPositionInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
    department_id?: string | null
    documents?: AdmissionDocumentUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutPositionInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutPositionInput, AdmissionUncheckedCreateWithoutPositionInput>
  }

  export type AdmissionCreateManyPositionInputEnvelope = {
    data: AdmissionCreateManyPositionInput | AdmissionCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutPositionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPositionInput, UserUncheckedUpdateWithoutPositionInput>
    create: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPositionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPositionInput, UserUncheckedUpdateWithoutPositionInput>
  }

  export type UserUpdateManyWithWhereWithoutPositionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutPositionInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password_hash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    last_login?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    departmentId?: StringNullableFilter<"User"> | string | null
    positionId?: StringNullableFilter<"User"> | string | null
    surname?: StringNullableFilter<"User"> | string | null
  }

  export type AdmissionUpsertWithWhereUniqueWithoutPositionInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutPositionInput, AdmissionUncheckedUpdateWithoutPositionInput>
    create: XOR<AdmissionCreateWithoutPositionInput, AdmissionUncheckedCreateWithoutPositionInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutPositionInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutPositionInput, AdmissionUncheckedUpdateWithoutPositionInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutPositionInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutPositionInput>
  }

  export type AdmissionScalarWhereInput = {
    AND?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    OR?: AdmissionScalarWhereInput[]
    NOT?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    id?: StringFilter<"Admission"> | string
    hireDate?: DateTimeFilter<"Admission"> | Date | string
    contractType?: StringFilter<"Admission"> | string
    salary?: FloatNullableFilter<"Admission"> | number | null
    benefits?: StringNullableFilter<"Admission"> | string | null
    terminationDate?: DateTimeNullableFilter<"Admission"> | Date | string | null
    terminationReason?: StringNullableFilter<"Admission"> | string | null
    status?: StringFilter<"Admission"> | string
    createdAt?: DateTimeFilter<"Admission"> | Date | string
    updatedAt?: DateTimeFilter<"Admission"> | Date | string
    user_id?: StringFilter<"Admission"> | string
    position_id?: StringNullableFilter<"Admission"> | string | null
    department_id?: StringNullableFilter<"Admission"> | string | null
  }

  export type UserCreateWithoutDepartmentInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDepartmentInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserCreateManyDepartmentInputEnvelope = {
    data: UserCreateManyDepartmentInput | UserCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutDepartmentInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdmissionsInput
    position?: PositionCreateNestedOneWithoutAdmissionsInput
    documents?: AdmissionDocumentCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutDepartmentInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
    position_id?: string | null
    documents?: AdmissionDocumentUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutDepartmentInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput>
  }

  export type AdmissionCreateManyDepartmentInputEnvelope = {
    data: AdmissionCreateManyDepartmentInput | AdmissionCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AdmissionUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutDepartmentInput, AdmissionUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutDepartmentInput, AdmissionUncheckedUpdateWithoutDepartmentInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutDepartmentInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type UserCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput, UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput>
  }

  export type UserCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput, UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput>
  }

  export type UserUpsertWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput = {
    update: XOR<UserUpdateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput, UserUncheckedUpdateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput>
    create: XOR<UserCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput, UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput, UserUncheckedUpdateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput>
  }

  export type UserUpdateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUpsertWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput = {
    update: XOR<UserUpdateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput, UserUncheckedUpdateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput>
    create: XOR<UserCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput, UserUncheckedCreateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput, UserUncheckedUpdateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput>
  }

  export type UserUpdateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPerformance_evaluations_performance_evaluations_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutAdmissionsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutAdmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdmissionsInput, UserUncheckedCreateWithoutAdmissionsInput>
  }

  export type PositionCreateWithoutAdmissionsInput = {
    id?: string
    name: string
    description?: string | null
    salary?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    name: string
    description?: string | null
    salary?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutAdmissionsInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutAdmissionsInput, PositionUncheckedCreateWithoutAdmissionsInput>
  }

  export type DepartmentCreateWithoutAdmissionsInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutAdmissionsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutAdmissionsInput, DepartmentUncheckedCreateWithoutAdmissionsInput>
  }

  export type AdmissionDocumentCreateWithoutAdmissionInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type AdmissionDocumentUncheckedCreateWithoutAdmissionInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type AdmissionDocumentCreateOrConnectWithoutAdmissionInput = {
    where: AdmissionDocumentWhereUniqueInput
    create: XOR<AdmissionDocumentCreateWithoutAdmissionInput, AdmissionDocumentUncheckedCreateWithoutAdmissionInput>
  }

  export type AdmissionDocumentCreateManyAdmissionInputEnvelope = {
    data: AdmissionDocumentCreateManyAdmissionInput | AdmissionDocumentCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdmissionsInput = {
    update: XOR<UserUpdateWithoutAdmissionsInput, UserUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<UserCreateWithoutAdmissionsInput, UserUncheckedCreateWithoutAdmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdmissionsInput, UserUncheckedUpdateWithoutAdmissionsInput>
  }

  export type UserUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type PositionUpsertWithoutAdmissionsInput = {
    update: XOR<PositionUpdateWithoutAdmissionsInput, PositionUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<PositionCreateWithoutAdmissionsInput, PositionUncheckedCreateWithoutAdmissionsInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutAdmissionsInput, PositionUncheckedUpdateWithoutAdmissionsInput>
  }

  export type PositionUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type DepartmentUpsertWithoutAdmissionsInput = {
    update: XOR<DepartmentUpdateWithoutAdmissionsInput, DepartmentUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<DepartmentCreateWithoutAdmissionsInput, DepartmentUncheckedCreateWithoutAdmissionsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutAdmissionsInput, DepartmentUncheckedUpdateWithoutAdmissionsInput>
  }

  export type DepartmentUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type AdmissionDocumentUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: AdmissionDocumentWhereUniqueInput
    update: XOR<AdmissionDocumentUpdateWithoutAdmissionInput, AdmissionDocumentUncheckedUpdateWithoutAdmissionInput>
    create: XOR<AdmissionDocumentCreateWithoutAdmissionInput, AdmissionDocumentUncheckedCreateWithoutAdmissionInput>
  }

  export type AdmissionDocumentUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: AdmissionDocumentWhereUniqueInput
    data: XOR<AdmissionDocumentUpdateWithoutAdmissionInput, AdmissionDocumentUncheckedUpdateWithoutAdmissionInput>
  }

  export type AdmissionDocumentUpdateManyWithWhereWithoutAdmissionInput = {
    where: AdmissionDocumentScalarWhereInput
    data: XOR<AdmissionDocumentUpdateManyMutationInput, AdmissionDocumentUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type AdmissionDocumentScalarWhereInput = {
    AND?: AdmissionDocumentScalarWhereInput | AdmissionDocumentScalarWhereInput[]
    OR?: AdmissionDocumentScalarWhereInput[]
    NOT?: AdmissionDocumentScalarWhereInput | AdmissionDocumentScalarWhereInput[]
    id?: StringFilter<"AdmissionDocument"> | string
    admissionId?: StringFilter<"AdmissionDocument"> | string
    fileName?: StringFilter<"AdmissionDocument"> | string
    fileType?: StringFilter<"AdmissionDocument"> | string
    fileSize?: IntFilter<"AdmissionDocument"> | number
    filePath?: StringFilter<"AdmissionDocument"> | string
    uploadedAt?: DateTimeFilter<"AdmissionDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"AdmissionDocument"> | string | null
  }

  export type AdmissionCreateWithoutDocumentsInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdmissionsInput
    position?: PositionCreateNestedOneWithoutAdmissionsInput
    department?: DepartmentCreateNestedOneWithoutAdmissionsInput
  }

  export type AdmissionUncheckedCreateWithoutDocumentsInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
    position_id?: string | null
    department_id?: string | null
  }

  export type AdmissionCreateOrConnectWithoutDocumentsInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutDocumentsInput, AdmissionUncheckedCreateWithoutDocumentsInput>
  }

  export type AdmissionUpsertWithoutDocumentsInput = {
    update: XOR<AdmissionUpdateWithoutDocumentsInput, AdmissionUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AdmissionCreateWithoutDocumentsInput, AdmissionUncheckedCreateWithoutDocumentsInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutDocumentsInput, AdmissionUncheckedUpdateWithoutDocumentsInput>
  }

  export type AdmissionUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdmissionsNestedInput
    position?: PositionUpdateOneWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneWithoutAdmissionsNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    position_id?: NullableStringFieldUpdateOperationsInput | string | null
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutTasksInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type GroupCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutTasksInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutTasksInput, GroupUncheckedCreateWithoutTasksInput>
  }

  export type TrainingCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    instructor?: UserCreateNestedOneWithoutTrainingsInput
    training_participations?: UserTrainingCreateNestedManyWithoutTrainingsInput
  }

  export type TrainingUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    instructorId?: string | null
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutTrainingsInput
  }

  export type TrainingCreateOrConnectWithoutTasksInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutTasksInput, TrainingUncheckedCreateWithoutTasksInput>
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type GroupUpsertWithoutTasksInput = {
    update: XOR<GroupUpdateWithoutTasksInput, GroupUncheckedUpdateWithoutTasksInput>
    create: XOR<GroupCreateWithoutTasksInput, GroupUncheckedCreateWithoutTasksInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutTasksInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutTasksInput, GroupUncheckedUpdateWithoutTasksInput>
  }

  export type GroupUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type TrainingUpsertWithoutTasksInput = {
    update: XOR<TrainingUpdateWithoutTasksInput, TrainingUncheckedUpdateWithoutTasksInput>
    create: XOR<TrainingCreateWithoutTasksInput, TrainingUncheckedCreateWithoutTasksInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutTasksInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutTasksInput, TrainingUncheckedUpdateWithoutTasksInput>
  }

  export type TrainingUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    instructor?: UserUpdateOneWithoutTrainingsNestedInput
    training_participations?: UserTrainingUpdateManyWithoutTrainingsNestedInput
  }

  export type TrainingUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    training_participations?: UserTrainingUncheckedUpdateManyWithoutTrainingsNestedInput
  }

  export type TaskCreateWithoutGroupInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTasksInput
    training?: TrainingCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutGroupInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    userId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId?: string | null
  }

  export type TaskCreateOrConnectWithoutGroupInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutGroupInput, TaskUncheckedCreateWithoutGroupInput>
  }

  export type TaskCreateManyGroupInputEnvelope = {
    data: TaskCreateManyGroupInput | TaskCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutGroupsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutGroupsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type UserCreateOrConnectWithoutGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutGroupInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutGroupInput, TaskUncheckedUpdateWithoutGroupInput>
    create: XOR<TaskCreateWithoutGroupInput, TaskUncheckedCreateWithoutGroupInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutGroupInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutGroupInput, TaskUncheckedUpdateWithoutGroupInput>
  }

  export type TaskUpdateManyWithWhereWithoutGroupInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutGroupInput>
  }

  export type UserUpsertWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
  }

  export type UserUpdateManyWithWhereWithoutGroupsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutGroupsInput>
  }

  export type reportsCreateWithoutDocumentsInput = {
    id: string
    name: string
    type: string
    frequency?: string | null
    scheduledDate?: Date | string | null
    created_at?: Date | string
    users: UserCreateNestedOneWithoutReportsInput
  }

  export type reportsUncheckedCreateWithoutDocumentsInput = {
    id: string
    name: string
    type: string
    generated_by: string
    frequency?: string | null
    scheduledDate?: Date | string | null
    created_at?: Date | string
  }

  export type reportsCreateOrConnectWithoutDocumentsInput = {
    where: reportsWhereUniqueInput
    create: XOR<reportsCreateWithoutDocumentsInput, reportsUncheckedCreateWithoutDocumentsInput>
  }

  export type reportsUpsertWithoutDocumentsInput = {
    update: XOR<reportsUpdateWithoutDocumentsInput, reportsUncheckedUpdateWithoutDocumentsInput>
    create: XOR<reportsCreateWithoutDocumentsInput, reportsUncheckedCreateWithoutDocumentsInput>
    where?: reportsWhereInput
  }

  export type reportsUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: reportsWhereInput
    data: XOR<reportsUpdateWithoutDocumentsInput, reportsUncheckedUpdateWithoutDocumentsInput>
  }

  export type reportsUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportsUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    generated_by?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutTrainingsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTrainingsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutTrainingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrainingsInput, UserUncheckedCreateWithoutTrainingsInput>
  }

  export type UserTrainingCreateWithoutTrainingsInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    progress?: number | null
    users: UserCreateNestedOneWithoutTraining_participationsInput
    documents?: TrainingDocumentCreateNestedManyWithoutUserTrainingInput
  }

  export type UserTrainingUncheckedCreateWithoutTrainingsInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    user_id: string
    progress?: number | null
    documents?: TrainingDocumentUncheckedCreateNestedManyWithoutUserTrainingInput
  }

  export type UserTrainingCreateOrConnectWithoutTrainingsInput = {
    where: UserTrainingWhereUniqueInput
    create: XOR<UserTrainingCreateWithoutTrainingsInput, UserTrainingUncheckedCreateWithoutTrainingsInput>
  }

  export type UserTrainingCreateManyTrainingsInputEnvelope = {
    data: UserTrainingCreateManyTrainingsInput | UserTrainingCreateManyTrainingsInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTasksInput
    group?: GroupCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    userId?: string | null
    groupId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutTrainingInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTrainingInput, TaskUncheckedCreateWithoutTrainingInput>
  }

  export type TaskCreateManyTrainingInputEnvelope = {
    data: TaskCreateManyTrainingInput | TaskCreateManyTrainingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTrainingsInput = {
    update: XOR<UserUpdateWithoutTrainingsInput, UserUncheckedUpdateWithoutTrainingsInput>
    create: XOR<UserCreateWithoutTrainingsInput, UserUncheckedCreateWithoutTrainingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrainingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrainingsInput, UserUncheckedUpdateWithoutTrainingsInput>
  }

  export type UserUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserTrainingUpsertWithWhereUniqueWithoutTrainingsInput = {
    where: UserTrainingWhereUniqueInput
    update: XOR<UserTrainingUpdateWithoutTrainingsInput, UserTrainingUncheckedUpdateWithoutTrainingsInput>
    create: XOR<UserTrainingCreateWithoutTrainingsInput, UserTrainingUncheckedCreateWithoutTrainingsInput>
  }

  export type UserTrainingUpdateWithWhereUniqueWithoutTrainingsInput = {
    where: UserTrainingWhereUniqueInput
    data: XOR<UserTrainingUpdateWithoutTrainingsInput, UserTrainingUncheckedUpdateWithoutTrainingsInput>
  }

  export type UserTrainingUpdateManyWithWhereWithoutTrainingsInput = {
    where: UserTrainingScalarWhereInput
    data: XOR<UserTrainingUpdateManyMutationInput, UserTrainingUncheckedUpdateManyWithoutTrainingsInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutTrainingInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTrainingInput, TaskUncheckedUpdateWithoutTrainingInput>
    create: XOR<TaskCreateWithoutTrainingInput, TaskUncheckedCreateWithoutTrainingInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTrainingInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTrainingInput, TaskUncheckedUpdateWithoutTrainingInput>
  }

  export type TaskUpdateManyWithWhereWithoutTrainingInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTrainingInput>
  }

  export type TrainingCreateWithoutTraining_participationsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    instructor?: UserCreateNestedOneWithoutTrainingsInput
    tasks?: TaskCreateNestedManyWithoutTrainingInput
  }

  export type TrainingUncheckedCreateWithoutTraining_participationsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
    instructorId?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutTrainingInput
  }

  export type TrainingCreateOrConnectWithoutTraining_participationsInput = {
    where: TrainingWhereUniqueInput
    create: XOR<TrainingCreateWithoutTraining_participationsInput, TrainingUncheckedCreateWithoutTraining_participationsInput>
  }

  export type UserCreateWithoutTraining_participationsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    reports?: reportsCreateNestedManyWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTraining_participationsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    reports?: reportsUncheckedCreateNestedManyWithoutUsersInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutTraining_participationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTraining_participationsInput, UserUncheckedCreateWithoutTraining_participationsInput>
  }

  export type TrainingDocumentCreateWithoutUserTrainingInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type TrainingDocumentUncheckedCreateWithoutUserTrainingInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type TrainingDocumentCreateOrConnectWithoutUserTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    create: XOR<TrainingDocumentCreateWithoutUserTrainingInput, TrainingDocumentUncheckedCreateWithoutUserTrainingInput>
  }

  export type TrainingDocumentCreateManyUserTrainingInputEnvelope = {
    data: TrainingDocumentCreateManyUserTrainingInput | TrainingDocumentCreateManyUserTrainingInput[]
    skipDuplicates?: boolean
  }

  export type TrainingUpsertWithoutTraining_participationsInput = {
    update: XOR<TrainingUpdateWithoutTraining_participationsInput, TrainingUncheckedUpdateWithoutTraining_participationsInput>
    create: XOR<TrainingCreateWithoutTraining_participationsInput, TrainingUncheckedCreateWithoutTraining_participationsInput>
    where?: TrainingWhereInput
  }

  export type TrainingUpdateToOneWithWhereWithoutTraining_participationsInput = {
    where?: TrainingWhereInput
    data: XOR<TrainingUpdateWithoutTraining_participationsInput, TrainingUncheckedUpdateWithoutTraining_participationsInput>
  }

  export type TrainingUpdateWithoutTraining_participationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    instructor?: UserUpdateOneWithoutTrainingsNestedInput
    tasks?: TaskUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutTraining_participationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorId?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type UserUpsertWithoutTraining_participationsInput = {
    update: XOR<UserUpdateWithoutTraining_participationsInput, UserUncheckedUpdateWithoutTraining_participationsInput>
    create: XOR<UserCreateWithoutTraining_participationsInput, UserUncheckedCreateWithoutTraining_participationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTraining_participationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTraining_participationsInput, UserUncheckedUpdateWithoutTraining_participationsInput>
  }

  export type UserUpdateWithoutTraining_participationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTraining_participationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type TrainingDocumentUpsertWithWhereUniqueWithoutUserTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    update: XOR<TrainingDocumentUpdateWithoutUserTrainingInput, TrainingDocumentUncheckedUpdateWithoutUserTrainingInput>
    create: XOR<TrainingDocumentCreateWithoutUserTrainingInput, TrainingDocumentUncheckedCreateWithoutUserTrainingInput>
  }

  export type TrainingDocumentUpdateWithWhereUniqueWithoutUserTrainingInput = {
    where: TrainingDocumentWhereUniqueInput
    data: XOR<TrainingDocumentUpdateWithoutUserTrainingInput, TrainingDocumentUncheckedUpdateWithoutUserTrainingInput>
  }

  export type TrainingDocumentUpdateManyWithWhereWithoutUserTrainingInput = {
    where: TrainingDocumentScalarWhereInput
    data: XOR<TrainingDocumentUpdateManyMutationInput, TrainingDocumentUncheckedUpdateManyWithoutUserTrainingInput>
  }

  export type TrainingDocumentScalarWhereInput = {
    AND?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
    OR?: TrainingDocumentScalarWhereInput[]
    NOT?: TrainingDocumentScalarWhereInput | TrainingDocumentScalarWhereInput[]
    id?: StringFilter<"TrainingDocument"> | string
    userTrainingId?: StringFilter<"TrainingDocument"> | string
    fileName?: StringFilter<"TrainingDocument"> | string
    fileType?: StringFilter<"TrainingDocument"> | string
    fileSize?: IntFilter<"TrainingDocument"> | number
    filePath?: StringFilter<"TrainingDocument"> | string
    uploadedAt?: DateTimeFilter<"TrainingDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"TrainingDocument"> | string | null
  }

  export type UserTrainingCreateWithoutDocumentsInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    progress?: number | null
    trainings: TrainingCreateNestedOneWithoutTraining_participationsInput
    users: UserCreateNestedOneWithoutTraining_participationsInput
  }

  export type UserTrainingUncheckedCreateWithoutDocumentsInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    training_id: string
    user_id: string
    progress?: number | null
  }

  export type UserTrainingCreateOrConnectWithoutDocumentsInput = {
    where: UserTrainingWhereUniqueInput
    create: XOR<UserTrainingCreateWithoutDocumentsInput, UserTrainingUncheckedCreateWithoutDocumentsInput>
  }

  export type UserTrainingUpsertWithoutDocumentsInput = {
    update: XOR<UserTrainingUpdateWithoutDocumentsInput, UserTrainingUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserTrainingCreateWithoutDocumentsInput, UserTrainingUncheckedCreateWithoutDocumentsInput>
    where?: UserTrainingWhereInput
  }

  export type UserTrainingUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserTrainingWhereInput
    data: XOR<UserTrainingUpdateWithoutDocumentsInput, UserTrainingUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserTrainingUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    trainings?: TrainingUpdateOneRequiredWithoutTraining_participationsNestedInput
    users?: UserUpdateOneRequiredWithoutTraining_participationsNestedInput
  }

  export type UserTrainingUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ReportDocumentCreateWithoutReportInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploaded_at?: Date | string
    uploaded_by?: string | null
  }

  export type ReportDocumentUncheckedCreateWithoutReportInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploaded_at?: Date | string
    uploaded_by?: string | null
  }

  export type ReportDocumentCreateOrConnectWithoutReportInput = {
    where: ReportDocumentWhereUniqueInput
    create: XOR<ReportDocumentCreateWithoutReportInput, ReportDocumentUncheckedCreateWithoutReportInput>
  }

  export type ReportDocumentCreateManyReportInputEnvelope = {
    data: ReportDocumentCreateManyReportInput | ReportDocumentCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    surname?: string | null
    admissions?: AdmissionCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingCreateNestedManyWithoutUsersInput
    trainings?: TrainingCreateNestedManyWithoutInstructorInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    position?: PositionCreateNestedOneWithoutUsersInput
    groups?: GroupCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    positionId?: string | null
    surname?: string | null
    admissions?: AdmissionUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: ChatMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentMessages?: ChatMessageUncheckedCreateNestedManyWithoutSenderInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_evaluator_idTousersInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedCreateNestedManyWithoutUsers_performance_evaluations_user_idTousersInput
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    training_participations?: UserTrainingUncheckedCreateNestedManyWithoutUsersInput
    trainings?: TrainingUncheckedCreateNestedManyWithoutInstructorInput
    groups?: GroupUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type ReportDocumentUpsertWithWhereUniqueWithoutReportInput = {
    where: ReportDocumentWhereUniqueInput
    update: XOR<ReportDocumentUpdateWithoutReportInput, ReportDocumentUncheckedUpdateWithoutReportInput>
    create: XOR<ReportDocumentCreateWithoutReportInput, ReportDocumentUncheckedCreateWithoutReportInput>
  }

  export type ReportDocumentUpdateWithWhereUniqueWithoutReportInput = {
    where: ReportDocumentWhereUniqueInput
    data: XOR<ReportDocumentUpdateWithoutReportInput, ReportDocumentUncheckedUpdateWithoutReportInput>
  }

  export type ReportDocumentUpdateManyWithWhereWithoutReportInput = {
    where: ReportDocumentScalarWhereInput
    data: XOR<ReportDocumentUpdateManyMutationInput, ReportDocumentUncheckedUpdateManyWithoutReportInput>
  }

  export type ReportDocumentScalarWhereInput = {
    AND?: ReportDocumentScalarWhereInput | ReportDocumentScalarWhereInput[]
    OR?: ReportDocumentScalarWhereInput[]
    NOT?: ReportDocumentScalarWhereInput | ReportDocumentScalarWhereInput[]
    id?: StringFilter<"ReportDocument"> | string
    reportId?: StringFilter<"ReportDocument"> | string
    fileName?: StringFilter<"ReportDocument"> | string
    fileType?: StringFilter<"ReportDocument"> | string
    fileSize?: IntFilter<"ReportDocument"> | number
    filePath?: StringFilter<"ReportDocument"> | string
    uploaded_at?: DateTimeFilter<"ReportDocument"> | Date | string
    uploaded_by?: StringNullableFilter<"ReportDocument"> | string | null
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ChatMessageCreateManyReceiverInput = {
    id?: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
    sender_id: string
  }

  export type ChatMessageCreateManySenderInput = {
    id?: string
    receiverId: string
    message: string
    timestamp?: Date | string
    isBot?: boolean
    isRead?: boolean
    messageType?: string
  }

  export type PerformanceEvaluationCreateManyUsers_performance_evaluations_evaluator_idTousersInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
  }

  export type PerformanceEvaluationCreateManyUsers_performance_evaluations_user_idTousersInput = {
    id?: string
    period: string
    score: number
    goals?: string | null
    achievements?: string | null
    feedback?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluator_id: string
  }

  export type reportsCreateManyUsersInput = {
    id: string
    name: string
    type: string
    frequency?: string | null
    scheduledDate?: Date | string | null
    created_at?: Date | string
  }

  export type TaskCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    groupId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId?: string | null
  }

  export type UserTrainingCreateManyUsersInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    training_id: string
    progress?: number | null
  }

  export type TrainingCreateManyInstructorInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    maxParticipants?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: number | null
  }

  export type ChatMessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isBot?: BoolFieldUpdateOperationsInput | boolean
    isRead?: BoolFieldUpdateOperationsInput | boolean
    messageType?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceEvaluationUpdateWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_performance_evaluations_user_idTousers?: UserUpdateOneRequiredWithoutPerformance_evaluations_performance_evaluations_user_idTousersNestedInput
  }

  export type PerformanceEvaluationUncheckedUpdateWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceEvaluationUpdateWithoutUsers_performance_evaluations_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users_performance_evaluations_evaluator_idTousers?: UserUpdateOneRequiredWithoutPerformance_evaluations_performance_evaluations_evaluator_idTousersNestedInput
  }

  export type PerformanceEvaluationUncheckedUpdateWithoutUsers_performance_evaluations_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator_id?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    goals?: NullableStringFieldUpdateOperationsInput | string | null
    achievements?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator_id?: StringFieldUpdateOperationsInput | string
  }

  export type reportsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ReportDocumentUpdateManyWithoutReportNestedInput
  }

  export type reportsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: ReportDocumentUncheckedUpdateManyWithoutReportNestedInput
  }

  export type reportsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: GroupUpdateOneWithoutTasksNestedInput
    training?: TrainingUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTrainingUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    trainings?: TrainingUpdateOneRequiredWithoutTraining_participationsNestedInput
    documents?: TrainingDocumentUpdateManyWithoutUserTrainingNestedInput
  }

  export type UserTrainingUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    documents?: TrainingDocumentUncheckedUpdateManyWithoutUserTrainingNestedInput
  }

  export type UserTrainingUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TrainingUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    training_participations?: UserTrainingUpdateManyWithoutTrainingsNestedInput
    tasks?: TaskUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    training_participations?: UserTrainingUncheckedUpdateManyWithoutTrainingsNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutTrainingNestedInput
  }

  export type TrainingUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type GroupUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyPositionInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departmentId?: string | null
    surname?: string | null
  }

  export type AdmissionCreateManyPositionInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
    department_id?: string | null
  }

  export type UserUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneWithoutAdmissionsNestedInput
    documents?: AdmissionDocumentUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: AdmissionDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    department_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyDepartmentInput = {
    id?: string
    email: string
    password_hash: string
    name: string
    role?: string
    isActive?: boolean
    last_login?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    positionId?: string | null
    surname?: string | null
  }

  export type AdmissionCreateManyDepartmentInput = {
    id?: string
    hireDate: Date | string
    contractType: string
    salary?: number | null
    benefits?: string | null
    terminationDate?: Date | string | null
    terminationReason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user_id: string
    position_id?: string | null
  }

  export type UserUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
    groups?: GroupUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdmissionsNestedInput
    position?: PositionUpdateOneWithoutAdmissionsNestedInput
    documents?: AdmissionDocumentUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    position_id?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: AdmissionDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    contractType?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    benefits?: NullableStringFieldUpdateOperationsInput | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationReason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    position_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionDocumentCreateManyAdmissionInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type AdmissionDocumentUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionDocumentUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionDocumentUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyGroupInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    userId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainingId?: string | null
  }

  export type TaskUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTasksNestedInput
    training?: TrainingUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    reports?: reportsUpdateManyWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUpdateManyWithoutInstructorNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    position?: PositionUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    admissions?: AdmissionUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: ChatMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentMessages?: ChatMessageUncheckedUpdateManyWithoutSenderNestedInput
    performance_evaluations_performance_evaluations_evaluator_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_evaluator_idTousersNestedInput
    performance_evaluations_performance_evaluations_user_idTousers?: PerformanceEvaluationUncheckedUpdateManyWithoutUsers_performance_evaluations_user_idTousersNestedInput
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    reports?: reportsUncheckedUpdateManyWithoutUsersNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    training_participations?: UserTrainingUncheckedUpdateManyWithoutUsersNestedInput
    trainings?: TrainingUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTrainingCreateManyTrainingsInput = {
    id?: string
    enrolledAt?: Date | string
    completedAt?: Date | string | null
    status?: string
    score?: number | null
    certificate?: string | null
    user_id: string
    progress?: number | null
  }

  export type TaskCreateManyTrainingInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    userId?: string | null
    groupId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTrainingUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    users?: UserUpdateOneRequiredWithoutTraining_participationsNestedInput
    documents?: TrainingDocumentUpdateManyWithoutUserTrainingNestedInput
  }

  export type UserTrainingUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
    documents?: TrainingDocumentUncheckedUpdateManyWithoutUserTrainingNestedInput
  }

  export type UserTrainingUncheckedUpdateManyWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    certificate?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    progress?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TaskUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTasksNestedInput
    group?: GroupUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDocumentCreateManyUserTrainingInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploadedAt?: Date | string
    uploadedBy?: string | null
  }

  export type TrainingDocumentUpdateWithoutUserTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingDocumentUncheckedUpdateWithoutUserTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrainingDocumentUncheckedUpdateManyWithoutUserTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportDocumentCreateManyReportInput = {
    id?: string
    fileName: string
    fileType: string
    fileSize: number
    filePath: string
    uploaded_at?: Date | string
    uploaded_by?: string | null
  }

  export type ReportDocumentUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportDocumentUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportDocumentUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaded_by?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PositionCountOutputTypeDefaultArgs instead
     */
    export type PositionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PositionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionCountOutputTypeDefaultArgs instead
     */
    export type AdmissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupCountOutputTypeDefaultArgs instead
     */
    export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingCountOutputTypeDefaultArgs instead
     */
    export type TrainingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTrainingCountOutputTypeDefaultArgs instead
     */
    export type UserTrainingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTrainingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportsCountOutputTypeDefaultArgs instead
     */
    export type ReportsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PositionDefaultArgs instead
     */
    export type PositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PositionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerformanceEvaluationDefaultArgs instead
     */
    export type PerformanceEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerformanceEvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionDefaultArgs instead
     */
    export type AdmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionDocumentDefaultArgs instead
     */
    export type AdmissionDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupDefaultArgs instead
     */
    export type GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDocumentDefaultArgs instead
     */
    export type ReportDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingDefaultArgs instead
     */
    export type SettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatMessageDefaultArgs instead
     */
    export type ChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingDefaultArgs instead
     */
    export type TrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTrainingDefaultArgs instead
     */
    export type UserTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTrainingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingDocumentDefaultArgs instead
     */
    export type TrainingDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupporterDefaultArgs instead
     */
    export type SupporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupporterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reportsDefaultArgs instead
     */
    export type reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reportsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}